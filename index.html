<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Boids with Glowing Tree</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; background-color: #111; color: #fff; overflow: hidden; }
        #info { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); padding: 15px 25px; background-color: rgba(0, 0, 0, 0.5); border-radius: 12px; text-align: center; font-size: 16px; z-index: 10; max-width: 90%; }
        #vr-button { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; border: 1px solid #fff; background-color: rgba(0,0,0,0.5); color: #fff; padding: 12px 24px; border-radius: 999px; cursor: pointer; font-weight: 600; }
        #vr-button:hover { background-color: rgba(255,255,255,0.2); }
        
        /* VR Mode - Specifically target UI elements only, not WebXR internals */
        .vr-active #info {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active #vr-button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active #threejs-vr-button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active div:not([id]) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        /* Ensure canvas and WebXR elements remain visible */
        .vr-active canvas {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">
        WebXR Boids: Flocking, Tossing, Predators & Force Punch<br>
        Grab boids to toss • Shake for predators • Make fist and punch to blast!<br>
        <small>Point with right hand for 3 seconds to teleport</small>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let camera, scene, renderer, clock;
        let boids = [];
        let predators = [];
        let particles = [];
        let particlePool = []; // Object pool for particles
        const PARTICLE_POOL_SIZE = 100;
        let hand1, hand2;
        
        let interactiveVoxels = [];
        let groundVoxels = [];
        let heldVoxelMesh1, heldVoxelMesh2;
        let groundVoxelsMesh;
        // Game of Life monolith system removed for performance
        const REVIVAL_TIME = 3; 
        const SHAKE_THRESHOLD = 0.8; // Reduced shake intensity needed to create predator

        const initialBoidCount = 25; // Further reduced by 50% for better performance
        const interactiveVoxelCount = 0; // Disabled for performance
        const groundVoxelCount = 15; // Scattered ground voxels for testing
        const boundSize = 20;
        
        // Punch blast variables
        let punchCooldown1 = 0;
        let punchCooldown2 = 0;
        const PUNCH_COOLDOWN = 0.5; // Seconds between punches
        const PUNCH_FORCE_RADIUS = 2.0; // Radius of punch force blast
        
        // Performance optimization variables - Aggressive for 120fps Quest 3
        let frameCount = 0;
        const OPTIMIZATION_INTERVAL = 40; // Reduced frequency for 120fps
        const SPACE_UPDATE_INTERVAL = 120; // Update stars every 120 frames (1 second at 120fps)
        const ORBITAL_UPDATE_INTERVAL = 60; // Update asteroids every 60 frames (0.5 seconds)
        const PARTICLE_UPDATE_INTERVAL = 30; // Update particles every 30 frames
        // Fountain constants removed - system eliminated
        
        // Level-of-Detail (LOD) system for 120fps
        const LOD_DISTANCES = {
            CLOSE: 10,    // Full detail
            MEDIUM: 30,   // Reduced detail
            FAR: 60       // Minimal detail
        };
        
        // Frame rate monitoring for dynamic scaling
        let frameRateHistory = [];
        let currentQualityLevel = 1.0; // 1.0 = full quality, 0.5 = half quality
        const TARGET_FRAME_RATE = 120;
        const MIN_FRAME_RATE = 90;
        
        // Temporal update spreading for 120fps
        let updateQueues = {
            fountain: 0,
            skyBattle: 1,
            particles: 2
        };
        const TEMPORAL_SPREAD_FRAMES = 6; // Spread updates across 6 frames
        
        // Spatial partitioning for collision detection optimization
        class SpatialGrid {
            constructor(cellSize = 5.0) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }
            
            clear() {
                this.grid.clear();
            }
            
            getKey(x, y, z) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                const gz = Math.floor(z / this.cellSize);
                return `${gx},${gy},${gz}`;
            }
            
            insert(object) {
                const key = this.getKey(object.position.x, object.position.y, object.position.z);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(object);
            }
            
            getNearby(position, radius = 1.0) {
                const nearby = [];
                const cellsToCheck = Math.ceil(radius / this.cellSize);
                
                for (let dx = -cellsToCheck; dx <= cellsToCheck; dx++) {
                    for (let dy = -cellsToCheck; dy <= cellsToCheck; dy++) {
                        for (let dz = -cellsToCheck; dz <= cellsToCheck; dz++) {
                            const key = this.getKey(
                                position.x + dx * this.cellSize,
                                position.y + dy * this.cellSize,
                                position.z + dz * this.cellSize
                            );
                            const cell = this.grid.get(key);
                            if (cell) {
                                nearby.push(...cell);
                            }
                        }
                    }
                }
                return nearby;
            }
        }
        
        const spatialGrid = new SpatialGrid(3.0); // 3 unit cells for boid flocking
        
        // Frustum culling
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();
        const CULLING_DISTANCE = 100; // Distance beyond which objects are culled
        
        // Shared materials for performance optimization
        const sharedMaterials = {
            boidMaterial: null,
            particleMaterial: null,
            starMaterial: null,
            spaceMaterial: null,
            fountainMaterial: null
        };
        
        
        // Three-layer sky system
        let stars = [];
        let asteroids = [];
        let spaceShips = [];
        let spaceBullets = [];
        let shootingStars = [];
        
        // Layer 1: Atmosphere (0-30m above user) - Boids flight zone
        const ATMOSPHERE_MIN_HEIGHT = 0;
        const ATMOSPHERE_MAX_HEIGHT = 30;
        const ATMOSPHERE_RADIUS = 40;
        
        // Layer 2: Orbital Space (30-60m above user) - Asteroids simulation
        const ORBITAL_MIN_HEIGHT = 30;
        const ORBITAL_MAX_HEIGHT = 60;
        const ORBITAL_RADIUS = 120; // Much larger area for asteroids and ships
        const ASTEROID_COUNT = 6;
        const SPACESHIP_COUNT = 1;
        const ASTEROID_SPEED = 25.0; // Much higher speed for dramatic movement
        const SPACESHIP_SPEED = 8.0; // Reduced by 50% for better control
        const SPACE_BULLET_SPEED = 35.0; // Much faster than spaceship (8.0 max speed)
        
        // Layer 3: Space (60m+ above user) - Distant starfield
        const SPACE_MIN_HEIGHT = 60;
        const SPACE_MAX_HEIGHT = 100;
        const SPACE_RADIUS = 200; // Much larger area for stars
        const SKY_RADIUS = 150; // Define SKY_RADIUS for bullet bounds
        const STAR_COUNT = 150; // More stars for distant effect
        const SHOOTING_STAR_SPAWN_RATE = 0.05;
        const SHOOTING_STAR_SPEED = 15.0;
        
        
        // Teleportation system
        let teleportRaycaster = new THREE.Raycaster();
        let teleportIndicator = null;
        let teleportHoldStartTime = 0;
        let teleportTargetPosition = null;
        let teleportReticle = null;
        let teleportRayLine = null;
        let isPointingForTeleport = false;
        const TELEPORT_HOLD_TIME = 3.0; // Seconds to hold for teleport
        const TELEPORT_SHAKE_TOLERANCE = 0.2; // Allowance for hand shake
        const TELEPORT_MAX_DISTANCE = 15; // Maximum teleport range

        // VR Debug overlay system
        let debugOverlay = null;
        let debugText = null;
        let debugInfo = {
            leftHand: { isFist: false, velocity: 0, cooldown: 0, thumbDist: 0, indexDist: 0, middleDist: 0, isReady: false, punchCount: 0 },
            rightHand: { isFist: false, velocity: 0, cooldown: 0, thumbDist: 0, indexDist: 0, middleDist: 0, isReady: false, punchCount: 0 },
            frameCount: 0
        };

        // --- NEW: Obstacles for boids to avoid ---
        // Tron trees and obstacles removed for performance
        
        
        
        // --- Sky Asteroids Classes ---
        class Star {
            constructor() {
                // Position in distant space layer (60m+ above user)
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * SPACE_RADIUS,
                    SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                    (Math.random() - 0.5) * SPACE_RADIUS
                );
                this.brightness = Math.random() * 0.8 + 0.2;
                this.twinkleSpeed = Math.random() * 2 + 1;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const geometry = new THREE.SphereGeometry(0.2, 8, 8); // Larger and more detailed for better VR visibility
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: this.brightness * 0.8 + 0.2, // Ensure minimum visibility
                    emissive: 0x222222 // Slight glow for better visibility
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(elapsedTime) {
                if (this.mesh) {
                    const twinkle = (Math.sin(elapsedTime * this.twinkleSpeed) + 1) / 2;
                    // Enhanced twinkling with better minimum visibility
                    this.mesh.material.opacity = (this.brightness * 0.8 + 0.2) * (0.5 + 0.5 * twinkle);
                }
            }
        }
        
        class Asteroid {
            constructor(position, size = 'large') {
                // Position in orbital space layer (30-60m above user)
                this.position = position || new THREE.Vector3(
                    (Math.random() - 0.5) * ORBITAL_RADIUS,
                    ORBITAL_MIN_HEIGHT + Math.random() * (ORBITAL_MAX_HEIGHT - ORBITAL_MIN_HEIGHT),
                    (Math.random() - 0.5) * ORBITAL_RADIUS
                );
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * ASTEROID_SPEED * 3.0, // Even more varied movement
                    (Math.random() - 0.5) * ASTEROID_SPEED * 2.0, // More dramatic Y movement
                    (Math.random() - 0.5) * ASTEROID_SPEED * 3.0
                );
                this.rotation = new THREE.Vector3(
                    Math.random() * 0.05, // Increased rotation for more visible movement
                    Math.random() * 0.05,
                    Math.random() * 0.05
                );
                this.size = size; // large, medium, small
                this.health = size === 'large' ? 3 : size === 'medium' ? 2 : 1;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const sizes = { large: 2.0, medium: 1.2, small: 0.7 };
                const radius = sizes[this.size];
                
                // Create irregular asteroid shape
                const geometry = new THREE.DodecahedronGeometry(radius, 0);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x888888,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                const oldPosition = this.position.clone();
                
                // FORCE CONSTANT MOVEMENT - bypass all other logic for testing
                this.position.x += 0.2; // Move 0.2 units per frame regardless of deltaTime
                this.position.z += 0.1; // Move diagonally for visibility
                
                // Debug minimal logging
                if (Math.random() < 0.05) {
                    console.log(`🌌 FORCED movement: position(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)})`);
                }
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.x += this.rotation.x;
                    this.mesh.rotation.y += this.rotation.y;
                    this.mesh.rotation.z += this.rotation.z;
                }
                
                // Wrap around orbital space boundaries (30-60m layer)
                const halfRadius = ORBITAL_RADIUS / 2;
                if (this.position.x > halfRadius) {
                    this.position.x = -halfRadius;
                }
                if (this.position.x < -halfRadius) {
                    this.position.x = halfRadius;
                }
                if (this.position.z > halfRadius) {
                    this.position.z = -halfRadius;
                }
                if (this.position.z < -halfRadius) {
                    this.position.z = halfRadius;
                }
                
                // Keep within height bounds
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                
                // Enhanced debug logging for asteroid movement
                const moved = oldPosition.distanceTo(this.position) > 0.1;
                if (moved && Math.random() < 0.05) { // More frequent logging
                    console.log(`🌌 Asteroid moving: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) speed=${ASTEROID_SPEED}`);
                }
            }
            
            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    this.split();
                    return true; // Mark for removal
                }
                return false;
            }
            
            split() {
                if (this.size === 'large') {
                    // Split into 2 medium asteroids
                    for (let i = 0; i < 2; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        const newAsteroid = new Asteroid(this.position.clone().add(offset), 'medium');
                        asteroids.push(newAsteroid);
                    }
                } else if (this.size === 'medium') {
                    // Split into 2 small asteroids
                    for (let i = 0; i < 2; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 1,
                            (Math.random() - 0.5) * 1,
                            (Math.random() - 0.5) * 1
                        );
                        const newAsteroid = new Asteroid(this.position.clone().add(offset), 'small');
                        asteroids.push(newAsteroid);
                    }
                }
                
                this.destroy();
                console.log(`💥 ${this.size} asteroid destroyed!`);
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        class SpaceShip {
            constructor() {
                // Position in orbital space layer (30-60m above user)
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * ORBITAL_RADIUS,
                    ORBITAL_MIN_HEIGHT + Math.random() * (ORBITAL_MAX_HEIGHT - ORBITAL_MIN_HEIGHT),
                    (Math.random() - 0.5) * ORBITAL_RADIUS
                );
                this.velocity = new THREE.Vector3();
                this.rotation = Math.random() * Math.PI * 2;
                this.angularVelocity = 0;
                this.target = null;
                this.lastFireTime = 0;
                this.mesh = null;
                this.thrust = false;
                
                this.createMesh();
            }
            
            createMesh() {
                const shipGroup = new THREE.Group();
                
                // Appropriately sized triangular ship shape for VR
                const shipGeometry = new THREE.ConeGeometry(1.0, 3.0, 3); // Reasonable size for VR visibility
                const shipMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 1.0,
                    emissive: 0x006666
                });
                const ship = new THREE.Mesh(shipGeometry, shipMaterial);
                ship.rotation.x = Math.PI / 2; // Point forward
                shipGroup.add(ship);
                
                // Add engine glow effect
                const engineGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const engineMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    emissive: 0x00aaff,
                    transparent: true,
                    opacity: 0.8
                });
                const engineGlow = new THREE.Mesh(engineGeometry, engineMaterial);
                engineGlow.position.z = -1.0; // Behind the ship
                shipGroup.add(engineGlow);
                this.engineGlow = engineGlow;
                
                this.mesh = shipGroup;
                this.mesh.position.copy(this.position);
                this.mesh.visible = true;
                scene.add(shipGroup);
                
                console.log('Enhanced spaceship created with maximum visibility');
            }
            
            update(deltaTime, elapsedTime) {
                // Find nearest asteroid
                this.findTarget();
                
                // AI behavior
                this.updateAI(deltaTime);
                
                // Update physics
                const oldPosition = this.position.clone();
                
                // Use velocity-based movement from AI with forced deltaTime
                const forcedDeltaTime = 1/60; // Assume 60fps to bypass deltaTime issues
                this.position.add(this.velocity.clone().multiplyScalar(forcedDeltaTime));
                this.rotation += this.angularVelocity * forcedDeltaTime;
                
                // Apply velocity damping to prevent runaway acceleration
                this.velocity.multiplyScalar(0.98);
                this.angularVelocity *= 0.9;
                
                // Debug minimal logging
                if (Math.random() < 0.05) {
                    console.log(`🚀 AI spaceship movement: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) target=${this.target ? 'YES' : 'NO'} thrust=${this.thrust ? 'YES' : 'NO'}`);
                }
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.y = this.rotation;
                    
                    // Update engine glow based on thrust
                    if (this.engineGlow) {
                        const thrustIntensity = this.thrust ? 1.0 : 0.3;
                        this.engineGlow.material.opacity = 0.4 + thrustIntensity * 0.6;
                        this.engineGlow.scale.set(thrustIntensity, thrustIntensity, thrustIntensity);
                    }
                }
                
                // Enhanced debug logging for spaceship movement
                const moved = oldPosition.distanceTo(this.position) > 0.1;
                if (moved && Math.random() < 0.05) { // More frequent logging
                    console.log(`🚀 Spaceship moving: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) target=${this.target ? 'YES' : 'NO'}`);
                }
                
                // Wrap around orbital space boundaries (30-60m layer)
                const halfRadius = ORBITAL_RADIUS / 2;
                if (this.position.x > halfRadius) {
                    this.position.x = -halfRadius;
                }
                if (this.position.x < -halfRadius) {
                    this.position.x = halfRadius;
                }
                if (this.position.z > halfRadius) {
                    this.position.z = -halfRadius;
                }
                if (this.position.z < -halfRadius) {
                    this.position.z = halfRadius;
                }
                
                // Keep within height bounds
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                
                // Try to fire
                this.tryFire(elapsedTime);
            }
            
            findTarget() {
                let closestAsteroid = null;
                let closestDistance = 80; // Much longer detection range for aggressive hunting
                
                // Always actively hunt for asteroids
                for (const asteroid of asteroids) {
                    if (!asteroid || asteroid.health <= 0) continue;
                    const distance = this.position.distanceTo(asteroid.position);
                    if (distance < closestDistance) {
                        closestAsteroid = asteroid;
                        closestDistance = distance;
                    }
                }
                
                // Debug target acquisition
                if (this.target !== closestAsteroid) {
                    if (closestAsteroid) {
                        console.log(`🎯 Spaceship acquired new target at distance ${closestDistance.toFixed(1)}`);
                    } else if (this.target) {
                        console.log(`❌ Spaceship lost target`);
                    }
                }
                
                this.target = closestAsteroid;
            }
            
            updateAI(deltaTime) {
                // Reset thrust flag
                this.thrust = false;
                
                // Use forced deltaTime for consistency
                const forcedDeltaTime = 1/60; // Assume 60fps to bypass deltaTime issues
                
                if (this.target) {
                    const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                    const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                    
                    // Turn towards target
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    this.angularVelocity += Math.sign(angleDiff) * 0.1;
                    
                    // Always thrust towards target - more aggressive behavior
                    const thrustForce = new THREE.Vector3(
                        Math.sin(this.rotation),
                        0,
                        Math.cos(this.rotation)
                    ).multiplyScalar(SPACESHIP_SPEED * forcedDeltaTime * 15.0); // Even higher thrust for more dramatic movement
                    
                    this.velocity.add(thrustForce);
                    this.thrust = true;
                    
                    // Much more aggressive turning for faster target acquisition
                    this.angularVelocity += Math.sign(angleDiff) * 0.5;
                } else {
                    // More active patrol when no target
                    if (Math.random() < 0.05) {
                        this.angularVelocity += (Math.random() - 0.5) * 1.0;
                    }
                    if (Math.random() < 0.3) { // Much more frequent thrust for active patrol
                        const thrustForce = new THREE.Vector3(
                            Math.sin(this.rotation),
                            0,
                            Math.cos(this.rotation)
                        ).multiplyScalar(SPACESHIP_SPEED * forcedDeltaTime * 12.0); // Much faster patrol movement
                        
                        this.velocity.add(thrustForce);
                        this.thrust = true;
                    }
                }
            }
            
            tryFire(elapsedTime) {
                if (!this.target) return;
                if (elapsedTime - this.lastFireTime < 0.3) return; // Faster fire rate
                
                const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                const distance = toTarget.length();
                
                // Fire if target is within range and roughly aimed
                if (distance < 40) { // Longer firing range to match detection range
                    const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Very lenient aiming requirement for more action
                    if (Math.abs(angleDiff) < Math.PI / 2.5) { // Even wider 72 degree cone for better hits
                        this.fire();
                        this.lastFireTime = elapsedTime;
                        console.log(`🚀 Spaceship firing at asteroid! Distance: ${distance.toFixed(1)} units, angle diff: ${(angleDiff * 180 / Math.PI).toFixed(1)} degrees`);
                    }
                }
            }
            
            fire() {
                const bulletStart = this.position.clone();
                
                // Aim directly at target for better accuracy
                if (this.target) {
                    const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                    const direction = toTarget.normalize();
                    
                    const bullet = new SpaceBullet(bulletStart, direction, this);
                    spaceBullets.push(bullet);
                    
                    console.log(`🚀 Space ship fired directly at target! Target at (${this.target.position.x.toFixed(1)}, ${this.target.position.y.toFixed(1)}, ${this.target.position.z.toFixed(1)})`);
                } else {
                    // Fallback to ship orientation
                    const direction = new THREE.Vector3(
                        Math.sin(this.rotation),
                        0,
                        Math.cos(this.rotation)
                    );
                    
                    const bullet = new SpaceBullet(bulletStart, direction, this);
                    spaceBullets.push(bullet);
                    
                    console.log('🚀 Space ship fired without target!');
                }
            }
        }
        
        class SpaceBullet {
            constructor(position, direction, shooter) {
                this.position = position.clone();
                this.velocity = direction.clone().multiplyScalar(SPACE_BULLET_SPEED);
                this.shooter = shooter;
                this.life = 4.0; // Seconds - balanced lifetime
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                // Create photon torpedo-style projectile
                const torpedoGroup = new THREE.Group();
                
                // Main torpedo body - elongated cylinder
                const bodyGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.4, 6);
                const bodyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff8800,
                    transparent: true,
                    opacity: 1.0,
                    emissive: 0xff4400  // Much brighter emissive glow
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2; // Point forward
                torpedoGroup.add(body);
                
                // Intense glowing energy core
                const coreGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const coreMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffdd00,
                    transparent: true,
                    opacity: 1.0,
                    emissive: 0xff8800  // Intense bright glow
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                torpedoGroup.add(core);
                
                // Outer glow aura
                const auraGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const auraMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.4,
                    emissive: 0xff6600
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                torpedoGroup.add(aura);
                
                // Enhanced energy trail effect
                const trailGeometry = new THREE.ConeGeometry(0.04, 0.3, 6);
                const trailMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff44,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xff6600  // Brighter trail glow
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.x = -0.2; // Behind the torpedo
                trail.rotation.z = -Math.PI / 2; // Point backward
                torpedoGroup.add(trail);
                
                this.mesh = torpedoGroup;
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                // FORCE CONSTANT MOVEMENT - bypass deltaTime issues
                const speed = SPACE_BULLET_SPEED / 60; // Assume 60fps for consistent movement
                this.position.add(this.velocity.clone().normalize().multiplyScalar(speed));
                this.life -= 1/60; // Decrease life by 1/60 second per frame
                
                // Debug torpedo lifetime
                if (Math.random() < 0.02) {
                    console.log(`🟡 Torpedo life remaining: ${this.life.toFixed(2)} seconds`);
                }
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // Orient torpedo to face movement direction
                    const direction = this.velocity.clone().normalize();
                    this.mesh.lookAt(this.position.clone().add(direction));
                    
                    // Add subtle rotation for more dynamic look
                    this.mesh.rotation.z += 0.1;
                }
                
                // Check collision with asteroids - Enhanced hit detection
                for (const asteroid of asteroids) {
                    const distance = this.position.distanceTo(asteroid.position);
                    const hitRadius = asteroid.size === 'large' ? 2.5 : asteroid.size === 'medium' ? 1.5 : 0.9; // Increased hit radius
                    
                    // Debug collision detection every 30 frames for closest asteroid
                    if (Math.random() < 0.01) {
                        console.log(`🎯 Torpedo at (${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) checking ${asteroid.size} asteroid at (${asteroid.position.x.toFixed(1)}, ${asteroid.position.y.toFixed(1)}, ${asteroid.position.z.toFixed(1)}) - distance: ${distance.toFixed(2)}, hit radius: ${hitRadius}`);
                    }
                    
                    if (distance < hitRadius) {
                        console.log(`💥 TORPEDO HIT! ${asteroid.size} asteroid at distance ${distance.toFixed(2)}, radius ${hitRadius}`);
                        asteroid.takeDamage();
                        this.explode();
                        return true; // Mark for removal
                    }
                }
                
                // Remove if life expired or out of bounds
                if (this.life <= 0 || Math.abs(this.position.x) > SKY_RADIUS * 2) {
                    console.log(`🗑️ Torpedo expired - life: ${this.life.toFixed(2)}, bounds check: ${Math.abs(this.position.x) > SKY_RADIUS * 2}`);
                    this.destroy();
                    return true; // Mark for removal
                }
                
                return false;
            }
            
            explode() {
                // Create small explosion effect
                createSpaceExplosion(this.position.clone());
                this.destroy();
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        class ShootingStar {
            constructor() {
                // Start from random edge of space layer area
                const side = Math.floor(Math.random() * 4);
                const spaceSize = SPACE_RADIUS * 1.5;
                
                // Position in space layer (60m+ above user)
                switch(side) {
                    case 0: // Top
                        this.position = new THREE.Vector3(
                            (Math.random() - 0.5) * spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            spaceSize
                        );
                        break;
                    case 1: // Right
                        this.position = new THREE.Vector3(
                            spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            (Math.random() - 0.5) * spaceSize
                        );
                        break;
                    case 2: // Bottom
                        this.position = new THREE.Vector3(
                            (Math.random() - 0.5) * spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            -spaceSize
                        );
                        break;
                    case 3: // Left
                        this.position = new THREE.Vector3(
                            -spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            (Math.random() - 0.5) * spaceSize
                        );
                        break;
                }
                
                // Create velocity toward opposite side within space layer
                const targetX = (Math.random() - 0.5) * spaceSize;
                const targetY = SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT);
                const targetZ = (Math.random() - 0.5) * spaceSize;
                
                const direction = new THREE.Vector3(targetX, targetY, targetZ).sub(this.position);
                direction.normalize();
                this.velocity = direction.multiplyScalar(SHOOTING_STAR_SPEED);
                
                this.life = 4.0; // Seconds
                this.brightness = 0.8 + Math.random() * 0.2;
                this.mesh = null;
                this.trailParticles = [];
                
                this.createMesh();
            }
            
            createMesh() {
                const starGeometry = new THREE.SphereGeometry(0.15, 4, 4); // Reduced complexity for background stars
                const starMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffaa,
                    transparent: true,
                    opacity: this.brightness
                });
                this.mesh = new THREE.Mesh(starGeometry, starMaterial);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime, elapsedTime) {
                // Update position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.life -= deltaTime;
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // Fade out as life decreases
                    const lifeFactor = Math.max(0, this.life / 4.0);
                    this.mesh.material.opacity = this.brightness * lifeFactor;
                }
                
                // Create trail particles
                this.createTrailParticle(elapsedTime);
                
                // Update trail particles
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    const particle = this.trailParticles[i];
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        if (particle.mesh) {
                            scene.remove(particle.mesh);
                        }
                        this.trailParticles.splice(i, 1);
                    } else {
                        // Fade trail particle
                        if (particle.mesh) {
                            particle.mesh.material.opacity = particle.life / 1.0;
                        }
                    }
                }
                
                // Remove if life expired
                return this.life <= 0;
            }
            
            createTrailParticle(elapsedTime) {
                // Create trail particle every few frames
                if (Math.random() < 0.3) {
                    const trailGeometry = new THREE.SphereGeometry(0.05, 3, 3); // Minimal for trail particles
                    const trailMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                    trailMesh.position.copy(this.position);
                    scene.add(trailMesh);
                    
                    this.trailParticles.push({
                        mesh: trailMesh,
                        life: 1.0 // Trail particles live for 1 second
                    });
                }
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
                
                // Clean up trail particles
                for (const particle of this.trailParticles) {
                    if (particle.mesh) {
                        scene.remove(particle.mesh);
                    }
                }
                this.trailParticles = [];
            }
        }
        
        
        
        // --- Predator Class ---
        class Predator {
            constructor(position, color) {
                this.position = position || new THREE.Vector3();
                this.velocity = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.velocity.setLength(Math.random() * 0.3 + 0.2);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.05;
                this.maxSpeed = 0.105; // Reduced by 30% to match boid speed reduction
                this.huntRadius = 4.0;
                this.color = color || new THREE.Color(0xff0000);
                this.isGrabbed = false;
            }
            
            update() {
                if (this.isGrabbed) return;
                
                this.position.add(this.velocity);
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.acceleration.multiplyScalar(0);
            }
            
            applyForce(force) {
                if (!this.isGrabbed) {
                    this.acceleration.add(force);
                }
            }
            
            hunt(boids) {
                if (!boids || !Array.isArray(boids)) {
                    return;
                }
                
                let closest = null;
                let closestDist = Infinity;
                
                for (let boid of boids) {
                    if (!boid || boid.isGrabbed) continue;
                    let d = this.position.distanceTo(boid.position);
                    if (d < this.huntRadius && d < closestDist) {
                        closest = boid;
                        closestDist = d;
                    }
                }
                
                if (closest) {
                    let huntForce = this.seek(closest.position);
                    huntForce.multiplyScalar(2.0); // Strong hunting drive
                    this.applyForce(huntForce);
                }
            }
            
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.normalize();
                desired.multiplyScalar(this.maxSpeed);
                let steer = desired.sub(this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            
            checkBounds() {
                if (this.isGrabbed) return;
                
                const halfRadius = ATMOSPHERE_RADIUS / 2;
                const turnFactor = 0.7;
                
                // Constrain to atmosphere layer (0-30m height)
                if (this.position.x > halfRadius) this.velocity.x -= turnFactor;
                if (this.position.x < -halfRadius) this.velocity.x += turnFactor;
                if (this.position.y > ATMOSPHERE_MAX_HEIGHT) this.velocity.y -= turnFactor;
                if (this.position.y < ATMOSPHERE_MIN_HEIGHT + 0.5) this.velocity.y += turnFactor;
                if (this.position.z > halfRadius) this.velocity.z -= turnFactor;
                if (this.position.z < -halfRadius) this.velocity.z += turnFactor;
            }
        }
        
        // --- Boid Class ---
        class Boid {
            constructor(position) {
                this.position = position || new THREE.Vector3(
                    Math.random() * boundSize - boundSize / 2,
                    Math.random() * (boundSize / 2) + 1,
                    Math.random() * boundSize - boundSize / 2
                );
                this.velocity = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                );
                this.velocity.setLength(Math.random() * 0.5 + 0.5);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.03;
                this.maxSpeed = 0.07; // Reduced by 30% for better performance
                this.isGrabbed = false;
                this.isBeingTossed = false;
                this.tossStartTime = 0;
                this.tossVelocity = new THREE.Vector3();
                this.originalVelocity = new THREE.Vector3();
                // Add smoothed rotation direction to prevent spinning
                this.smoothedDirection = this.velocity.clone().normalize();
                // Add punch effect tracking
                this.punchAffected = false;
                this.punchEffectEndTime = 0;
                this.punchGlowColor = new THREE.Color(0xff6600);
                this.trailPositions = [];
            }
            
            update() {
                if (this.isGrabbed) return;
                
                if (this.isBeingTossed) {
                    this.handleTossedMovement();
                } else {
                    this.position.add(this.velocity);
                    this.velocity.add(this.acceleration);
                    this.velocity.clampLength(0, this.maxSpeed);
                    this.acceleration.multiplyScalar(0);
                }
                
                // Smooth rotation direction to prevent spinning
                if (this.velocity.length() > 0.01) {
                    const currentDirection = this.velocity.clone().normalize();
                    this.smoothedDirection.lerp(currentDirection, 0.1); // Smooth interpolation
                    this.smoothedDirection.normalize();
                }
                
                // Update punch effect trail
                if (this.punchAffected) {
                    // Add current position to trail
                    this.trailPositions.push(this.position.clone());
                    // Keep trail length reasonable
                    if (this.trailPositions.length > 10) {
                        this.trailPositions.shift();
                    }
                    
                    // Check if effect should end
                    if (clock.getElapsedTime() > this.punchEffectEndTime) {
                        this.punchAffected = false;
                        this.trailPositions = [];
                    }
                }
            }
            
            handleTossedMovement() {
                const tossTime = clock.getElapsedTime() - this.tossStartTime;
                const transitionTime = 1.0; // Time to transition from toss to flight
                
                if (tossTime < transitionTime) {
                    // Newtonian trajectory with gravity
                    const gravity = new THREE.Vector3(0, -9.8, 0);
                    this.position.add(this.tossVelocity.clone().multiplyScalar(0.016)); // ~60fps
                    this.tossVelocity.add(gravity.clone().multiplyScalar(0.016));
                    
                    // Gradually blend back to boid behavior
                    const blendFactor = tossTime / transitionTime;
                    this.velocity.lerpVectors(this.tossVelocity, this.originalVelocity, blendFactor);
                } else {
                    // Return to normal boid behavior
                    this.isBeingTossed = false;
                    this.velocity.copy(this.originalVelocity);
                }
            }
            
            applyForce(force) {
                if (!this.isGrabbed && !this.isBeingTossed) {
                    this.acceleration.add(force);
                }
            }
            
            // --- MODIFIED: flock method now includes obstacle avoidance and predator fleeing ---
            flock(boids, hands, obstacles, predators) {
                let fleeForce = this.fleeFromHands(hands);
                let predatorFleeForce = this.fleeFromPredators(predators);
                // Obstacle avoidance removed for performance
                let separation = this.separate(boids);
                let alignment = this.align(boids);
                let cohesion = this.cohere(boids);

                // Weight forces
                fleeForce.multiplyScalar(5.0);
                predatorFleeForce.multiplyScalar(8.0); // Very strong predator avoidance
                separation.multiplyScalar(1.5);
                alignment.multiplyScalar(1.0);
                cohesion.multiplyScalar(1.0);
                
                this.applyForce(fleeForce);
                this.applyForce(predatorFleeForce);
                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }
            
            // Obstacle avoidance removed for performance

            fleeFromHands(hands) {
                let fleeForce = new THREE.Vector3();
                for (const hand of hands) {
                    if (hand.userData.isReady && !hand.userData.isGrabbingBoid) {
                        fleeForce.add(this.flee(hand.userData.tipPositions.MIDDLE));
                    }
                }
                return fleeForce;
            }
            
            fleeFromPredators(predators) {
                let fleeForce = new THREE.Vector3();
                if (!predators || !Array.isArray(predators)) {
                    return fleeForce;
                }
                for (const predator of predators) {
                    if (!predator || predator.isGrabbed) continue;
                    let d = this.position.distanceTo(predator.position);
                    if (d < 3.0) { // Flee radius from predators
                        let flee = this.flee(predator.position);
                        flee.multiplyScalar(3.0); // Strong flee response
                        fleeForce.add(flee);
                    }
                }
                return fleeForce;
            }
            separate(boids) {
                let desiredSeparation = 0.8;
                let steer = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < desiredSeparation)) {
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                }
                
                if (count > 0) {
                    steer.divideScalar(count);
                    steer.normalize();
                    steer.multiplyScalar(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }
            align(boids) {
                let neighborDist = 2.5;
                let sum = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divideScalar(count);
                    sum.normalize();
                    sum.multiplyScalar(this.maxSpeed);
                    let steer = sum.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                    return steer;
                } else {
                    return new THREE.Vector3();
                }
            }
            cohere(boids) {
                let neighborDist = 3;
                let sum = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.add(other.position);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divideScalar(count);
                    return this.seek(sum);
                } else {
                    return new THREE.Vector3();
                }
            }
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.normalize();
                desired.multiplyScalar(this.maxSpeed);
                let steer = desired.sub(this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            flee(target) {
                const fleeRadius = 1.5;
                let steer = new THREE.Vector3();
                let d = this.position.distanceTo(target);
                if (d < fleeRadius) {
                    let desired = new THREE.Vector3().subVectors(this.position, target);
                    desired.normalize();
                    desired.multiplyScalar(this.maxSpeed);
                    steer = desired.sub(this.velocity);
                    steer.clampLength(0, this.maxForce * 2.0);
                }
                return steer;
            }
            checkBounds() {
                if (this.isGrabbed) return;
                
                const halfBound = boundSize / 2;
                const turnFactor = 0.5;
                
                if (this.position.x > halfBound) this.velocity.x -= turnFactor;
                if (this.position.x < -halfBound) this.velocity.x += turnFactor;
                if (this.position.y > 8) this.velocity.y -= turnFactor; // Max Y=8, well below asteroids at Y=11.8
                if (this.position.y < 0.1) this.velocity.y += turnFactor;
                if (this.position.z > halfBound) this.velocity.z -= turnFactor;
                if (this.position.z < -halfBound) this.velocity.z += turnFactor;
            }
        }

        function addFallbackControls() {
            const fallbackDiv = document.createElement('div');
            fallbackDiv.style.position = 'absolute';
            fallbackDiv.style.bottom = '20px';
            fallbackDiv.style.left = '50%';
            fallbackDiv.style.transform = 'translateX(-50%)';
            fallbackDiv.style.padding = '12px 24px';
            fallbackDiv.style.backgroundColor = 'rgba(255, 100, 100, 0.8)';
            fallbackDiv.style.color = 'white';
            fallbackDiv.style.borderRadius = '8px';
            fallbackDiv.style.fontSize = '14px';
            fallbackDiv.textContent = 'VR not supported - use mouse to look around';
            document.body.appendChild(fallbackDiv);
            
            // Add basic mouse controls for fallback
            let mouseX = 0, mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                camera.position.x = mouseX * 5;
                camera.position.y = mouseY * 3 + 1.6;
                camera.lookAt(0, 2, 0);
            });
        }

        function createVectorGridGround() {
            // Create a simple, clean grid to avoid aliasing artifacts
            const gridSize = 80; // Smaller for better performance
            const divisions = 40; // Fewer divisions to reduce aliasing
            const gridHelper = new THREE.GridHelper(gridSize, divisions);
            
            // Simple cyan color without transparency to avoid artifacts
            gridHelper.material.color.setHex(0x004444);
            gridHelper.material.opacity = 0.5;
            gridHelper.material.transparent = true;
            gridHelper.position.y = 0; // Exactly at ground level
            
            scene.add(gridHelper);
            
            console.log('🌐 Created simplified grid ground');
        }

        // Tron trees function removed for performance
        
        // Fountain system removed - too problematic
        
        function createGroundVoxels() {
            // Create geometry and material for ground voxels
            const voxelSize = 0.12;
            const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
            const voxelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x6666ff, 
                transparent: true,
                opacity: 0.8,
                emissive: 0x2222bb
            });
            
            // Create instanced mesh for ground voxels
            groundVoxelsMesh = new THREE.InstancedMesh(voxelGeometry, voxelMaterial, groundVoxelCount);
            groundVoxelsMesh.name = 'ground_voxels';
            groundVoxelsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(groundVoxelsMesh);
            
            // Create and position ground voxels
            const dummy = new THREE.Object3D();
            for (let i = 0; i < groundVoxelCount; i++) {
                const voxel = {
                    position: new THREE.Vector3(
                        (Math.random() - 0.5) * boundSize * 0.8, // Within bounds
                        0.1, // Slightly above ground
                        (Math.random() - 0.5) * boundSize * 0.8
                    ),
                    active: true,
                    glowPhase: Math.random() * Math.PI * 2, // Random glow phase
                    originalY: 0.1
                };
                
                groundVoxels.push(voxel);
                
                // Set initial matrix
                dummy.position.copy(voxel.position);
                dummy.updateMatrix();
                groundVoxelsMesh.setMatrixAt(i, dummy.matrix);
            }
            
            groundVoxelsMesh.instanceMatrix.needsUpdate = true;
            console.log(`✨ Created ${groundVoxelCount} ground voxels for testing`);
        }
        
        function createBoidsSystem() {
            // Create geometry and material for boids
            const boidSize = 0.15; // Larger for better VR visibility
            const boidGeometry = new THREE.BoxGeometry(boidSize, boidSize, boidSize);
            const boidMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa, 
                transparent: false, // Disable for mobile perf
                opacity: 1.0
            }); // Switched to Basic for Quest 3 perf, removed emissive as Basic doesn't support it
            
            // Create instanced mesh for boids
            const boidsMesh = new THREE.InstancedMesh(boidGeometry, boidMaterial, initialBoidCount);
            boidsMesh.name = 'alive_voxels';
            boidsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(boidsMesh);
            
            // Initialize all boids with default matrices
            const dummy = new THREE.Object3D();
            for (let i = 0; i < initialBoidCount; i++) {
                dummy.position.set(0, -1000, 0); // Start hidden
                dummy.updateMatrix();
                boidsMesh.setMatrixAt(i, dummy.matrix);
            }
            boidsMesh.instanceMatrix.needsUpdate = true;
            
            // Create held voxel meshes for both hands
            heldVoxelMesh1 = new THREE.Mesh(boidGeometry, boidMaterial.clone());
            heldVoxelMesh1.visible = false;
            heldVoxelMesh1.position.set(0, -1000, 0);
            scene.add(heldVoxelMesh1);
            
            heldVoxelMesh2 = new THREE.Mesh(boidGeometry, boidMaterial.clone());
            heldVoxelMesh2.visible = false;
            heldVoxelMesh2.position.set(0, -1000, 0);
            scene.add(heldVoxelMesh2);
            
            console.log(`🐦 Created boids system with ${initialBoidCount} boids`);
        }
        
        // Game of Life pattern functions removed for performance
        
        // Game of Life functions removed for performance


        function createSpaceBattle() {
            // Clear existing space objects
            asteroids = [];
            spaceShips = [];
            stars = [];
            
            // Create initial asteroids
            for (let i = 0; i < ASTEROID_COUNT; i++) {
                const asteroid = new Asteroid();
                asteroids.push(asteroid);
            }
            
            // Create initial spaceships
            for (let i = 0; i < SPACESHIP_COUNT; i++) {
                const spaceship = new SpaceShip();
                spaceShips.push(spaceship);
            }
            
            // Create starfield
            for (let i = 0; i < STAR_COUNT; i++) {
                const star = new Star();
                stars.push(star);
            }
            
            console.log(`🚀 Created ${ASTEROID_COUNT} asteroids, ${SPACESHIP_COUNT} spaceships, and ${STAR_COUNT} stars for Space Battle`);
            console.log(`⭐ Stars positioned at heights ${SPACE_MIN_HEIGHT}m - ${SPACE_MAX_HEIGHT}m above user`);
        }


        
        
        function createSpaceExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 6; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = getParticleFromPool();
                    if (particle) {
                        particle.position.copy(position);
                        particle.velocity.set(
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3
                        );
                        particle.life = 0.8;
                        particle.maxLife = 0.8;
                        particle.color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.1, 1, 0.8);
                        particles.push(particle);
                    }
                }
                
                console.log('✨ Space explosion!');
            } catch (error) {
                console.warn('Space explosion error:', error);
            }
        }
        
        function updateSkyBattle(deltaTime, elapsedTime) {
            try {
                // Performance optimization: update different elements at different intervals
                const shouldUpdateStars = frameCount % SPACE_UPDATE_INTERVAL === 0;
                const shouldUpdateOrbital = frameCount % ORBITAL_UPDATE_INTERVAL === 0;
                const shouldUpdateParticles = frameCount % PARTICLE_UPDATE_INTERVAL === 0;
                
                // Update stars at reduced frequency (space layer)
                if (shouldUpdateStars) {
                    for (const star of stars) {
                        star.update(elapsedTime);
                    }
                }
                
                // Spawn shooting stars randomly but check less frequently
                if (shouldUpdateParticles && Math.random() < SHOOTING_STAR_SPAWN_RATE * deltaTime * PARTICLE_UPDATE_INTERVAL) {
                    shootingStars.push(new ShootingStar());
                    console.log('✨ Shooting star appeared!');
                }
                
                // Update shooting stars
                for (let i = shootingStars.length - 1; i >= 0; i--) {
                    const shootingStar = shootingStars[i];
                    if (shootingStar.update(deltaTime, elapsedTime)) {
                        shootingStar.destroy();
                        shootingStars.splice(i, 1);
                    }
                }
                
                // Update asteroids every frame for smooth movement
                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    asteroid.update(deltaTime);
                    
                    // Remove destroyed asteroids
                    if (asteroid.health <= 0) {
                        asteroids.splice(i, 1);
                    }
                }
                
                // Maintain minimum asteroid count (only check occasionally)
                if (shouldUpdateOrbital && asteroids.length < ASTEROID_COUNT / 2) {
                    while (asteroids.length < ASTEROID_COUNT / 2) {
                        asteroids.push(new Asteroid());
                    }
                }
                
                // Update space ships every frame for smooth movement
                for (const ship of spaceShips) {
                    ship.update(deltaTime, elapsedTime);
                }
                
                // Update space bullets (keep at normal frequency for responsiveness)
                for (let i = spaceBullets.length - 1; i >= 0; i--) {
                    const bullet = spaceBullets[i];
                    if (bullet.update(deltaTime)) {
                        spaceBullets.splice(i, 1);
                    }
                }
                
            } catch (error) {
                console.warn('Sky battle update error:', error);
            }
        }
        
        
        
        function handleTeleportation(hand, elapsedTime) {
            try {
                if (!hand.userData.isReady || !hand.userData.isPointing) {
                    resetTeleportState();
                    return;
                }
                
                // Perform raycast from index finger
                const rayOrigin = hand.userData.tipPositions.INDEX.clone();
                const rayDirection = new THREE.Vector3()
                    .subVectors(hand.userData.tipPositions.INDEX, hand.userData.wristPosition)
                    .normalize();
                
                teleportRaycaster.set(rayOrigin, rayDirection);
                
                // Raycast against ground plane (y = 0)
                const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectPoint = new THREE.Vector3();
                teleportRaycaster.ray.intersectPlane(groundPlane, intersectPoint);
                
                if (intersectPoint) {
                    const distance = rayOrigin.distanceTo(intersectPoint);
                    
                    // Check if within teleport range
                    if (distance <= TELEPORT_MAX_DISTANCE) {
                        // Show ray line
                        if (teleportRayLine) {
                            const rayGeometry = teleportRayLine.geometry;
                            const positions = rayGeometry.attributes.position.array;
                            positions[0] = rayOrigin.x;
                            positions[1] = rayOrigin.y;
                            positions[2] = rayOrigin.z;
                            positions[3] = intersectPoint.x;
                            positions[4] = intersectPoint.y;
                            positions[5] = intersectPoint.z;
                            rayGeometry.attributes.position.needsUpdate = true;
                            teleportRayLine.visible = true;
                        }
                        
                        // Show reticle
                        teleportReticle.position.copy(intersectPoint);
                        teleportReticle.visible = true;
                        
                        // Simple timer-based teleportation
                        if (!isPointingForTeleport) {
                            teleportHoldStartTime = elapsedTime;
                            teleportTargetPosition = intersectPoint.clone();
                            isPointingForTeleport = true;
                            console.log('📍 Teleport started');
                        } else {
                            const holdTime = elapsedTime - teleportHoldStartTime;
                            const progress = Math.min(holdTime / TELEPORT_HOLD_TIME, 1.0);
                            
                            // Show progress
                            teleportIndicator.position.copy(intersectPoint);
                            teleportIndicator.visible = true;
                            teleportIndicator.scale.set(progress * 2, 1, progress * 2);
                            
                            // Teleport when complete
                            if (progress >= 1.0) {
                                console.log('🚀 Teleporting!');
                                performTeleport(intersectPoint);
                                resetTeleportState();
                            }
                        }
                    } else {
                        resetTeleportState();
                    }
                } else {
                    resetTeleportState();
                }
                
            } catch (error) {
                console.warn('Teleportation error:', error);
                resetTeleportState();
            }
        }
        
        function detectPointingGesture(hand) {
            // Check if index finger is extended while other fingers are curled
            if (!hand.userData.tipPositions.INDEX || !hand.userData.tipPositions.MIDDLE) {
                return false;
            }
            
            const palmPosition = hand.userData.tipPositions.MIDDLE; // Approximate palm
            const indexTip = hand.userData.tipPositions.INDEX;
            
            // Simple pointing detection: index finger extended away from palm
            const pointingDistance = indexTip.distanceTo(palmPosition);
            return pointingDistance > 0.08; // Threshold for extended finger
        }
        
        function getPointingDirection(hand) {
            // Calculate pointing direction from palm toward index fingertip
            const palmPosition = hand.userData.tipPositions.MIDDLE; // Approximate palm
            const indexTip = hand.userData.tipPositions.INDEX;
            
            const direction = new THREE.Vector3().subVectors(indexTip, palmPosition);
            direction.normalize();
            
            return direction;
        }
        
        function performTeleport(targetPosition) {
            try {
                console.log('🚀 Teleporting to:', targetPosition);
                
                if (renderer.xr.isPresenting) {
                    // VR Mode: Use XR reference space
                    const xrReferenceSpace = renderer.xr.getReferenceSpace();
                    const session = renderer.xr.getSession();
                    
                    if (session && session.requestReferenceSpace) {
                        // Calculate offset to teleport position
                        // Keep the user at ground level + comfortable VR height
                        const teleportY = 1.6; // Standard VR height above ground
                        // Get current reference space position
                        const currentPose = renderer.xr.getFrame().getViewerPose(xrReferenceSpace);
                        if (currentPose) {
                            const currentPosition = currentPose.transform.position;
                            const offsetX = targetPosition.x - currentPosition.x;
                            const offsetY = teleportY - currentPosition.y; // Adjust to ground level + height
                            const offsetZ = targetPosition.z - currentPosition.z;
                            
                            const transform = new XRRigidTransform(
                                {x: offsetX, y: offsetY, z: offsetZ},
                                {x: 0, y: 0, z: 0, w: 1}
                            );
                            
                            const offsetReferenceSpace = xrReferenceSpace.getOffsetReferenceSpace(transform);
                            renderer.xr.setReferenceSpace(offsetReferenceSpace);
                            console.log('✅ XR Teleport completed with offset:', {offsetX, offsetY, offsetZ});
                        } else {
                            console.warn('⚠️ Could not get current viewer pose for teleport');
                        }
                        
                        console.log('✅ XR Teleport completed to:', teleportVector.toArray().map(v => v.toFixed(2)));
                    } else {
                        // Fallback: Move the VR camera group
                        const vrCamera = renderer.xr.getCamera();
                        if (vrCamera.parent) {
                            vrCamera.parent.position.set(
                                -targetPosition.x,
                                1.6 - targetPosition.y, // Keep above ground
                                -targetPosition.z
                            );
                            console.log('✅ VR Camera teleport completed');
                        }
                    }
                } else {
                    // Desktop mode - move scene
                    scene.position.set(
                        -targetPosition.x,
                        -targetPosition.y + 1.6,
                        -targetPosition.z
                    );
                    console.log('✅ Desktop teleport completed');
                }
                
                // Create teleport effect
                createTeleportEffect(targetPosition);
                
            } catch (error) {
                console.warn('Teleport execution error:', error);
            }
        }
        
        function createTeleportEffect(position) {
            // Create particle effect at teleport location
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const particle = getParticleFromPool();
                if (particle) {
                    particle.position.copy(position).add(new THREE.Vector3(0, 0.1, 0));
                    particle.velocity.set(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    );
                    particle.life = 1.5;
                    particle.maxLife = 1.5;
                    particle.color = new THREE.Color().setHSL(0.5, 1, 0.8); // Cyan teleport effect
                    particles.push(particle);
                }
            }
        }
        
        function resetTeleportState() {
            isPointingForTeleport = false;
            teleportTargetPosition = null;
            teleportHoldStartTime = 0;
            
            if (teleportReticle) teleportReticle.visible = false;
            if (teleportIndicator) teleportIndicator.visible = false;
            if (teleportRayLine) teleportRayLine.visible = false;
        }
        
        // Duplicate performTeleport function removed - using the scene-based implementation above
        
        function detectFist(hand) {
            try {
                if (!hand.userData.isReady) return false;
                
                // Ensure we have valid tip positions
                if (!hand.userData.tipPositions.INDEX || !hand.userData.tipPositions.MIDDLE || !hand.userData.tipPositions.THUMB) {
                    return false;
                }
                
                // Get joint positions for better fist detection
                const joints = hand.joints;
                if (!joints || !joints['wrist']) return false;
                
                const wrist = joints['wrist'].position;
                const thumbTip = hand.userData.tipPositions.THUMB;
                const indexTip = hand.userData.tipPositions.INDEX;
                const middleTip = hand.userData.tipPositions.MIDDLE;
                
                // Check if fingertips are close to the wrist (curled fingers)
                const thumbToWrist = thumbTip.distanceTo(wrist);
                const indexToWrist = indexTip.distanceTo(wrist);
                const middleToWrist = middleTip.distanceTo(wrist);
                
                // Store finger distances for debug overlay
                if (hand.userData.debugHandIndex !== undefined) {
                    const handInfo = hand.userData.debugHandIndex === 0 ? debugInfo.leftHand : debugInfo.rightHand;
                    handInfo.thumbDist = thumbToWrist;
                    handInfo.indexDist = indexToWrist;
                    handInfo.middleDist = middleToWrist;
                }
                
                // Debug logging
                if (frameCount % 30 === 0) { // More frequent logging
                    console.log('👊 Fist detection:', {
                        thumbToWrist: thumbToWrist.toFixed(3),
                        indexToWrist: indexToWrist.toFixed(3),
                        middleToWrist: middleToWrist.toFixed(3),
                        velocity: hand.userData.velocity ? hand.userData.velocity.length().toFixed(3) : '0',
                        isFist: (thumbToWrist < 0.18 && indexToWrist < 0.18 && middleToWrist < 0.18)
                    });
                }
                
                // If fingertips are close to wrist, it's a fist (very relaxed thresholds)
                return thumbToWrist < 0.18 && indexToWrist < 0.18 && middleToWrist < 0.18;
            } catch (error) {
                console.warn('Fist detection error:', error);
                return false;
            }
        }
        
        function punchBlast(hand) {
            try {
                if (!hand.userData.handCenter || !hand.userData.velocity) {
                    console.warn('⚠️ Punch blast failed - missing handCenter or velocity');
                    return;
                }
                
                const blastCenter = hand.userData.handCenter.clone();
                const blastDirection = hand.userData.velocity.clone().normalize();
                
                console.log('💥 PUNCH BLAST TRIGGERED!');
                console.log('  Center:', blastCenter.toArray().map(v => v.toFixed(2)));
                console.log('  Direction:', blastDirection.toArray().map(v => v.toFixed(2)));
                
                // Create punch blast visual effect
                createPunchBlastEffect(blastCenter, blastDirection);
                
                // Play punch sound effect
                playPunchSound();
                
                // Affect boids within blast radius
                let affectedBoidsCount = 0;
                boids.forEach((boid, index) => {
                    if (boid && boid.position) {
                        const distance = boid.position.distanceTo(blastCenter);
                        if (distance < PUNCH_FORCE_RADIUS) {
                            // Push boids away instead of removing them
                            const pushDirection = new THREE.Vector3().subVectors(boid.position, blastCenter).normalize();
                            const pushForce = Math.max(0.1, (PUNCH_FORCE_RADIUS - distance) / PUNCH_FORCE_RADIUS);
                            boid.velocity.add(pushDirection.multiplyScalar(pushForce * 2.0));
                            
                            // Apply punch effect with lingering glow and trail
                            boid.punchAffected = true;
                            boid.punchEffectEndTime = clock.getElapsedTime() + 30; // 30 second effect
                            boid.punchGlowColor.setHSL(0.1, 1.0, 0.6); // Orange glow
                            boid.trailPositions = [boid.position.clone()];
                            
                            // Create particle explosion at boid position
                            createParticleExplosion(boid.position.clone());
                            affectedBoidsCount++;
                        }
                    }
                });
                
                // Also affect predators
                predators.forEach(predator => {
                    if (predator && predator.position) {
                        const distance = predator.position.distanceTo(blastCenter);
                        if (distance < PUNCH_FORCE_RADIUS) {
                            // Push predators away
                            const pushDirection = new THREE.Vector3().subVectors(predator.position, blastCenter).normalize();
                            const pushForce = Math.max(0.1, (PUNCH_FORCE_RADIUS - distance) / PUNCH_FORCE_RADIUS);
                            predator.velocity.add(pushDirection.multiplyScalar(pushForce * 1.5));
                        }
                    }
                });
                
                console.log(`💥 Punch affected ${affectedBoidsCount} boids!`);
                
            } catch (error) {
                console.warn('Punch blast error:', error);
            }
        }
        
        function createPunchBlastEffect(center, direction) {
            try {
                // Create expanding bubble effect
                const bubbleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bubbleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xff4400
                });
                const bubbleMesh = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubbleMesh.position.copy(center);
                scene.add(bubbleMesh);
                
                // Animate bubble expansion
                const startTime = clock.getElapsedTime();
                const animateBlast = () => {
                    const elapsed = clock.getElapsedTime() - startTime;
                    const progress = elapsed / 0.5; // 0.5 second animation
                    
                    if (progress < 1) {
                        // Expand bubble and fade out
                        const scale = 1 + progress * (PUNCH_FORCE_RADIUS * 8);
                        bubbleMesh.scale.set(scale, scale, scale);
                        bubbleMaterial.opacity = 0.8 * (1 - progress);
                        
                        requestAnimationFrame(animateBlast);
                    } else {
                        // Remove bubble
                        scene.remove(bubbleMesh);
                        bubbleGeometry.dispose();
                        bubbleMaterial.dispose();
                    }
                };
                animateBlast();
                
                // Create shockwave rings
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        createShockwaveRing(center, i * 0.1);
                    }, i * 100);
                }
                
            } catch (error) {
                console.warn('Punch blast effect error:', error);
            }
        }
        
        function createShockwaveRing(center, delay) {
            const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            ringMesh.position.copy(center);
            ringMesh.rotation.x = Math.random() * Math.PI;
            ringMesh.rotation.y = Math.random() * Math.PI;
            scene.add(ringMesh);
            
            // Animate ring expansion
            const startTime = clock.getElapsedTime();
            const animateRing = () => {
                const elapsed = clock.getElapsedTime() - startTime;
                const progress = elapsed / 0.8; // 0.8 second animation
                
                if (progress < 1) {
                    const scale = 1 + progress * 15;
                    ringMesh.scale.set(scale, scale, scale);
                    ringMaterial.opacity = 0.6 * (1 - progress);
                    
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ringMesh);
                    ringGeometry.dispose();
                    ringMaterial.dispose();
                }
            };
            animateRing();
        }
        
        function playPunchSound() {
            try {
                // Create punch sound using Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create punch sound with multiple frequency components
                const duration = 0.3;
                const sampleRate = audioContext.sampleRate;
                const frameCount = sampleRate * duration;
                
                const arrayBuffer = audioContext.createBuffer(1, frameCount, sampleRate);
                const channelData = arrayBuffer.getChannelData(0);
                
                // Generate punch sound (thump + high-frequency crack)
                for (let i = 0; i < frameCount; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-t * 8); // Quick decay
                    
                    // Low frequency thump (40-80 Hz)
                    const lowFreq = Math.sin(2 * Math.PI * 60 * t) * 0.8;
                    // High frequency crack (200-400 Hz)
                    const highFreq = Math.sin(2 * Math.PI * 300 * t) * 0.3 * Math.exp(-t * 15);
                    // Mid frequency punch (100-150 Hz)
                    const midFreq = Math.sin(2 * Math.PI * 125 * t) * 0.5;
                    
                    channelData[i] = (lowFreq + highFreq + midFreq) * envelope * 0.3;
                }
                
                // Play the sound
                const source = audioContext.createBufferSource();
                source.buffer = arrayBuffer;
                source.connect(audioContext.destination);
                source.start();
                
            } catch (error) {
                console.warn('Punch sound error:', error);
            }
        }
        
        function createPunchTrail(boid) {
            try {
                if (boid.trailPositions.length < 2) return;
                
                // Only create trail particles occasionally to avoid performance issues
                if (Math.random() < 0.3) {
                    const trailGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const trailMaterial = new THREE.MeshBasicMaterial({
                        color: boid.punchGlowColor,
                        transparent: true,
                        opacity: 0.6,
                        emissive: boid.punchGlowColor.clone().multiplyScalar(0.5)
                    });
                    
                    const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                    trailMesh.position.copy(boid.position);
                    scene.add(trailMesh);
                    
                    // Animate trail particle fade
                    const startTime = clock.getElapsedTime();
                    const animateTrail = () => {
                        const elapsed = clock.getElapsedTime() - startTime;
                        const progress = elapsed / 1.0; // 1 second fade
                        
                        if (progress < 1) {
                            trailMaterial.opacity = 0.6 * (1 - progress);
                            const scale = 1 + progress * 2;
                            trailMesh.scale.set(scale, scale, scale);
                            
                            requestAnimationFrame(animateTrail);
                        } else {
                            scene.remove(trailMesh);
                            trailGeometry.dispose();
                            trailMaterial.dispose();
                        }
                    };
                    animateTrail();
                }
                
            } catch (error) {
                console.warn('Punch trail error:', error);
            }
        }
        
        function handleGrabbing(hand, heldVoxelMesh) {
            try {
                const grabRadius = 0.15; // Increased grab radius
                
                // Start grabbing - SIMPLIFIED
                if (hand.userData.isPinching && hand.userData.heldVoxelIndex === null && hand.userData.heldBoidIndex === null) {
                    // Try to grab ground voxels
                    for (let i = 0; i < groundVoxels.length; i++) {
                        const voxel = groundVoxels[i];
                        if (voxel && voxel.active && voxel.position) {
                            const distance = hand.userData.handCenter.distanceTo(voxel.position);
                            if (distance < 0.3) {
                                voxel.active = false;
                                hand.userData.heldVoxelIndex = i;
                                hand.userData.holdStartTime = clock.getElapsedTime();
                                
                                heldVoxelMesh.material.color.set(0x6666ff);
                                heldVoxelMesh.material.emissive.set(0x2222bb);
                                heldVoxelMesh.visible = true;
                                console.log('Grabbed ground voxel', i);
                                return;
                            }
                        }
                    }
                    
                    // Try to grab active boids
                    for (let i = 0; i < boids.length; i++) {
                        const boid = boids[i];
                        if (boid && boid.position && !boid.isGrabbed && hand.userData.tipPositions.INDEX && hand.userData.tipPositions.INDEX.distanceTo(boid.position) < grabRadius) {
                            boid.isGrabbed = true;
                            boid.originalVelocity.copy(boid.velocity);
                            hand.userData.heldBoidIndex = i;
                            hand.userData.isGrabbingBoid = true;
                            hand.userData.holdStartTime = clock.getElapsedTime();
                            
                            heldVoxelMesh.material.color.set(0xff4444);
                            heldVoxelMesh.material.emissive.set(0xff2222);
                            heldVoxelMesh.visible = true;
                            console.log('Grabbed boid', i);
                            return;
                        }
                    }
                }

                // Handle held voxel (revival or predator creation)
                if (hand.userData.heldVoxelIndex !== null) {
                    const holdDuration = clock.getElapsedTime() - hand.userData.holdStartTime;
                    const isShaking = hand.userData.shakeIntensity > SHAKE_THRESHOLD;
                    
                    // Debug logging for shake detection
                    if (frameCount % 30 === 0) { // Log every 30 frames
                        console.log('Shake detection:', {
                            shakeIntensity: hand.userData.shakeIntensity.toFixed(3),
                            threshold: SHAKE_THRESHOLD,
                            isShaking: isShaking,
                            holdDuration: holdDuration.toFixed(2)
                        });
                    }
                    
                    if (!hand.userData.isPinching) {
                        if (isShaking && holdDuration >= 1.0) {
                            // Create predator from vigorous shaking
                            const predator = new Predator(heldVoxelMesh.position.clone());
                            predators.push(predator);
                            console.log('Predator created! Total predators:', predators.length);
                        } else if (holdDuration >= REVIVAL_TIME) {
                            // Normal revival
                            boids.push(new Boid(heldVoxelMesh.position.clone()));
                            console.log('Boid revived! Total boids:', boids.length);
                        } else {
                            // Return ground voxel to original position if released too early
                            if (hand.userData.heldVoxelIndex < groundVoxels.length) {
                                const voxel = groundVoxels[hand.userData.heldVoxelIndex];
                                if (voxel) {
                                    voxel.active = true;
                                    voxel.position.copy(heldVoxelMesh.position);
                                    voxel.position.y = 0.1; // Reset to ground level
                                    voxel.originalY = 0.1;
                                }
                            }
                            console.log('Ground voxel released');
                        }
                        
                        hand.userData.heldVoxelIndex = null;
                        heldVoxelMesh.visible = false;
                        heldVoxelMesh.position.set(0, -1000, 0); // Move far away
                    } else if (isShaking) {
                        // Visual feedback for shaking - turn red
                        heldVoxelMesh.material.color.set(0xff0000);
                        heldVoxelMesh.material.emissive.set(0xff0000);
                    }
                }
                
                // Handle held boid (tossing mechanic)
                if (hand.userData.heldBoidIndex !== null) {
                    const boid = boids[hand.userData.heldBoidIndex];
                    if (!hand.userData.isPinching) {
                        // Release and toss the boid
                        boid.isGrabbed = false;
                        boid.isBeingTossed = true;
                        boid.tossStartTime = clock.getElapsedTime();
                        boid.tossVelocity.copy(hand.userData.velocity);
                        boid.position.copy(heldVoxelMesh.position);
                        
                        hand.userData.heldBoidIndex = null;
                        hand.userData.isGrabbingBoid = false;
                        heldVoxelMesh.visible = false;
                        heldVoxelMesh.position.set(0, -1000, 0); // Move far away
                        console.log('Boid tossed');
                    }
                }
            } catch (error) {
                console.warn('Grabbing error:', error);
            }
        }
        
        function createForceBlastEffect(center, direction) {
            // Create expanding ring of particles to show force blast
            const particleCount = 15; // Reduced for Quest performance
            for (let i = 0; i < particleCount; i++) {
                const particle = getParticleFromPool();
                if (particle) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 0.5;
                    particle.position.copy(center);
                    particle.velocity.set(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 0.5,
                        Math.sin(angle) * radius
                    ).add(direction.clone().multiplyScalar(0.5));
                    particle.life = 0.8;
                    particle.maxLife = 0.8;
                    particle.color = new THREE.Color(0x00aaff);
                    particles.push(particle);
                }
            }
        }
        
        function createParticleExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 10; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = getParticleFromPool();
                    if (particle) {
                        particle.position.copy(position);
                        particle.velocity.set(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        particle.life = 1.0;
                        particle.maxLife = 1.0;
                        particle.color = new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 1, 0.5);
                        particles.push(particle);
                    }
                }
            } catch (error) {
                console.warn('Particle explosion error:', error);
            }
        }
        
        // Fountain update and spawn functions removed - system eliminated

        function updateHandData(hand) {
            try {
                // Reset ready state
                hand.userData.isReady = false;
                
                // Check if we have the basic joints we need
                if (!hand.joints) {
                    console.warn('No hand.joints available');
                    return;
                }
                
                // Get essential joints
                const wrist = hand.joints['wrist'];
                const indexTip = hand.joints['index-finger-tip'];
                const thumbTip = hand.joints['thumb-tip'];
                const middleTip = hand.joints['middle-finger-tip'];
                
                if (!wrist || !indexTip || !thumbTip || !middleTip) {
                    console.warn('Missing essential hand joints');
                    return;
                }
                
                // All joints available - hand is ready
                hand.userData.isReady = true;
                
                // Store previous hand center for velocity - prevent initial velocity spike
                const isFirstFrame = !hand.userData.handCenter || hand.userData.handCenter.length() === 0;
                const previousCenter = isFirstFrame ? wrist.position.clone() : hand.userData.handCenter.clone();
                
                // Smooth joint positions to handle tracking loss (lerp with previous if valid)
                const smoothingFactor = 0.8; // Adjust for smoother tracking
                if (!hand.userData.prevThumb) hand.userData.prevThumb = new THREE.Vector3();
                if (!hand.userData.prevIndex) hand.userData.prevIndex = new THREE.Vector3();
                if (!hand.userData.prevMiddle) hand.userData.prevMiddle = new THREE.Vector3();
                if (!hand.userData.prevWrist) hand.userData.prevWrist = new THREE.Vector3();
                
                hand.userData.tipPositions.THUMB.lerpVectors(hand.userData.prevThumb, thumbTip.position, smoothingFactor);
                hand.userData.tipPositions.INDEX.lerpVectors(hand.userData.prevIndex, indexTip.position, smoothingFactor);
                hand.userData.tipPositions.MIDDLE.lerpVectors(hand.userData.prevMiddle, middleTip.position, smoothingFactor);
                hand.userData.wristPosition.lerpVectors(hand.userData.prevWrist, wrist.position, smoothingFactor);
                
                // Update previous positions
                hand.userData.prevThumb.copy(hand.userData.tipPositions.THUMB);
                hand.userData.prevIndex.copy(hand.userData.tipPositions.INDEX);
                hand.userData.prevMiddle.copy(hand.userData.tipPositions.MIDDLE);
                hand.userData.prevWrist.copy(hand.userData.wristPosition);
                
                // Calculate hand center (use wrist as primary reference)
                hand.userData.handCenter.copy(hand.userData.wristPosition);
                
                // Calculate velocity (simpler approach) - prevent initial spikes
                if (isFirstFrame) {
                    hand.userData.velocity.set(0, 0, 0); // Zero velocity on first frame
                    hand.userData.startupFrames = 0; // Initialize startup counter
                } else {
                    hand.userData.velocity.subVectors(hand.userData.handCenter, previousCenter);
                    hand.userData.velocity.multiplyScalar(120); // Scale for reasonable velocity values
                    hand.userData.velocity.clampLength(0, 10); // Clamp to prevent extreme values from tracking glitches
                }
                
                // Increment startup counter
                hand.userData.startupFrames = (hand.userData.startupFrames || 0) + 1;
                
                // Simple pinch detection
                const thumbIndexDist = hand.userData.tipPositions.THUMB.distanceTo(hand.userData.tipPositions.INDEX);
                hand.userData.isPinching = thumbIndexDist < 0.04;
                
                // Improved fist detection - fingers close to wrist with weighted scoring
                const thumbToWrist = hand.userData.tipPositions.THUMB.distanceTo(hand.userData.wristPosition);
                const indexToWrist = hand.userData.tipPositions.INDEX.distanceTo(hand.userData.wristPosition);
                const middleToWrist = hand.userData.tipPositions.MIDDLE.distanceTo(hand.userData.wristPosition);
                
                // More reliable fist detection - require at least 2 of 3 fingers to be close
                const fistThreshold = 0.12;
                const closedFingers = [
                    thumbToWrist < fistThreshold,
                    indexToWrist < fistThreshold, 
                    middleToWrist < fistThreshold
                ].filter(closed => closed).length;
                
                hand.userData.isFist = closedFingers >= 2;
                
                // Calculate punch velocity only when fist is detected
                hand.userData.recentMaxVelocity = hand.userData.recentMaxVelocity || 0;
                if (hand.userData.isFist) {
                  hand.userData.recentMaxVelocity = Math.max(hand.userData.recentMaxVelocity, hand.userData.velocity.length());
                } else {
                  hand.userData.recentMaxVelocity = 0;
                }
                hand.userData.punchVelocity = hand.userData.isFist ? hand.userData.recentMaxVelocity : 0;
                
                // Update debug info
                if (hand.userData.debugHandIndex !== undefined) {
                    const handInfo = hand.userData.debugHandIndex === 0 ? debugInfo.leftHand : debugInfo.rightHand;
                    handInfo.isFist = hand.userData.isFist;
                    handInfo.velocity = hand.userData.punchVelocity;
                    handInfo.isReady = hand.userData.isReady;
                    handInfo.thumbDist = thumbToWrist;
                    handInfo.indexDist = indexToWrist;
                    handInfo.middleDist = middleToWrist;
                }
                
                // Pointing detection for teleportation
                if (hand.userData.debugHandIndex === 1) { // Right hand only
                    // Simple pointing: index finger extended, others curled
                    const indexExtended = indexToWrist > 0.15;
                    const othersRetracted = thumbToWrist < 0.12 && middleToWrist < 0.12;
                    hand.userData.isPointing = indexExtended && othersRetracted;
                }
                
            } catch (error) {
                console.warn('Hand tracking error:', error);
                hand.userData.isReady = false;
            }
        }


        function update() {
            const elapsedTime = clock.getElapsedTime();
            const dummy = new THREE.Object3D();
            frameCount++;
            const deltaTime = clock.getDelta();
            
            // Update frustum culling
            updateFrustumCulling();
            
            // Monitor frame rate and adjust quality for 120fps
            updateFrameRateMonitoring(deltaTime);
            
            
            // Update punch cooldowns
            if (punchCooldown1 > 0) {
                punchCooldown1 -= deltaTime;
            }
            if (punchCooldown2 > 0) {
                punchCooldown2 -= deltaTime;
            }

            // Only update hand data if XR is active
            if (renderer.xr.isPresenting) {
                updateHandData(hand1);
                updateHandData(hand2);
                handleGrabbing(hand1, heldVoxelMesh1);
                handleGrabbing(hand2, heldVoxelMesh2);
                
                // Game of Life touch interaction removed for performance
                
                // Handle teleportation (only use right hand to avoid conflicts)
                handleTeleportation(hand2, elapsedTime);
                
                // Handle punch detection - SIMPLIFIED
                [hand1, hand2].forEach((hand, index) => {
                    try {
                        const currentCooldown = index === 0 ? punchCooldown1 : punchCooldown2;
                        const startupFrames = hand.userData.startupFrames || 0;
                        
                        // Require startup grace period and no cooldown
                        if (currentCooldown > 0 || !hand.userData.isReady || startupFrames < 60) {
                            if (frameCount % 60 === 0 && currentCooldown > 0) {
                                console.log(`⏰ Hand ${index} on cooldown: ${currentCooldown.toFixed(2)}s remaining`);
                            }
                            if (frameCount % 60 === 0 && startupFrames < 60) {
                                console.log(`🚀 Hand ${index} in startup: ${startupFrames}/60 frames`);
                            }
                            return;
                        }
                        
                        // Update debug info
                        const handInfo = index === 0 ? debugInfo.leftHand : debugInfo.rightHand;
                        handInfo.isFist = hand.userData.isFist;
                        handInfo.velocity = hand.userData.punchVelocity;
                        handInfo.cooldown = currentCooldown;
                        handInfo.isReady = hand.userData.isReady;
                        
                        // AGGRESSIVE DEBUG: Log every frame when conditions are close
                        if (frameCount % 10 === 0) {
                            console.log(`🔍 DETAILED CHECK Hand ${index}:`, {
                                isFist: hand.userData.isFist,
                                velocity: hand.userData.punchVelocity?.toFixed(3) || 'undefined',
                                recentMax: hand.userData.recentMaxVelocity?.toFixed(3) || 'undefined',
                                rawVel: hand.userData.velocity?.length()?.toFixed(3) || 'undefined',
                                startupFrames: hand.userData.startupFrames,
                                cooldown: currentCooldown.toFixed(3),
                                isReady: hand.userData.isReady
                            });
                        }
                        
                        // Simple punch detection: fist + fast movement  
                        if (frameCount % 30 === 0 && hand.userData.isFist) {
                            console.log(`👊 PUNCH CHECK Hand ${index}: Fist=${hand.userData.isFist}, Velocity=${hand.userData.punchVelocity.toFixed(3)}, Will punch=${hand.userData.punchVelocity > 1.5}`);
                        }
                        
                        // SIMPLIFIED WORKING DETECTION: Use raw velocity only
                        const rawVelocity = hand.userData.velocity ? hand.userData.velocity.length() : 0;
                        if (hand.userData.isFist && rawVelocity > 2.5) {
                            console.log('👊 PUNCH DETECTED! Hand:', index, 'Raw velocity:', rawVelocity.toFixed(3));
                            handInfo.punchCount++;
                            console.log('🔢 Punch count for hand', index, ':', handInfo.punchCount);
                            
                            // Immediate visual feedback
                            createParticleExplosion(hand.userData.handCenter.clone());
                            
                            // Create blast effect
                            createPunchBlastEffect(hand.userData.handCenter, hand.userData.velocity.clone().normalize());
                            
                            // Affect nearby boids
                            let affectedCount = 0;
                            boids.forEach(boid => {
                                if (boid && boid.position) {
                                    const distance = hand.userData.handCenter.distanceTo(boid.position);
                                    if (distance < 3.0) {
                                        const pushDirection = new THREE.Vector3().subVectors(boid.position, hand.userData.handCenter).normalize();
                                        boid.velocity.add(pushDirection.multiplyScalar(2.0));
                                        affectedCount++;
                                    }
                                }
                            });
                            
                            console.log(`💥 Punch affected ${affectedCount} boids!`);
                            
                            // Set cooldown
                            if (index === 0) {
                                punchCooldown1 = PUNCH_COOLDOWN;
                            } else {
                                punchCooldown2 = PUNCH_COOLDOWN;
                            }
                            hand.userData.recentMaxVelocity = 0;
                        }
                        
                    } catch (error) {
                        console.warn('Punch detection error:', error);
                    }
                });
            }
            
            // Update debug overlay in VR mode
            if (renderer.xr.isPresenting && debugOverlay) {
                debugOverlay.visible = true;
                debugInfo.frameCount = frameCount;
                updateDebugOverlay();
            } else if (debugOverlay) {
                debugOverlay.visible = false;
            }
            
            // Update particles with performance optimization using object pool
            try {
                const shouldUpdateParticles = frameCount % PARTICLE_UPDATE_INTERVAL === 0;
                
                if (shouldUpdateParticles) {
                    particles = particles.filter(particle => {
                        if (!particle || !particle.position || !particle.velocity) {
                            if (particle) returnParticleToPool(particle);
                            return false;
                        }
                        
                        particle.life -= deltaTime * 2 * PARTICLE_UPDATE_INTERVAL;
                        if (particle.life <= 0) {
                            returnParticleToPool(particle);
                            return false;
                        }
                        
                        particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime * PARTICLE_UPDATE_INTERVAL));
                        particle.velocity.multiplyScalar(0.98); // Friction
                        return true;
                    });
                }
            } catch (error) {
                console.warn('Particle update error:', error);
                particles.forEach(p => returnParticleToPool(p));
                particles = []; // Clear particles on error
            }

            // Update held objects for both hands
            [hand1, hand2].forEach((hand, handIndex) => {
                // Check if hand tracking data is available
                if (!hand.userData || !hand.userData.tipPositions || !hand.userData.tipPositions.INDEX) {
                    return; // Skip if hand tracking not ready
                }
                
                const heldMesh = handIndex === 0 ? heldVoxelMesh1 : heldVoxelMesh2;
                
                // Update held voxel (revival mechanic)
                if (hand.userData.heldVoxelIndex !== null) {
                    // Check if we're holding a ground voxel
                    if (hand.userData.heldVoxelIndex < groundVoxels.length) {
                        const voxel = groundVoxels[hand.userData.heldVoxelIndex];
                        if (voxel && hand.userData.tipPositions.INDEX) {
                            heldMesh.position.copy(hand.userData.tipPositions.INDEX);
                            heldMesh.visible = true; // Make visible when holding
                            const chargeRatio = Math.min((elapsedTime - hand.userData.holdStartTime) / REVIVAL_TIME, 1.0);
                            const finalColor = new THREE.Color(0x00ffaa); // Default final color
                            heldMesh.material.color.lerpColors(new THREE.Color(0x550055), finalColor, chargeRatio);
                            heldMesh.material.emissive.lerpColors(new THREE.Color(0x550055), finalColor, chargeRatio);
                        }
                    }
                } else if (hand.userData.heldBoidIndex !== null) {
                    // Update held boid position
                    const boid = boids[hand.userData.heldBoidIndex];
                    if (boid && hand.userData.tipPositions.INDEX) {
                        heldMesh.position.copy(hand.userData.tipPositions.INDEX);
                        heldMesh.visible = true; // Make visible when holding
                        boid.position.copy(heldMesh.position);
                    }
                    
                    // Visual feedback for held boid
                    const holdTime = elapsedTime - hand.userData.holdStartTime;
                    const pulseFactor = (Math.sin(holdTime * 10) + 1) / 2;
                    heldMesh.material.emissive.setRGB(0.8 * pulseFactor, 0.2 * pulseFactor, 0.2 * pulseFactor);
                } else {
                    // Hide held mesh when not holding anything
                    heldMesh.visible = false;
                    heldMesh.position.set(0, -1000, 0); // Move far away
                }
            });
            
            
            // Temporal spreading of expensive updates for 120fps
            const currentFrame = frameCount % TEMPORAL_SPREAD_FRAMES;
            
            // Fountain system removed - too problematic
            
            // Game of Life updates removed for performance
            
            // Update sky battle and starfield (frames 1, 3, 5)
            if (currentFrame === updateQueues.skyBattle) {
                updateSkyBattle(deltaTime, elapsedTime);
                updateQueues.skyBattle = (updateQueues.skyBattle + 2) % TEMPORAL_SPREAD_FRAMES;
            }
            
            // Fountain mesh update removed - system eliminated
            
            // Update ground voxels with gentle glow effect
            if (groundVoxelsMesh) {
                const dummy = new THREE.Object3D();
                let activeGroundVoxels = 0;
                
                groundVoxels.forEach((voxel, i) => {
                    if (voxel && voxel.active) {
                        // Gentle floating animation
                        voxel.glowPhase += deltaTime * 2;
                        const glowOffset = Math.sin(voxel.glowPhase) * 0.02;
                        voxel.position.y = voxel.originalY + glowOffset;
                        
                        dummy.position.copy(voxel.position);
                        dummy.updateMatrix();
                        groundVoxelsMesh.setMatrixAt(activeGroundVoxels++, dummy.matrix);
                    }
                });
                
                groundVoxelsMesh.count = activeGroundVoxels;
                groundVoxelsMesh.instanceMatrix.needsUpdate = true;
                groundVoxelsMesh.visible = activeGroundVoxels > 0;
                
                // Occasionally respawn ground voxels if low count
                if (frameCount % 1800 === 0 && activeGroundVoxels < groundVoxelCount / 2) { // Every 15 seconds at 120fps
                    for (let i = 0; i < groundVoxels.length; i++) {
                        const voxel = groundVoxels[i];
                        if (voxel && !voxel.active) {
                            voxel.active = true;
                            voxel.position.set(
                                (Math.random() - 0.5) * boundSize * 0.8,
                                0.1,
                                (Math.random() - 0.5) * boundSize * 0.8
                            );
                            voxel.originalY = 0.1;
                            voxel.glowPhase = Math.random() * Math.PI * 2;
                            console.log('✨ Respawned ground voxel', i);
                            break; // Only respawn one per cycle
                        }
                    }
                }
            }

            const aliveVoxelsMesh = scene.getObjectByName('alive_voxels');
            if (aliveVoxelsMesh && boids.length > 0) {
                aliveVoxelsMesh.count = boids.length;
                
                // Performance optimization: only update flocking every few frames for distant boids
                const shouldUpdateFlocking = frameCount % OPTIMIZATION_INTERVAL === 0;
                
                // Spatial partitioning for 120fps collision detection
                spatialGrid.clear();
                boids.forEach(boid => spatialGrid.insert(boid));
                
                // LOD-based boid updates for 120fps
                let processedBoids = 0;
                const maxBoidsPerFrame = Math.ceil(boids.length * currentQualityLevel);
                
                // LOD-based flocking updates for performance
                
                boids.forEach((boid, i) => {
                    // Skip some boids based on quality level for 120fps
                    if (processedBoids >= maxBoidsPerFrame && !boid.isGrabbed) {
                        return; // Skip this boid this frame
                    }
                    
                    const distanceToCamera = camera.position.distanceTo(boid.position);
                    const lodLevel = getLODLevel(distanceToCamera);
                    const inFrustum = isObjectInFrustum(boid.position, 0.2);
                    
                    // Skip culled objects entirely
                    if (lodLevel === 'CULLED' && !boid.isGrabbed) {
                        return;
                    }
                    
                    if (!boid.isGrabbed && (inFrustum || distanceToCamera < CULLING_DISTANCE)) {
                        // Update frequency based on LOD level
                        let updateThisFrame = false;
                        switch(lodLevel) {
                            case 'CLOSE':
                                updateThisFrame = true; // Always update close objects
                                break;
                            case 'MEDIUM':
                                updateThisFrame = shouldUpdateFlocking || boid.isBeingTossed;
                                break;
                            case 'FAR':
                                updateThisFrame = (frameCount % (OPTIMIZATION_INTERVAL * 2) === 0) || boid.isBeingTossed;
                                break;
                        }
                        
                        if (updateThisFrame) {
                            // Use spatial partitioning for nearby boids instead of all boids
                            const nearbyBoids = spatialGrid.getNearby(boid.position, 3.0);
                            boid.flock(nearbyBoids, [hand1, hand2], [], predators);
                        }
                        boid.checkBounds();
                    }
                    
                    boid.update();
                    dummy.position.copy(boid.position);
                    
                    // Fix spinning issue: use smoothed direction instead of raw velocity
                    if (boid.velocity.length() > 0.05) {
                        const targetRotation = boid.position.clone().add(boid.smoothedDirection);
                        dummy.lookAt(targetRotation);
                    }
                    
                    dummy.updateMatrix();
                    aliveVoxelsMesh.setMatrixAt(i, dummy.matrix);
                    
                    // Apply punch effect glow - DISABLED to fix trail dots issue
                    if (boid.punchAffected) {
                        // Create glowing effect by temporarily changing material
                        const glowIntensity = Math.sin(clock.getElapsedTime() * 8) * 0.3 + 0.7;
                        // Note: Individual material changes are expensive, so we'll use a visual trail instead
                        // createPunchTrail(boid); // DISABLED - causing trail dots
                    }
                    
                    processedBoids++;
                });
                aliveVoxelsMesh.instanceMatrix.needsUpdate = true;
                
                // Update predators with performance optimization
                const predatorMesh = scene.getObjectByName('predators');
                if (predatorMesh && predators.length > 0) {
                    predatorMesh.count = predators.length;
                    const shouldUpdatePredatorMesh = frameCount % OPTIMIZATION_INTERVAL === 0;
                    
                    predators.forEach((predator, i) => {
                        try {
                            if (!predator.isGrabbed) {
                                if (shouldUpdatePredatorMesh) {
                                    predator.hunt(boids);
                                    predator.checkBounds();
                                }
                            }
                            predator.update();
                            
                            // Only update matrix if updating mesh
                            if (shouldUpdatePredatorMesh) {
                                dummy.position.copy(predator.position);
                                if (predator.velocity && predator.velocity.length() > 0.01) {
                                    dummy.lookAt(predator.position.clone().add(predator.velocity));
                                }
                                dummy.updateMatrix();
                                predatorMesh.setMatrixAt(i, dummy.matrix);
                            }
                        } catch (error) {
                            console.warn('Predator update error:', error);
                        }
                    });
                    
                    if (shouldUpdatePredatorMesh) {
                        predatorMesh.instanceMatrix.needsUpdate = true;
                    }
                }
            }
        }

        function render() { renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        // Object pooling for particles
        function initParticlePool() {
            particlePool = [];
            for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
                particlePool.push({
                    position: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    life: 0,
                    maxLife: 1,
                    inUse: false
                });
            }
        }
        
        function getParticleFromPool() {
            for (let i = 0; i < particlePool.length; i++) {
                if (!particlePool[i].inUse) {
                    particlePool[i].inUse = true;
                    return particlePool[i];
                }
            }
            return null; // Pool exhausted
        }
        
        function returnParticleToPool(particle) {
            particle.inUse = false;
            particle.life = 0;
        }
        
        // Frustum culling function
        function updateFrustumCulling() {
            cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(cameraMatrix);
        }
        
        function isObjectInFrustum(position, radius = 1.0) {
            const sphere = new THREE.Sphere(position, radius);
            return frustum.intersectsSphere(sphere);
        }
        
        // Initialize shared materials for performance optimization (120fps optimized)
        function initSharedMaterials() {
            // Use MeshBasicMaterial for maximum performance (no lighting calculations)
            sharedMaterials.boidMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                transparent: false, // Disable transparency for performance
                fog: false // Disable fog for performance
            });
            
            sharedMaterials.particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: false, // Disable transparency for performance
                fog: false
            });
            
            sharedMaterials.starMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffaa,
                transparent: false,
                fog: false
            });
            
            sharedMaterials.spaceMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: false,
                fog: false
            });
            
            // Fountain material removed - system eliminated
            
            // Quality-based material switching
            sharedMaterials.updateForQuality = function(qualityLevel) {
                const useBasicMaterials = qualityLevel < 0.7;
                
                if (useBasicMaterials) {
                    // Switch to basic materials for better performance
                    Object.values(sharedMaterials).forEach(material => {
                        if (material && material.type) {
                            material.transparent = false;
                            material.fog = false;
                        }
                    });
                }
            };
        }
        
        // Frame rate monitoring and dynamic quality scaling for 120fps
        function updateFrameRateMonitoring(deltaTime) {
            if (deltaTime > 0) {
                const currentFPS = 1 / deltaTime;
                frameRateHistory.push(currentFPS);
                
                // Keep only last 60 frames for rolling average
                if (frameRateHistory.length > 60) {
                    frameRateHistory.shift();
                }
                
                // Calculate average FPS every 60 frames
                if (frameRateHistory.length >= 60) {
                    const avgFPS = frameRateHistory.reduce((a, b) => a + b) / frameRateHistory.length;
                    
                    // Dynamic quality scaling
                    if (avgFPS < MIN_FRAME_RATE) {
                        currentQualityLevel = Math.max(0.3, currentQualityLevel - 0.1);
                        console.log(`🔻 Quality reduced to ${(currentQualityLevel * 100).toFixed(0)}% (FPS: ${avgFPS.toFixed(1)})`);
                    } else if (avgFPS > TARGET_FRAME_RATE * 0.95 && currentQualityLevel < 1.0) {
                        currentQualityLevel = Math.min(1.0, currentQualityLevel + 0.05);
                        console.log(`🔺 Quality increased to ${(currentQualityLevel * 100).toFixed(0)}% (FPS: ${avgFPS.toFixed(1)})`);
                    }
                    
                    frameRateHistory = []; // Reset for next measurement
                }
            }
        }
        
        // LOD system for objects based on distance
        function getLODLevel(distance) {
            if (distance < LOD_DISTANCES.CLOSE) return 'CLOSE';
            if (distance < LOD_DISTANCES.MEDIUM) return 'MEDIUM';
            if (distance < LOD_DISTANCES.FAR) return 'FAR';
            return 'CULLED';
        }
        
        // Initialize VR debug overlay
        function initDebugOverlay() {
            // Create debug overlay positioned in VR space
            debugOverlay = new THREE.Group();
            debugOverlay.position.set(2, 2, -3); // Position to upper right in VR
            
            // Create background panel
            const panelGeometry = new THREE.PlaneGeometry(6, 4.5);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            debugOverlay.add(panel);
            
            // Create text using canvas texture
            const canvas = document.createElement('canvas');
            canvas.width = 800;
            canvas.height = 600;
            const context = canvas.getContext('2d');
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const textGeometry = new THREE.PlaneGeometry(6, 4);
            debugText = new THREE.Mesh(textGeometry, textMaterial);
            debugText.position.z = 0.01; // Slightly in front of panel
            debugOverlay.add(debugText);
            
            // Store canvas and context for updating
            debugText.canvas = canvas;
            debugText.context = context;
            debugText.texture = texture;
            
            scene.add(debugOverlay);
            debugOverlay.visible = false; // Hidden by default
            
            console.log('🔍 Debug overlay initialized');
        }

        // Update debug overlay with current info
        function updateDebugOverlay() {
            if (!debugText || !debugText.context) return;
            
            const ctx = debugText.context;
            const canvas = debugText.canvas;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set text style
            ctx.fillStyle = '#00ff00';
            ctx.font = '20px monospace';
            ctx.textAlign = 'left';
            
            // Draw debug information
            let y = 30;
            ctx.fillText('=== FORCE PUNCH DEBUG ===', 10, y);
            y += 25;
            ctx.fillText(`Frame: ${debugInfo.frameCount}`, 10, y);
            y += 35;
            
            ctx.fillText(`LEFT HAND:`, 10, y);
            y += 25;
            ctx.fillText(`  Ready: ${debugInfo.leftHand.isReady ? 'YES' : 'NO'}`, 10, y);
            y += 20;
            ctx.fillText(`  Fist: ${debugInfo.leftHand.isFist ? 'YES' : 'NO'}`, 10, y);
            y += 20;
            ctx.fillText(`  Velocity: ${debugInfo.leftHand.velocity.toFixed(3)} (need >1.5)`, 10, y);
            y += 20;
            ctx.fillText(`  Punches: ${debugInfo.leftHand.punchCount}`, 10, y);
            y += 20;
            ctx.fillText(`  Cooldown: ${debugInfo.leftHand.cooldown.toFixed(2)}s`, 10, y);
            y += 20;
            ctx.fillText(`  Thumb: ${debugInfo.leftHand.thumbDist.toFixed(3)} (<0.16)`, 10, y);
            y += 20;
            ctx.fillText(`  Index: ${debugInfo.leftHand.indexDist.toFixed(3)} (<0.16)`, 10, y);
            y += 20;
            ctx.fillText(`  Middle: ${debugInfo.leftHand.middleDist.toFixed(3)} (<0.16)`, 10, y);
            y += 30;
            
            ctx.fillText(`RIGHT HAND:`, 10, y);
            y += 25;
            ctx.fillText(`  Ready: ${debugInfo.rightHand.isReady ? 'YES' : 'NO'}`, 10, y);
            y += 20;
            ctx.fillText(`  Fist: ${debugInfo.rightHand.isFist ? 'YES' : 'NO'}`, 10, y);
            y += 20;
            ctx.fillText(`  Velocity: ${debugInfo.rightHand.velocity.toFixed(3)} (need >1.5)`, 10, y);
            y += 20;
            ctx.fillText(`  Punches: ${debugInfo.rightHand.punchCount}`, 10, y);
            y += 20;
            ctx.fillText(`  Cooldown: ${debugInfo.rightHand.cooldown.toFixed(2)}s`, 10, y);
            y += 20;
            ctx.fillText(`  Thumb: ${debugInfo.rightHand.thumbDist.toFixed(3)} (<0.16)`, 10, y);
            y += 20;
            ctx.fillText(`  Index: ${debugInfo.rightHand.indexDist.toFixed(3)} (<0.16)`, 10, y);
            y += 20;
            ctx.fillText(`  Middle: ${debugInfo.rightHand.middleDist.toFixed(3)} (<0.16)`, 10, y);
            
            // Update texture
            debugText.texture.needsUpdate = true;
        }

        // Initialize teleportation system
        function initTeleportationSystem() {
            // Create teleport reticle
            const reticleGeometry = new THREE.RingGeometry(0.2, 0.3, 16);
            const reticleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            teleportReticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            teleportReticle.visible = false;
            teleportReticle.rotation.x = -Math.PI / 2; // Flat on ground
            scene.add(teleportReticle);
            
            // Create teleport progress indicator
            const indicatorGeometry = new THREE.RingGeometry(0.1, 0.4, 16);
            const indicatorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            teleportIndicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            teleportIndicator.visible = false;
            teleportIndicator.rotation.x = -Math.PI / 2; // Flat on ground
            scene.add(teleportIndicator);
            
            // Create teleport ray line
            const rayGeometry = new THREE.BufferGeometry();
            const rayPositions = new Float32Array(6); // 2 points * 3 coordinates
            rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
            const rayMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.7,
                linewidth: 3
            });
            teleportRayLine = new THREE.Line(rayGeometry, rayMaterial);
            teleportRayLine.visible = false;
            scene.add(teleportRayLine);
            
            console.log('🚀 Teleportation system initialized');
        }

        async function init() {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Initialize camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Create global player rig for VR movement
            window.playerRig = new THREE.Group();
            scene.add(window.playerRig);
            window.playerRig.add(camera);
            window.playerRig.position.set(0, 0, 3);
            camera.position.set(0, 1.6, 0);
            
            // Initialize renderer with Quest 3 120fps optimizations
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, // Disable for 120fps performance
                alpha: false,
                depth: true,
                stencil: false,
                powerPreference: "high-performance" // Request high-performance GPU
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio for performance
            renderer.shadowMap.enabled = false; // Disable shadows for 120fps
            renderer.outputEncoding = THREE.sRGBEncoding; // Ensure correct color space
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Optimized tone mapping
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
            
            // Initialize clock
            clock = new THREE.Clock();
            
            // Initialize particle pool for better performance
            initParticlePool();
            
            // Initialize shared materials for performance optimization
            initSharedMaterials();
            
            // Initialize teleportation indicators
            initTeleportationSystem();
            
            // Initialize debug overlay
            initDebugOverlay();
            
            // Setup WebXR with Quest 3 optimizations
            renderer.xr.enabled = true;
            
            // Enable foveated rendering for Quest 3 120fps
            if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                if (session && session.supportedFrameRates) {
                    // Request 120fps if supported
                    session.requestReferenceSpace('local').then(referenceSpace => {
                        if (session.supportedFrameRates.includes(120)) {
                            session.updateRenderState({
                                baseLayer: new XRWebGLLayer(session, renderer.context, {
                                    antialias: false, // Disable for performance
                                    alpha: false,
                                    depth: true,
                                    stencil: false,
                                    framebufferScaleFactor: 0.8 // Reduce resolution for 120fps
                                }),
                                refreshRate: 120
                            });
                            console.log('🚀 Quest 3 120fps mode enabled with foveated rendering');
                        }
                    });
                }
            }
            
            document.body.appendChild(VRButton.createButton(renderer));
            
            // Add hand tracking with proper mesh models
            const handModelFactory = new XRHandModelFactory();
            
            // Left hand (index 0)
            hand1 = renderer.xr.getHand(0);
            const handModel1 = handModelFactory.createHandModel(hand1, 'mesh');
            handModel1.name = 'leftHandMesh';
            hand1.add(handModel1);
            window.playerRig.add(hand1);
            console.log('✋ Left hand model created:', handModel1.type || 'mesh');
            
            // Right hand (index 1)  
            hand2 = renderer.xr.getHand(1);
            const handModel2 = handModelFactory.createHandModel(hand2, 'mesh');
            handModel2.name = 'rightHandMesh';
            hand2.add(handModel2);
            window.playerRig.add(hand2);
            console.log('✋ Right hand model created:', handModel2.type || 'mesh');
            
            // Ensure no sphere fallback - force mesh type only
            handModel1.visible = true;
            handModel2.visible = true;
            
            // Initialize hand userData
            [hand1, hand2].forEach((hand, index) => {
                hand.userData = {
                    tipPositions: {
                        THUMB: new THREE.Vector3(),
                        INDEX: new THREE.Vector3(),
                        MIDDLE: new THREE.Vector3()
                    },
                    wristPosition: new THREE.Vector3(),
                    handCenter: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    isPinching: false,
                    isFist: false,
                    isPointing: false,
                    isReady: false,
                    heldVoxelIndex: null,
                    heldBoidIndex: null,
                    holdStartTime: 0,
                    isGrabbingBoid: false,
                    punchVelocity: 0,
                    debugHandIndex: index
                };
            });
            
            // Setup lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create boids async
            await createBoidsAsync();
            
            // Create world content async
            await Promise.all([
                createVectorGridGround(),
                createGroundVoxels(),
                createBoidsSystem(),
                createSpaceBattle()
            ]);
            
            // Setup event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Add fallback controls for desktop
            addFallbackControls();
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }

        async function createBoidsAsync() {
            for (let i = 0; i < initialBoidCount; i++) {
                const boid = new Boid(
                    new THREE.Vector3(
                        (Math.random() - 0.5) * ATMOSPHERE_RADIUS,
                        Math.random() * (ATMOSPHERE_MAX_HEIGHT - 2) + 2, // 2-28m height
                        (Math.random() - 0.5) * ATMOSPHERE_RADIUS
                    )
                );
                boids.push(boid);
                if (i % 10 === 0) await new Promise(resolve => setTimeout(resolve, 0)); // Yield to prevent blocking
            }
        }
        
        function animate() {
            update();
            render();
        }

        // Call init after all definitions
        init();
    </script>
</body>
</html>