<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Boids with Glowing Tree</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; background-color: #111; color: #fff; overflow: hidden; }
        #info { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); padding: 15px 25px; background-color: rgba(0, 0, 0, 0.5); border-radius: 12px; text-align: center; font-size: 16px; z-index: 10; max-width: 90%; }
        #vr-button { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; border: 1px solid #fff; background-color: rgba(0,0,0,0.5); color: #fff; padding: 12px 24px; border-radius: 999px; cursor: pointer; font-weight: 600; }
        #vr-button:hover { background-color: rgba(255,255,255,0.2); }
        
        /* VR Mode - Specifically target UI elements only, not WebXR internals */
        .vr-active #info {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active #vr-button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active #threejs-vr-button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active div:not([id]) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        /* Ensure canvas and WebXR elements remain visible */
        .vr-active canvas {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">
        WebXR Boids: Flocking, Tossing, Predators & Force Punch<br>
        Grab boids to toss ‚Ä¢ Shake for predators ‚Ä¢ Make fist and punch to blast!<br>
        <small>Point with right hand for 3 seconds to teleport</small>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let camera, scene, renderer, clock;
        let boids = [];
        let predators = [];
        let particles = [];
        let particlePool = []; // Object pool for particles
        const PARTICLE_POOL_SIZE = 100;
        let hand1, hand2;
        
        let interactiveVoxels = [];
        let groundVoxels = [];
        let heldVoxelMesh1, heldVoxelMesh2;
        let groundVoxelsMesh;
        // Game of Life monolith system removed for performance
        const REVIVAL_TIME = 3; 
        const SHAKE_THRESHOLD = 0.8; // Reduced shake intensity needed to create predator

        const initialBoidCount = 25; // Further reduced by 50% for better performance
        const interactiveVoxelCount = 0; // Disabled for performance
        const groundVoxelCount = 15; // Scattered ground voxels for testing
        const boundSize = 20;
        
        // Punch blast variables
        let punchCooldown1 = 0;
        let punchCooldown2 = 0;
        const PUNCH_COOLDOWN = 0.5; // Seconds between punches
        const PUNCH_FORCE_RADIUS = 2.0; // Radius of punch force blast
        
        // Performance optimization variables - Aggressive for 120fps Quest 3
        let frameCount = 0;
        const OPTIMIZATION_INTERVAL = 40; // Reduced frequency for 120fps
        const SPACE_UPDATE_INTERVAL = 120; // Update stars every 120 frames (1 second at 120fps)
        const ORBITAL_UPDATE_INTERVAL = 60; // Update asteroids every 60 frames (0.5 seconds)
        const PARTICLE_UPDATE_INTERVAL = 30; // Update particles every 30 frames
        // Fountain constants removed - system eliminated
        
        // Level-of-Detail (LOD) system for 120fps
        const LOD_DISTANCES = {
            CLOSE: 10,    // Full detail
            MEDIUM: 30,   // Reduced detail
            FAR: 60       // Minimal detail
        };
        
        // Frame rate monitoring for dynamic scaling
        let frameRateHistory = [];
        let currentQualityLevel = 1.0; // 1.0 = full quality, 0.5 = half quality
        const TARGET_FRAME_RATE = 120;
        const MIN_FRAME_RATE = 90;
        
        // Temporal update spreading for 120fps
        let updateQueues = {
            fountain: 0,
            skyBattle: 1,
            particles: 2
        };
        const TEMPORAL_SPREAD_FRAMES = 6; // Spread updates across 6 frames
        
        // Spatial partitioning for collision detection optimization
        class SpatialGrid {
            constructor(cellSize = 5.0) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }
            
            clear() {
                this.grid.clear();
            }
            
            getKey(x, y, z) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                const gz = Math.floor(z / this.cellSize);
                return `${gx},${gy},${gz}`;
            }
            
            insert(object) {
                const key = this.getKey(object.position.x, object.position.y, object.position.z);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(object);
            }
            
            getNearby(position, radius = 1.0) {
                const nearby = [];
                const cellsToCheck = Math.ceil(radius / this.cellSize);
                
                for (let dx = -cellsToCheck; dx <= cellsToCheck; dx++) {
                    for (let dy = -cellsToCheck; dy <= cellsToCheck; dy++) {
                        for (let dz = -cellsToCheck; dz <= cellsToCheck; dz++) {
                            const key = this.getKey(
                                position.x + dx * this.cellSize,
                                position.y + dy * this.cellSize,
                                position.z + dz * this.cellSize
                            );
                            const cell = this.grid.get(key);
                            if (cell) {
                                nearby.push(...cell);
                            }
                        }
                    }
                }
                return nearby;
            }
        }
        
        const spatialGrid = new SpatialGrid(3.0); // 3 unit cells for boid flocking
        
        // Frustum culling
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();
        const CULLING_DISTANCE = 100; // Distance beyond which objects are culled
        
        // Shared materials for performance optimization
        const sharedMaterials = {
            boidMaterial: null,
            particleMaterial: null,
            starMaterial: null,
            spaceMaterial: null,
            fountainMaterial: null
        };
        
        
        // Three-layer sky system
        let stars = [];
        let asteroids = [];
        let spaceShips = [];
        let spaceBullets = [];
        let shootingStars = [];
        
        // Layer 1: Atmosphere (0-30m above user) - Boids flight zone
        const ATMOSPHERE_MIN_HEIGHT = 0;
        const ATMOSPHERE_MAX_HEIGHT = 30;
        const ATMOSPHERE_RADIUS = 40;
        
        // Layer 2: Orbital Space (30-60m above user) - Asteroids simulation
        const ORBITAL_MIN_HEIGHT = 30;
        const ORBITAL_MAX_HEIGHT = 60;
        const ORBITAL_RADIUS = 120; // Much larger area for asteroids and ships
        const ASTEROID_COUNT = 6;
        const SPACESHIP_COUNT = 1;
        const ASTEROID_SPEED = 12.25; // Reduced by another 30% (was 17.5)
        const SPACESHIP_SPEED = 3.92; // Reduced by another 30% (was 5.6)
        const SPACE_BULLET_SPEED = 35.0; // Much faster than spaceship (8.0 max speed)
        
        // Layer 3: Space (60m+ above user) - Distant starfield
        const SPACE_MIN_HEIGHT = 60;
        const SPACE_MAX_HEIGHT = 100;
        const SPACE_RADIUS = 200; // Much larger area for stars
        const SKY_RADIUS = 150; // Define SKY_RADIUS for bullet bounds
        const STAR_COUNT = 150; // More stars for distant effect
        const SHOOTING_STAR_SPAWN_RATE = 0.05;
        const SHOOTING_STAR_SPEED = 15.0;
        
        
        // Teleportation system
        let teleportRaycaster = new THREE.Raycaster();
        let teleportIndicator = null;
        let teleportHoldStartTime = 0;
        let teleportTargetPosition = null;
        let teleportReticle = null;
        let teleportRayLine = null;
        let isPointingForTeleport = false;
        const TELEPORT_HOLD_TIME = 3.0; // Seconds to hold for teleport
        const TELEPORT_SHAKE_TOLERANCE = 0.2; // Allowance for hand shake
        const TELEPORT_MAX_DISTANCE = 15; // Maximum teleport range

        // VR Debug overlay system
        let debugOverlay = null;
        let debugText = null;
        let debugInfo = {
            leftHand: { isFist: false, velocity: 0, cooldown: 0, thumbDist: 0, indexDist: 0, middleDist: 0, isReady: false, punchCount: 0 },
            rightHand: { isFist: false, velocity: 0, cooldown: 0, thumbDist: 0, indexDist: 0, middleDist: 0, isReady: false, punchCount: 0 },
            frameCount: 0
        };
        
        // In-VR Console Log System
        let vrConsoleLog = [];
        const MAX_VR_LOG_LINES = 15;
        
        function addVRLog(message) {
            const timestamp = performance.now().toFixed(0);
            vrConsoleLog.push(`[${timestamp}] ${message}`);
            if (vrConsoleLog.length > MAX_VR_LOG_LINES) {
                vrConsoleLog.shift(); // Remove oldest log
            }
        }
        
        // Override console.log to capture logs
        const originalConsoleLog = console.log;
        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            // Only capture hand-related debug messages for VR display
            const message = args.join(' ');
            if (message.includes('üëä') || message.includes('‚è∞') || message.includes('üîç') || 
                message.includes('‚ö†Ô∏è') || message.includes('üî¢') || message.includes('üìä') ||
                message.includes('‚úÖ') || message.includes('Hand') || message.includes('Fist') ||
                message.includes('Cooldown') || message.includes('Punch') || message.includes('velocity')) {
                addVRLog(message);
            }
        };

        // --- NEW: Obstacles for boids to avoid ---
        // Tron trees and obstacles removed for performance
        
        
        
        // --- Sky Asteroids Classes ---
        class Star {
            constructor() {
                // Position in distant space layer (60m+ above user)
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * SPACE_RADIUS,
                    SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                    (Math.random() - 0.5) * SPACE_RADIUS
                );
                this.brightness = Math.random() * 0.8 + 0.2;
                this.twinkleSpeed = Math.random() * 2 + 1;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const geometry = new THREE.SphereGeometry(0.2, 8, 8); // Larger and more detailed for better VR visibility
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: this.brightness * 0.8 + 0.2, // Ensure minimum visibility
                    emissive: 0x222222 // Slight glow for better visibility
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(elapsedTime) {
                if (this.mesh) {
                    const twinkle = (Math.sin(elapsedTime * this.twinkleSpeed) + 1) / 2;
                    // Enhanced twinkling with better minimum visibility
                    this.mesh.material.opacity = (this.brightness * 0.8 + 0.2) * (0.5 + 0.5 * twinkle);
                }
            }
        }
        
        class Asteroid {
            constructor(position, size = 'large') {
                // Position in orbital space layer (30-60m above user)
                this.position = position || new THREE.Vector3(
                    (Math.random() - 0.5) * ORBITAL_RADIUS,
                    ORBITAL_MIN_HEIGHT + Math.random() * (ORBITAL_MAX_HEIGHT - ORBITAL_MIN_HEIGHT),
                    (Math.random() - 0.5) * ORBITAL_RADIUS
                );
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * ASTEROID_SPEED * 3.0, // Even more varied movement
                    (Math.random() - 0.5) * ASTEROID_SPEED * 2.0, // More dramatic Y movement
                    (Math.random() - 0.5) * ASTEROID_SPEED * 3.0
                );
                this.rotation = new THREE.Vector3(
                    Math.random() * 0.05, // Increased rotation for more visible movement
                    Math.random() * 0.05,
                    Math.random() * 0.05
                );
                this.size = size; // large, medium, small
                this.health = size === 'large' ? 3 : size === 'medium' ? 2 : 1;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const sizes = { large: 2.0, medium: 1.2, small: 0.7 };
                const radius = sizes[this.size];
                
                // Create irregular asteroid shape
                const geometry = new THREE.DodecahedronGeometry(radius, 0);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x888888,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                const oldPosition = this.position.clone();
                
                // FORCE CONSTANT MOVEMENT - bypass all other logic for testing
                this.position.x += 0.14; // Move 0.14 units per frame (reduced by 30%)
                this.position.z += 0.07; // Move diagonally for visibility (reduced by 30%)
                
                // Debug minimal logging
                if (Math.random() < 0.05) {
                    console.log(`üåå FORCED movement: position(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)})`);
                }
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.x += this.rotation.x;
                    this.mesh.rotation.y += this.rotation.y;
                    this.mesh.rotation.z += this.rotation.z;
                }
                
                // Wrap around orbital space boundaries (30-60m layer)
                const halfRadius = ORBITAL_RADIUS / 2;
                if (this.position.x > halfRadius) {
                    this.position.x = -halfRadius;
                }
                if (this.position.x < -halfRadius) {
                    this.position.x = halfRadius;
                }
                if (this.position.z > halfRadius) {
                    this.position.z = -halfRadius;
                }
                if (this.position.z < -halfRadius) {
                    this.position.z = halfRadius;
                }
                
                // Keep within height bounds
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                
                // Enhanced debug logging for asteroid movement
                const moved = oldPosition.distanceTo(this.position) > 0.1;
                if (moved && Math.random() < 0.05) { // More frequent logging
                    console.log(`üåå Asteroid moving: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) speed=${ASTEROID_SPEED}`);
                }
            }
            
            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    this.split();
                    return true; // Mark for removal
                }
                return false;
            }
            
            split() {
                if (this.size === 'large') {
                    // Split into 2 medium asteroids
                    for (let i = 0; i < 2; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        const newAsteroid = new Asteroid(this.position.clone().add(offset), 'medium');
                        asteroids.push(newAsteroid);
                    }
                } else if (this.size === 'medium') {
                    // Split into 2 small asteroids
                    for (let i = 0; i < 2; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 1,
                            (Math.random() - 0.5) * 1,
                            (Math.random() - 0.5) * 1
                        );
                        const newAsteroid = new Asteroid(this.position.clone().add(offset), 'small');
                        asteroids.push(newAsteroid);
                    }
                }
                
                this.destroy();
                console.log(`üí• ${this.size} asteroid destroyed!`);
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        class SpaceShip {
            constructor() {
                // Position in orbital space layer (30-60m above user)
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * ORBITAL_RADIUS,
                    ORBITAL_MIN_HEIGHT + Math.random() * (ORBITAL_MAX_HEIGHT - ORBITAL_MIN_HEIGHT),
                    (Math.random() - 0.5) * ORBITAL_RADIUS
                );
                this.velocity = new THREE.Vector3();
                this.rotation = Math.random() * Math.PI * 2;
                this.angularVelocity = 0;
                this.target = null;
                this.lastFireTime = 0;
                this.mesh = null;
                this.thrust = false;
                
                this.createMesh();
            }
            
            createMesh() {
                const shipGroup = new THREE.Group();
                
                // Appropriately sized triangular ship shape for VR
                const shipGeometry = new THREE.ConeGeometry(1.0, 3.0, 3); // Reasonable size for VR visibility
                const shipMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 1.0,
                    emissive: 0x006666
                });
                const ship = new THREE.Mesh(shipGeometry, shipMaterial);
                ship.rotation.x = Math.PI / 2; // Point forward
                shipGroup.add(ship);
                
                // Engine glow effect removed per user request
                
                this.mesh = shipGroup;
                this.mesh.position.copy(this.position);
                this.mesh.visible = true;
                scene.add(shipGroup);
                
                console.log('Enhanced spaceship created with maximum visibility');
            }
            
            update(deltaTime, elapsedTime) {
                // Find nearest asteroid
                this.findTarget();
                
                // AI behavior
                this.updateAI(deltaTime);
                
                // Update physics
                const oldPosition = this.position.clone();
                
                // Use velocity-based movement from AI with forced deltaTime
                const forcedDeltaTime = 1/60; // Assume 60fps to bypass deltaTime issues
                this.position.add(this.velocity.clone().multiplyScalar(forcedDeltaTime));
                this.rotation += this.angularVelocity * forcedDeltaTime;
                
                // Apply velocity damping to prevent runaway acceleration
                this.velocity.multiplyScalar(0.98);
                this.angularVelocity *= 0.9;
                
                // Debug minimal logging
                if (Math.random() < 0.05) {
                    console.log(`üöÄ AI spaceship movement: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) target=${this.target ? 'YES' : 'NO'} thrust=${this.thrust ? 'YES' : 'NO'}`);
                }
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.y = this.rotation;
                    
                    // Engine glow animation removed
                }
                
                // Enhanced debug logging for spaceship movement
                const moved = oldPosition.distanceTo(this.position) > 0.1;
                if (moved && Math.random() < 0.05) { // More frequent logging
                    console.log(`üöÄ Spaceship moving: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) target=${this.target ? 'YES' : 'NO'}`);
                }
                
                // Wrap around orbital space boundaries (30-60m layer)
                const halfRadius = ORBITAL_RADIUS / 2;
                if (this.position.x > halfRadius) {
                    this.position.x = -halfRadius;
                }
                if (this.position.x < -halfRadius) {
                    this.position.x = halfRadius;
                }
                if (this.position.z > halfRadius) {
                    this.position.z = -halfRadius;
                }
                if (this.position.z < -halfRadius) {
                    this.position.z = halfRadius;
                }
                
                // Keep within height bounds
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                
                // Try to fire
                this.tryFire(elapsedTime);
            }
            
            findTarget() {
                let closestAsteroid = null;
                let closestDistance = 80; // Much longer detection range for aggressive hunting
                
                // Always actively hunt for asteroids
                for (const asteroid of asteroids) {
                    if (!asteroid || asteroid.health <= 0) continue;
                    const distance = this.position.distanceTo(asteroid.position);
                    if (distance < closestDistance) {
                        closestAsteroid = asteroid;
                        closestDistance = distance;
                    }
                }
                
                // Debug target acquisition
                if (this.target !== closestAsteroid) {
                    if (closestAsteroid) {
                        console.log(`üéØ Spaceship acquired new target at distance ${closestDistance.toFixed(1)}`);
                    } else if (this.target) {
                        console.log(`‚ùå Spaceship lost target`);
                    }
                }
                
                this.target = closestAsteroid;
            }
            
            updateAI(deltaTime) {
                // Reset thrust flag
                this.thrust = false;
                
                // Use forced deltaTime for consistency
                const forcedDeltaTime = 1/60; // Assume 60fps to bypass deltaTime issues
                
                if (this.target) {
                    const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                    const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                    
                    // Turn towards target
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    this.angularVelocity += Math.sign(angleDiff) * 0.1;
                    
                    // Always thrust towards target - more aggressive behavior
                    const thrustForce = new THREE.Vector3(
                        Math.sin(this.rotation),
                        0,
                        Math.cos(this.rotation)
                    ).multiplyScalar(SPACESHIP_SPEED * forcedDeltaTime * 15.0); // Even higher thrust for more dramatic movement
                    
                    this.velocity.add(thrustForce);
                    this.thrust = true;
                    
                    // Much more aggressive turning for faster target acquisition
                    this.angularVelocity += Math.sign(angleDiff) * 0.5;
                } else {
                    // More active patrol when no target
                    if (Math.random() < 0.05) {
                        this.angularVelocity += (Math.random() - 0.5) * 1.0;
                    }
                    if (Math.random() < 0.3) { // Much more frequent thrust for active patrol
                        const thrustForce = new THREE.Vector3(
                            Math.sin(this.rotation),
                            0,
                            Math.cos(this.rotation)
                        ).multiplyScalar(SPACESHIP_SPEED * forcedDeltaTime * 12.0); // Much faster patrol movement
                        
                        this.velocity.add(thrustForce);
                        this.thrust = true;
                    }
                }
            }
            
            tryFire(elapsedTime) {
                if (!this.target) return;
                if (elapsedTime - this.lastFireTime < 0.3) return; // Faster fire rate
                
                const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                const distance = toTarget.length();
                
                // Fire if target is within range and roughly aimed
                if (distance < 40) { // Longer firing range to match detection range
                    const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Very lenient aiming requirement for more action
                    if (Math.abs(angleDiff) < Math.PI / 2.5) { // Even wider 72 degree cone for better hits
                        this.fire();
                        this.lastFireTime = elapsedTime;
                        console.log(`üöÄ Spaceship firing at asteroid! Distance: ${distance.toFixed(1)} units, angle diff: ${(angleDiff * 180 / Math.PI).toFixed(1)} degrees`);
                    }
                }
            }
            
            fire() {
                const bulletStart = this.position.clone();
                
                // Aim directly at target for better accuracy
                if (this.target) {
                    const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                    const direction = toTarget.normalize();
                    
                    const bullet = new SpaceBullet(bulletStart, direction, this);
                    spaceBullets.push(bullet);
                    
                    console.log(`üöÄ Space ship fired directly at target! Target at (${this.target.position.x.toFixed(1)}, ${this.target.position.y.toFixed(1)}, ${this.target.position.z.toFixed(1)})`);
                } else {
                    // Fallback to ship orientation
                    const direction = new THREE.Vector3(
                        Math.sin(this.rotation),
                        0,
                        Math.cos(this.rotation)
                    );
                    
                    const bullet = new SpaceBullet(bulletStart, direction, this);
                    spaceBullets.push(bullet);
                    
                    console.log('üöÄ Space ship fired without target!');
                }
            }
        }
        
        class SpaceBullet {
            constructor(position, direction, shooter) {
                this.position = position.clone();
                this.velocity = direction.clone().multiplyScalar(SPACE_BULLET_SPEED);
                this.shooter = shooter;
                this.life = 4.0; // Seconds - balanced lifetime
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                // Create photon torpedo-style projectile
                const torpedoGroup = new THREE.Group();
                
                // Main torpedo body - elongated cylinder
                const bodyGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.4, 6);
                const bodyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff8800,
                    transparent: true,
                    opacity: 1.0,
                    emissive: 0xff4400  // Much brighter emissive glow
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2; // Point forward
                torpedoGroup.add(body);
                
                // Intense glowing energy core
                const coreGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const coreMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffdd00,
                    transparent: true,
                    opacity: 1.0,
                    emissive: 0xff8800  // Intense bright glow
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                torpedoGroup.add(core);
                
                // Outer glow aura
                const auraGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const auraMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.4,
                    emissive: 0xff6600
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                torpedoGroup.add(aura);
                
                // Enhanced energy trail effect
                const trailGeometry = new THREE.ConeGeometry(0.04, 0.3, 6);
                const trailMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff44,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xff6600  // Brighter trail glow
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.x = -0.2; // Behind the torpedo
                trail.rotation.z = -Math.PI / 2; // Point backward
                torpedoGroup.add(trail);
                
                this.mesh = torpedoGroup;
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                // FORCE CONSTANT MOVEMENT - bypass deltaTime issues
                const speed = SPACE_BULLET_SPEED / 60; // Assume 60fps for consistent movement
                this.position.add(this.velocity.clone().normalize().multiplyScalar(speed));
                this.life -= 1/60; // Decrease life by 1/60 second per frame
                
                // Debug torpedo lifetime
                if (Math.random() < 0.02) {
                    console.log(`üü° Torpedo life remaining: ${this.life.toFixed(2)} seconds`);
                }
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // Orient torpedo to face movement direction
                    const direction = this.velocity.clone().normalize();
                    this.mesh.lookAt(this.position.clone().add(direction));
                    
                    // Add subtle rotation for more dynamic look
                    this.mesh.rotation.z += 0.1;
                }
                
                // Check collision with ground (y=0 level)
                if (this.position.y <= 0.1) {
                    console.log(`üí• TORPEDO HIT GROUND! At position (${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)})`);
                    // Create ground explosion effect
                    this.createGroundExplosion();
                    this.destroy();
                    return true; // Mark for removal
                }
                
                // Check collision with asteroids - Enhanced hit detection
                for (const asteroid of asteroids) {
                    const distance = this.position.distanceTo(asteroid.position);
                    const hitRadius = asteroid.size === 'large' ? 2.5 : asteroid.size === 'medium' ? 1.5 : 0.9; // Increased hit radius
                    
                    // Debug collision detection every 30 frames for closest asteroid
                    if (Math.random() < 0.01) {
                        console.log(`üéØ Torpedo at (${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) checking ${asteroid.size} asteroid at (${asteroid.position.x.toFixed(1)}, ${asteroid.position.y.toFixed(1)}, ${asteroid.position.z.toFixed(1)}) - distance: ${distance.toFixed(2)}, hit radius: ${hitRadius}`);
                    }
                    
                    if (distance < hitRadius) {
                        console.log(`üí• TORPEDO HIT! ${asteroid.size} asteroid at distance ${distance.toFixed(2)}, radius ${hitRadius}`);
                        asteroid.takeDamage();
                        this.explode();
                        return true; // Mark for removal
                    }
                }
                
                // Remove if life expired or out of bounds
                if (this.life <= 0 || Math.abs(this.position.x) > SKY_RADIUS * 2) {
                    console.log(`üóëÔ∏è Torpedo expired - life: ${this.life.toFixed(2)}, bounds check: ${Math.abs(this.position.x) > SKY_RADIUS * 2}`);
                    this.destroy();
                    return true; // Mark for removal
                }
                
                return false;
            }
            
            explode() {
                // Create small explosion effect
                createSpaceExplosion(this.position.clone());
                this.destroy();
            }
            
            createGroundExplosion() {
                // Create a ground-appropriate explosion with style matching the experience
                const explosionPos = this.position.clone();
                explosionPos.y = 0.05; // Slightly above ground
                
                console.log('üî• Creating ground explosion at:', explosionPos.toArray().map(v => v.toFixed(2)));
                
                // Create expanding ring of cyan particles (matching force beam style)
                const particleCount = 12; // Moderate count for performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = getParticleFromPool();
                    if (particle) {
                        const angle = (i / particleCount) * Math.PI * 2;
                        const radius = 0.8; // Initial expansion radius
                        
                        particle.position.copy(explosionPos);
                        particle.velocity.set(
                            Math.cos(angle) * radius,
                            Math.random() * 0.6 + 0.2, // Upward scatter with variation
                            Math.sin(angle) * radius
                        );
                        particle.life = 1.2; // Longer life for visible effect
                        particle.maxLife = 1.2;
                        particle.color = new THREE.Color(0x00ffff); // Cyan to match theme
                        particles.push(particle);
                    }
                }
                
                // Create central flash/impact effect
                const flashGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0x0088ff
                });
                const flashMesh = new THREE.Mesh(flashGeometry, flashMaterial);
                flashMesh.position.copy(explosionPos);
                scene.add(flashMesh);
                
                // Cleanup function
                const cleanupFlash = () => {
                    if (flashMesh.parent) { // Only cleanup if still in scene
                        scene.remove(flashMesh);
                        flashGeometry.dispose();
                        flashMaterial.dispose();
                        console.log('üßπ Ground explosion flash cleaned up');
                    }
                };
                
                // Timeout-based cleanup as failsafe (always runs)
                setTimeout(cleanupFlash, 600); // 0.6 seconds max
                
                // Animate flash decay (if this fails, timeout will still cleanup)
                let flashLife = 0.5;
                let animationId = null;
                const animateFlash = () => {
                    flashLife -= 0.016; // ~60fps decay
                    if (flashLife > 0 && flashMesh.parent) { // Check if still in scene
                        const scale = flashLife * 2; // Expand as it fades
                        flashMesh.scale.setScalar(scale);
                        flashMaterial.opacity = Math.max(0, flashLife * 1.6);
                        animationId = requestAnimationFrame(animateFlash);
                    } else {
                        if (animationId) cancelAnimationFrame(animationId);
                        cleanupFlash();
                    }
                };
                animateFlash();
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        class ShootingStar {
            constructor() {
                // Start from random edge of space layer area
                const side = Math.floor(Math.random() * 4);
                const spaceSize = SPACE_RADIUS * 1.5;
                
                // Position in space layer (60m+ above user)
                switch(side) {
                    case 0: // Top
                        this.position = new THREE.Vector3(
                            (Math.random() - 0.5) * spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            spaceSize
                        );
                        break;
                    case 1: // Right
                        this.position = new THREE.Vector3(
                            spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            (Math.random() - 0.5) * spaceSize
                        );
                        break;
                    case 2: // Bottom
                        this.position = new THREE.Vector3(
                            (Math.random() - 0.5) * spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            -spaceSize
                        );
                        break;
                    case 3: // Left
                        this.position = new THREE.Vector3(
                            -spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            (Math.random() - 0.5) * spaceSize
                        );
                        break;
                }
                
                // Create velocity toward opposite side within space layer
                const targetX = (Math.random() - 0.5) * spaceSize;
                const targetY = SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT);
                const targetZ = (Math.random() - 0.5) * spaceSize;
                
                const direction = new THREE.Vector3(targetX, targetY, targetZ).sub(this.position);
                direction.normalize();
                this.velocity = direction.multiplyScalar(SHOOTING_STAR_SPEED);
                
                this.life = 4.0; // Seconds
                this.brightness = 0.8 + Math.random() * 0.2;
                this.mesh = null;
                this.trailParticles = [];
                
                this.createMesh();
            }
            
            createMesh() {
                const starGeometry = new THREE.SphereGeometry(0.15, 4, 4); // Reduced complexity for background stars
                const starMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffaa,
                    transparent: true,
                    opacity: this.brightness
                });
                this.mesh = new THREE.Mesh(starGeometry, starMaterial);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime, elapsedTime) {
                // Update position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.life -= deltaTime;
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // Fade out as life decreases
                    const lifeFactor = Math.max(0, this.life / 4.0);
                    this.mesh.material.opacity = this.brightness * lifeFactor;
                }
                
                // Create trail particles
                this.createTrailParticle(elapsedTime);
                
                // Update trail particles
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    const particle = this.trailParticles[i];
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        if (particle.mesh) {
                            scene.remove(particle.mesh);
                        }
                        this.trailParticles.splice(i, 1);
                    } else {
                        // Fade trail particle
                        if (particle.mesh) {
                            particle.mesh.material.opacity = particle.life / 1.0;
                        }
                    }
                }
                
                // Remove if life expired
                return this.life <= 0;
            }
            
            createTrailParticle(elapsedTime) {
                // Create trail particle every few frames
                if (Math.random() < 0.3) {
                    const trailGeometry = new THREE.SphereGeometry(0.05, 3, 3); // Minimal for trail particles
                    const trailMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                    trailMesh.position.copy(this.position);
                    scene.add(trailMesh);
                    
                    this.trailParticles.push({
                        mesh: trailMesh,
                        life: 1.0 // Trail particles live for 1 second
                    });
                }
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
                
                // Clean up trail particles
                for (const particle of this.trailParticles) {
                    if (particle.mesh) {
                        scene.remove(particle.mesh);
                    }
                }
                this.trailParticles = [];
            }
        }
        
        
        
        // --- Predator Class ---
        class Predator {
            constructor(position, color) {
                this.position = position || new THREE.Vector3();
                this.velocity = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.velocity.setLength(Math.random() * 0.3 + 0.2);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.05;
                this.maxSpeed = 0.105; // Reduced by 30% to match boid speed reduction
                this.huntRadius = 4.0;
                this.color = color || new THREE.Color(0xff0000);
                this.isGrabbed = false;
            }
            
            update() {
                if (this.isGrabbed) return;
                
                this.position.add(this.velocity);
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.acceleration.multiplyScalar(0);
            }
            
            applyForce(force) {
                if (!this.isGrabbed) {
                    this.acceleration.add(force);
                }
            }
            
            hunt(boids) {
                if (!boids || !Array.isArray(boids)) {
                    return;
                }
                
                let closest = null;
                let closestDist = Infinity;
                
                for (let boid of boids) {
                    if (!boid || boid.isGrabbed) continue;
                    let d = this.position.distanceTo(boid.position);
                    if (d < this.huntRadius && d < closestDist) {
                        closest = boid;
                        closestDist = d;
                    }
                }
                
                if (closest) {
                    let huntForce = this.seek(closest.position);
                    huntForce.multiplyScalar(2.0); // Strong hunting drive
                    this.applyForce(huntForce);
                }
            }
            
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.normalize();
                desired.multiplyScalar(this.maxSpeed);
                let steer = desired.sub(this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            
            checkBounds() {
                if (this.isGrabbed) return;
                
                const halfRadius = ATMOSPHERE_RADIUS / 2;
                const turnFactor = 0.7;
                
                // Constrain to atmosphere layer (0-30m height)
                if (this.position.x > halfRadius) this.velocity.x -= turnFactor;
                if (this.position.x < -halfRadius) this.velocity.x += turnFactor;
                if (this.position.y > ATMOSPHERE_MAX_HEIGHT) this.velocity.y -= turnFactor;
                if (this.position.y < ATMOSPHERE_MIN_HEIGHT + 0.5) this.velocity.y += turnFactor;
                if (this.position.z > halfRadius) this.velocity.z -= turnFactor;
                if (this.position.z < -halfRadius) this.velocity.z += turnFactor;
            }
        }
        
        // --- Boid Class ---
        class Boid {
            constructor(position) {
                this.position = position || new THREE.Vector3(
                    Math.random() * boundSize - boundSize / 2,
                    Math.random() * (boundSize / 2) + 1,
                    Math.random() * boundSize - boundSize / 2
                );
                this.velocity = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                );
                this.velocity.setLength(Math.random() * 0.5 + 0.5);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.03;
                this.maxSpeed = 0.07; // Reduced by 30% for better performance
                this.isGrabbed = false;
                this.isBeingTossed = false;
                this.tossStartTime = 0;
                this.tossVelocity = new THREE.Vector3();
                this.originalVelocity = new THREE.Vector3();
                // Add smoothed rotation direction to prevent spinning
                this.smoothedDirection = this.velocity.clone().normalize();
                // Add punch effect tracking
                this.punchAffected = false;
                this.punchEffectEndTime = 0;
                this.punchGlowColor = new THREE.Color(0xff6600);
                this.trailPositions = [];
                
                // Enhanced visual properties
                this.pulsePhase = Math.random() * Math.PI * 2; // Random start phase
                this.pulseSpeed = 0.8 + Math.random() * 0.4; // 0.8-1.2 speed variation
                this.baseColor = new THREE.Color(0x00ffaa); // Base teal
                this.currentColor = new THREE.Color(0x00ffaa);
                this.colorChangeTime = 0;
                this.lastStateChange = 0;
            }
            
            update() {
                if (this.isGrabbed) return;
                
                if (this.isBeingTossed) {
                    this.handleTossedMovement();
                } else {
                    this.position.add(this.velocity);
                    this.velocity.add(this.acceleration);
                    this.velocity.clampLength(0, this.maxSpeed);
                    this.acceleration.multiplyScalar(0);
                }
                
                // Smooth rotation direction to prevent spinning
                if (this.velocity.length() > 0.01) {
                    const currentDirection = this.velocity.clone().normalize();
                    this.smoothedDirection.lerp(currentDirection, 0.1); // Smooth interpolation
                    this.smoothedDirection.normalize();
                }
                
                // Update visual effects
                this.updateVisualEffects();
                
                // Update punch effect trail
                if (this.punchAffected) {
                    // Add current position to trail
                    this.trailPositions.push(this.position.clone());
                    // Keep trail length reasonable
                    if (this.trailPositions.length > 10) {
                        this.trailPositions.shift();
                    }
                    
                    // Check if effect should end
                    if (clock.getElapsedTime() > this.punchEffectEndTime) {
                        this.punchAffected = false;
                        this.trailPositions = [];
                    }
                }
            }
            
            handleTossedMovement() {
                const tossTime = clock.getElapsedTime() - this.tossStartTime;
                const transitionTime = 1.0; // Time to transition from toss to flight
                
                if (tossTime < transitionTime) {
                    // Newtonian trajectory with gravity
                    const gravity = new THREE.Vector3(0, -9.8, 0);
                    this.position.add(this.tossVelocity.clone().multiplyScalar(0.016)); // ~60fps
                    this.tossVelocity.add(gravity.clone().multiplyScalar(0.016));
                    
                    // Gradually blend back to boid behavior
                    const blendFactor = tossTime / transitionTime;
                    this.velocity.lerpVectors(this.tossVelocity, this.originalVelocity, blendFactor);
                } else {
                    // Return to normal boid behavior
                    this.isBeingTossed = false;
                    this.velocity.copy(this.originalVelocity);
                }
            }
            
            applyForce(force) {
                if (!this.isGrabbed && !this.isBeingTossed) {
                    this.acceleration.add(force);
                }
            }
            
            // --- MODIFIED: flock method now includes obstacle avoidance and predator fleeing ---
            flock(boids, hands, obstacles, predators) {
                let fleeForce = this.fleeFromHands(hands);
                let predatorFleeForce = this.fleeFromPredators(predators);
                // Obstacle avoidance removed for performance
                let separation = this.separate(boids);
                let alignment = this.align(boids);
                let cohesion = this.cohere(boids);

                // Weight forces
                fleeForce.multiplyScalar(5.0);
                predatorFleeForce.multiplyScalar(8.0); // Very strong predator avoidance
                separation.multiplyScalar(1.5);
                alignment.multiplyScalar(1.0);
                cohesion.multiplyScalar(1.0);
                
                this.applyForce(fleeForce);
                this.applyForce(predatorFleeForce);
                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }
            
            // Obstacle avoidance removed for performance

            fleeFromHands(hands) {
                let fleeForce = new THREE.Vector3();
                for (const hand of hands) {
                    if (hand.userData.isReady && !hand.userData.isGrabbingBoid) {
                        fleeForce.add(this.flee(hand.userData.tipPositions.MIDDLE));
                    }
                }
                return fleeForce;
            }
            
            fleeFromPredators(predators) {
                let fleeForce = new THREE.Vector3();
                if (!predators || !Array.isArray(predators)) {
                    return fleeForce;
                }
                for (const predator of predators) {
                    if (!predator || predator.isGrabbed) continue;
                    let d = this.position.distanceTo(predator.position);
                    if (d < 3.0) { // Flee radius from predators
                        let flee = this.flee(predator.position);
                        flee.multiplyScalar(3.0); // Strong flee response
                        fleeForce.add(flee);
                    }
                }
                return fleeForce;
            }
            separate(boids) {
                let desiredSeparation = 0.8;
                let steer = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < desiredSeparation)) {
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                }
                
                if (count > 0) {
                    steer.divideScalar(count);
                    steer.normalize();
                    steer.multiplyScalar(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }
            align(boids) {
                let neighborDist = 2.5;
                let sum = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divideScalar(count);
                    sum.normalize();
                    sum.multiplyScalar(this.maxSpeed);
                    let steer = sum.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                    return steer;
                } else {
                    return new THREE.Vector3();
                }
            }
            cohere(boids) {
                let neighborDist = 3;
                let sum = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.add(other.position);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divideScalar(count);
                    return this.seek(sum);
                } else {
                    return new THREE.Vector3();
                }
            }
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.normalize();
                desired.multiplyScalar(this.maxSpeed);
                let steer = desired.sub(this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            flee(target) {
                const fleeRadius = 1.5;
                let steer = new THREE.Vector3();
                let d = this.position.distanceTo(target);
                if (d < fleeRadius) {
                    let desired = new THREE.Vector3().subVectors(this.position, target);
                    desired.normalize();
                    desired.multiplyScalar(this.maxSpeed);
                    steer = desired.sub(this.velocity);
                    steer.clampLength(0, this.maxForce * 2.0);
                }
                return steer;
            }
            checkBounds() {
                if (this.isGrabbed) return;
                
                const halfBound = boundSize / 2;
                const turnFactor = 0.5;
                
                if (this.position.x > halfBound) this.velocity.x -= turnFactor;
                if (this.position.x < -halfBound) this.velocity.x += turnFactor;
                if (this.position.y > 8) this.velocity.y -= turnFactor; // Max Y=8, well below asteroids at Y=11.8
                if (this.position.y < 0.1) this.velocity.y += turnFactor;
                if (this.position.z > halfBound) this.velocity.z -= turnFactor;
                if (this.position.z < -halfBound) this.velocity.z += turnFactor;
            }
            
            updateVisualEffects() {
                const currentTime = clock.getElapsedTime();
                
                // Update pulse phase
                this.pulsePhase += this.pulseSpeed * 0.02; // Slow pulsing
                
                // Calculate pulse intensity (0.7-1.0 range for subtle effect)
                const pulseIntensity = 0.7 + Math.sin(this.pulsePhase) * 0.3;
                
                // Base color transitions based on boid state
                let targetColor = this.baseColor;
                
                if (this.punchAffected) {
                    // Orange glow when affected by punch
                    targetColor = this.punchGlowColor;
                } else if (this.isBeingTossed) {
                    // Bright cyan when being tossed
                    targetColor = new THREE.Color(0x00aaff);
                } else {
                    // Speed-based color variation (faster = more cyan, slower = more green)
                    const speedFactor = Math.min(this.velocity.length() / this.maxSpeed, 1.0);
                    const r = 0.0;
                    const g = 1.0;
                    const b = 0.4 + speedFactor * 0.27; // 0.4-0.67 range
                    targetColor = new THREE.Color(r, g, b);
                }
                
                // Smooth color transitions
                this.currentColor.lerp(targetColor, 0.05);
                
                // Apply pulse intensity to current color
                this.currentColor.r *= pulseIntensity;
                this.currentColor.g *= pulseIntensity;
                this.currentColor.b *= pulseIntensity;
            }
        }

        function addFallbackControls() {
            const fallbackDiv = document.createElement('div');
            fallbackDiv.style.position = 'absolute';
            fallbackDiv.style.bottom = '20px';
            fallbackDiv.style.left = '50%';
            fallbackDiv.style.transform = 'translateX(-50%)';
            fallbackDiv.style.padding = '12px 24px';
            fallbackDiv.style.backgroundColor = 'rgba(255, 100, 100, 0.8)';
            fallbackDiv.style.color = 'white';
            fallbackDiv.style.borderRadius = '8px';
            fallbackDiv.style.fontSize = '14px';
            fallbackDiv.textContent = 'VR not supported - use mouse to look around';
            document.body.appendChild(fallbackDiv);
            
            // Add basic mouse controls for fallback
            let mouseX = 0, mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                camera.position.x = mouseX * 5;
                camera.position.y = mouseY * 3 + 1.6;
                camera.lookAt(0, 2, 0);
            });
        }

        function createVectorGridGround() {
            // Create a simple, clean grid to avoid aliasing artifacts
            const gridSize = 80; // Smaller for better performance
            const divisions = 40; // Fewer divisions to reduce aliasing
            const gridHelper = new THREE.GridHelper(gridSize, divisions);
            
            // Simple cyan color without transparency to avoid artifacts
            gridHelper.material.color.setHex(0x004444);
            gridHelper.material.opacity = 0.5;
            gridHelper.material.transparent = true;
            gridHelper.position.y = 0; // Exactly at ground level
            
            scene.add(gridHelper);
            
            console.log('üåê Created simplified grid ground');
        }

        // Tron trees function removed for performance
        
        // Fountain system removed - too problematic
        
        function createGroundVoxels() {
            // Create geometry and material for ground voxels
            const voxelSize = 0.12;
            const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
            const voxelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x6666ff, 
                transparent: true,
                opacity: 0.8,
                emissive: 0x2222bb
            });
            
            // Create instanced mesh for ground voxels
            groundVoxelsMesh = new THREE.InstancedMesh(voxelGeometry, voxelMaterial, groundVoxelCount);
            groundVoxelsMesh.name = 'ground_voxels';
            groundVoxelsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(groundVoxelsMesh);
            
            // Create and position ground voxels
            const dummy = new THREE.Object3D();
            for (let i = 0; i < groundVoxelCount; i++) {
                const voxel = {
                    position: new THREE.Vector3(
                        (Math.random() - 0.5) * boundSize * 0.8, // Within bounds
                        0.1, // Slightly above ground
                        (Math.random() - 0.5) * boundSize * 0.8
                    ),
                    active: true,
                    glowPhase: Math.random() * Math.PI * 2, // Random glow phase
                    originalY: 0.1
                };
                
                groundVoxels.push(voxel);
                
                // Set initial matrix
                dummy.position.copy(voxel.position);
                dummy.updateMatrix();
                groundVoxelsMesh.setMatrixAt(i, dummy.matrix);
            }
            
            groundVoxelsMesh.instanceMatrix.needsUpdate = true;
            console.log(`‚ú® Created ${groundVoxelCount} ground voxels for testing`);
        }
        
        function createBoidsSystem() {
            // Create geometry and material for boids
            const boidSize = 0.15; // Larger for better VR visibility
            const boidGeometry = new THREE.BoxGeometry(boidSize, boidSize, boidSize);
            const boidMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa, 
                transparent: false, // Disable for mobile perf
                opacity: 1.0
            }); // Switched to Basic for Quest 3 perf, removed emissive as Basic doesn't support it
            
            // Create instanced mesh for boids with enhanced visuals
            const boidsMesh = new THREE.InstancedMesh(boidGeometry, boidMaterial, initialBoidCount);
            boidsMesh.name = 'alive_voxels';
            boidsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            
            // Add instance color attribute for per-boid coloring
            const instanceColors = new Float32Array(initialBoidCount * 3);
            for (let i = 0; i < initialBoidCount; i++) {
                // Initialize with base teal color
                instanceColors[i * 3] = 0.0;      // R
                instanceColors[i * 3 + 1] = 1.0;  // G 
                instanceColors[i * 3 + 2] = 0.67; // B (0x00ffaa)
            }
            boidsMesh.instanceColor = new THREE.InstancedBufferAttribute(instanceColors, 3);
            boidsMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
            
            scene.add(boidsMesh);
            
            // Initialize all boids with default matrices
            const dummy = new THREE.Object3D();
            for (let i = 0; i < initialBoidCount; i++) {
                dummy.position.set(0, -1000, 0); // Start hidden
                dummy.updateMatrix();
                boidsMesh.setMatrixAt(i, dummy.matrix);
            }
            boidsMesh.instanceMatrix.needsUpdate = true;
            
            // Create held voxel meshes for both hands
            heldVoxelMesh1 = new THREE.Mesh(boidGeometry, boidMaterial.clone());
            heldVoxelMesh1.visible = false;
            heldVoxelMesh1.position.set(0, -1000, 0);
            scene.add(heldVoxelMesh1);
            
            heldVoxelMesh2 = new THREE.Mesh(boidGeometry, boidMaterial.clone());
            heldVoxelMesh2.visible = false;
            heldVoxelMesh2.position.set(0, -1000, 0);
            scene.add(heldVoxelMesh2);
            
            console.log(`üê¶ Created boids system with ${initialBoidCount} boids`);
        }
        
        // Game of Life pattern functions removed for performance
        
        // Game of Life functions removed for performance


        function createSpaceBattle() {
            // Clear existing space objects
            asteroids = [];
            spaceShips = [];
            stars = [];
            
            // Create initial asteroids
            for (let i = 0; i < ASTEROID_COUNT; i++) {
                const asteroid = new Asteroid();
                asteroids.push(asteroid);
            }
            
            // Create initial spaceships
            for (let i = 0; i < SPACESHIP_COUNT; i++) {
                const spaceship = new SpaceShip();
                spaceShips.push(spaceship);
            }
            
            // Create starfield
            for (let i = 0; i < STAR_COUNT; i++) {
                const star = new Star();
                stars.push(star);
            }
            
            console.log(`üöÄ Created ${ASTEROID_COUNT} asteroids, ${SPACESHIP_COUNT} spaceships, and ${STAR_COUNT} stars for Space Battle`);
            console.log(`‚≠ê Stars positioned at heights ${SPACE_MIN_HEIGHT}m - ${SPACE_MAX_HEIGHT}m above user`);
        }


        
        
        function createSpaceExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 6; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = getParticleFromPool();
                    if (particle) {
                        particle.position.copy(position);
                        particle.velocity.set(
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3
                        );
                        particle.life = 0.8;
                        particle.maxLife = 0.8;
                        particle.color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.1, 1, 0.8);
                        particles.push(particle);
                    }
                }
                
                console.log('‚ú® Space explosion!');
            } catch (error) {
                console.warn('Space explosion error:', error);
            }
        }
        
        function updateSkyBattle(deltaTime, elapsedTime) {
            try {
                // Performance optimization: update different elements at different intervals
                const shouldUpdateStars = frameCount % SPACE_UPDATE_INTERVAL === 0;
                const shouldUpdateOrbital = frameCount % ORBITAL_UPDATE_INTERVAL === 0;
                const shouldUpdateParticles = frameCount % PARTICLE_UPDATE_INTERVAL === 0;
                
                // Update stars at reduced frequency (space layer)
                if (shouldUpdateStars) {
                    for (const star of stars) {
                        star.update(elapsedTime);
                    }
                }
                
                // Spawn shooting stars randomly but check less frequently
                if (shouldUpdateParticles && Math.random() < SHOOTING_STAR_SPAWN_RATE * deltaTime * PARTICLE_UPDATE_INTERVAL) {
                    shootingStars.push(new ShootingStar());
                    console.log('‚ú® Shooting star appeared!');
                }
                
                // Update shooting stars
                for (let i = shootingStars.length - 1; i >= 0; i--) {
                    const shootingStar = shootingStars[i];
                    if (shootingStar.update(deltaTime, elapsedTime)) {
                        shootingStar.destroy();
                        shootingStars.splice(i, 1);
                    }
                }
                
                // Update asteroids every frame for smooth movement
                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    asteroid.update(deltaTime);
                    
                    // Remove destroyed asteroids
                    if (asteroid.health <= 0) {
                        asteroids.splice(i, 1);
                    }
                }
                
                // Maintain minimum asteroid count (only check occasionally)
                if (shouldUpdateOrbital && asteroids.length < ASTEROID_COUNT / 2) {
                    while (asteroids.length < ASTEROID_COUNT / 2) {
                        asteroids.push(new Asteroid());
                    }
                }
                
                // Update space ships every frame for smooth movement
                for (const ship of spaceShips) {
                    ship.update(deltaTime, elapsedTime);
                }
                
                // Update space bullets (keep at normal frequency for responsiveness)
                for (let i = spaceBullets.length - 1; i >= 0; i--) {
                    const bullet = spaceBullets[i];
                    if (bullet.update(deltaTime)) {
                        spaceBullets.splice(i, 1);
                    }
                }
                
            } catch (error) {
                console.warn('Sky battle update error:', error);
            }
        }
        
        
        
        function handleTeleportation(hand, elapsedTime) {
            try {
                // Debug teleportation prerequisites
                if (frameCount % 120 === 0) {
                    console.log(`üöÄ TELEPORT CHECK: isReady=${hand.userData.isReady}, isPointing=${hand.userData.isPointing}`);
                }
                
                if (!hand.userData.isReady || !hand.userData.isPointing) {
                    resetTeleportState();
                    return;
                }
                
                // Perform raycast from index finger
                const rayOrigin = hand.userData.tipPositions.INDEX.clone();
                const rayDirection = new THREE.Vector3()
                    .subVectors(hand.userData.tipPositions.INDEX, hand.userData.wristPosition)
                    .normalize();
                
                teleportRaycaster.set(rayOrigin, rayDirection);
                
                // Raycast against ground plane (y = 0)
                const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectPoint = new THREE.Vector3();
                teleportRaycaster.ray.intersectPlane(groundPlane, intersectPoint);
                
                if (intersectPoint) {
                    const distance = rayOrigin.distanceTo(intersectPoint);
                    
                    // Check if within teleport range
                    if (distance <= TELEPORT_MAX_DISTANCE) {
                        // Show ray line
                        if (teleportRayLine) {
                            const rayGeometry = teleportRayLine.geometry;
                            const positions = rayGeometry.attributes.position.array;
                            positions[0] = rayOrigin.x;
                            positions[1] = rayOrigin.y;
                            positions[2] = rayOrigin.z;
                            positions[3] = intersectPoint.x;
                            positions[4] = intersectPoint.y;
                            positions[5] = intersectPoint.z;
                            rayGeometry.attributes.position.needsUpdate = true;
                            teleportRayLine.visible = true;
                        }
                        
                        // Show reticle
                        teleportReticle.position.copy(intersectPoint);
                        teleportReticle.visible = true;
                        
                        // Simple timer-based teleportation
                        if (!isPointingForTeleport) {
                            teleportHoldStartTime = elapsedTime;
                            teleportTargetPosition = intersectPoint.clone();
                            isPointingForTeleport = true;
                            console.log('üìç Teleport started');
                        } else {
                            const holdTime = elapsedTime - teleportHoldStartTime;
                            const progress = Math.min(holdTime / TELEPORT_HOLD_TIME, 1.0);
                            
                            // Show progress
                            teleportIndicator.position.copy(intersectPoint);
                            teleportIndicator.visible = true;
                            teleportIndicator.scale.set(progress * 2, 1, progress * 2);
                            
                            // Teleport when complete
                            if (progress >= 1.0) {
                                console.log('üöÄ Teleporting!');
                                performTeleport(intersectPoint);
                                resetTeleportState();
                            }
                        }
                    } else {
                        resetTeleportState();
                    }
                } else {
                    resetTeleportState();
                }
                
            } catch (error) {
                console.warn('Teleportation error:', error);
                resetTeleportState();
            }
        }
        
        function detectPointingGesture(hand) {
            // Check if index finger is extended while other fingers are curled
            if (!hand.userData.tipPositions.INDEX || !hand.userData.tipPositions.MIDDLE) {
                return false;
            }
            
            const palmPosition = hand.userData.tipPositions.MIDDLE; // Approximate palm
            const indexTip = hand.userData.tipPositions.INDEX;
            
            // Simple pointing detection: index finger extended away from palm
            const pointingDistance = indexTip.distanceTo(palmPosition);
            return pointingDistance > 0.08; // Threshold for extended finger
        }
        
        function getPointingDirection(hand) {
            // Calculate pointing direction from palm toward index fingertip
            const palmPosition = hand.userData.tipPositions.MIDDLE; // Approximate palm
            const indexTip = hand.userData.tipPositions.INDEX;
            
            const direction = new THREE.Vector3().subVectors(indexTip, palmPosition);
            direction.normalize();
            
            return direction;
        }
        
        function performTeleport(targetPosition) {
            try {
                console.log('üöÄ Teleporting to:', targetPosition);
                
                if (renderer.xr.isPresenting) {
                    // VR Mode: Use XR reference space
                    const xrReferenceSpace = renderer.xr.getReferenceSpace();
                    const session = renderer.xr.getSession();
                    
                    if (session && session.requestReferenceSpace) {
                        // Calculate offset to teleport position
                        // Keep the user at ground level + comfortable VR height
                        const teleportY = 1.6; // Standard VR height above ground
                        // Get current reference space position
                        const currentPose = renderer.xr.getFrame().getViewerPose(xrReferenceSpace);
                        if (currentPose) {
                            const currentPosition = currentPose.transform.position;
                            const offsetX = targetPosition.x - currentPosition.x;
                            const offsetY = teleportY - currentPosition.y; // Adjust to ground level + height
                            const offsetZ = targetPosition.z - currentPosition.z;
                            
                            const transform = new XRRigidTransform(
                                {x: offsetX, y: offsetY, z: offsetZ},
                                {x: 0, y: 0, z: 0, w: 1}
                            );
                            
                            const offsetReferenceSpace = xrReferenceSpace.getOffsetReferenceSpace(transform);
                            renderer.xr.setReferenceSpace(offsetReferenceSpace);
                            console.log('‚úÖ XR Teleport completed with offset:', {offsetX, offsetY, offsetZ});
                        } else {
                            console.warn('‚ö†Ô∏è Could not get current viewer pose for teleport');
                        }
                        
                        console.log('‚úÖ XR Teleport completed to:', targetPosition.toArray().map(v => v.toFixed(2)));
                    } else {
                        // Fallback: Move the VR camera group
                        const vrCamera = renderer.xr.getCamera();
                        if (vrCamera.parent) {
                            vrCamera.parent.position.set(
                                -targetPosition.x,
                                1.6 - targetPosition.y, // Keep above ground
                                -targetPosition.z
                            );
                            console.log('‚úÖ VR Camera teleport completed');
                        }
                    }
                } else {
                    // Desktop mode - move scene
                    scene.position.set(
                        -targetPosition.x,
                        -targetPosition.y + 1.6,
                        -targetPosition.z
                    );
                    console.log('‚úÖ Desktop teleport completed');
                }
                
                // Create teleport effect
                createTeleportEffect(targetPosition);
                
            } catch (error) {
                console.warn('Teleport execution error:', error);
            }
        }
        
        function createTeleportEffect(position) {
            // Create particle effect at teleport location
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const particle = getParticleFromPool();
                if (particle) {
                    particle.position.copy(position).add(new THREE.Vector3(0, 0.1, 0));
                    particle.velocity.set(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    );
                    particle.life = 1.5;
                    particle.maxLife = 1.5;
                    particle.color = new THREE.Color().setHSL(0.5, 1, 0.8); // Cyan teleport effect
                    particles.push(particle);
                }
            }
        }
        
        function resetTeleportState() {
            isPointingForTeleport = false;
            teleportTargetPosition = null;
            teleportHoldStartTime = 0;
            
            if (teleportReticle) teleportReticle.visible = false;
            if (teleportIndicator) teleportIndicator.visible = false;
            if (teleportRayLine) teleportRayLine.visible = false;
        }
        
        // Duplicate performTeleport function removed - using the scene-based implementation above
        
        function detectFist(hand) {
            try {
                if (!hand.userData.isReady) return false;
                
                // Ensure we have valid tip positions
                if (!hand.userData.tipPositions.INDEX || !hand.userData.tipPositions.MIDDLE || !hand.userData.tipPositions.THUMB) {
                    return false;
                }
                
                // Get joint positions for better fist detection
                const joints = hand.joints;
                if (!joints || !joints['wrist']) return false;
                
                const wrist = joints['wrist'].position;
                const thumbTip = hand.userData.tipPositions.THUMB;
                const indexTip = hand.userData.tipPositions.INDEX;
                const middleTip = hand.userData.tipPositions.MIDDLE;
                
                // Check if fingertips are close to the wrist (curled fingers)
                const thumbToWrist = thumbTip.distanceTo(wrist);
                const indexToWrist = indexTip.distanceTo(wrist);
                const middleToWrist = middleTip.distanceTo(wrist);
                
                // Store finger distances for debug overlay
                if (hand.userData.debugHandIndex !== undefined) {
                    const handInfo = hand.userData.debugHandIndex === 0 ? debugInfo.leftHand : debugInfo.rightHand;
                    handInfo.thumbDist = thumbToWrist;
                    handInfo.indexDist = indexToWrist;
                    handInfo.middleDist = middleToWrist;
                }
                
                // Debug logging
                if (frameCount % 30 === 0) { // More frequent logging
                    console.log('üëä Fist detection:', {
                        thumbToWrist: thumbToWrist.toFixed(3),
                        indexToWrist: indexToWrist.toFixed(3),
                        middleToWrist: middleToWrist.toFixed(3),
                        velocity: hand.userData.velocity ? hand.userData.velocity.length().toFixed(3) : '0',
                        isFist: (thumbToWrist < 0.18 && indexToWrist < 0.18 && middleToWrist < 0.18)
                    });
                }
                
                // If fingertips are close to wrist, it's a fist (very relaxed thresholds)
                return thumbToWrist < 0.18 && indexToWrist < 0.18 && middleToWrist < 0.18;
            } catch (error) {
                console.warn('Fist detection error:', error);
                return false;
            }
        }
        
        function punchBlast(hand) {
            try {
                if (!hand.userData.handCenter || !hand.userData.velocity) {
                    console.warn('‚ö†Ô∏è Punch blast failed - missing handCenter or velocity');
                    return;
                }
                
                const blastCenter = hand.userData.handCenter.clone();
                const blastDirection = hand.userData.velocity.clone().normalize();
                
                console.log('üí• PUNCH BLAST TRIGGERED!');
                console.log('  Center:', blastCenter.toArray().map(v => v.toFixed(2)));
                console.log('  Direction:', blastDirection.toArray().map(v => v.toFixed(2)));
                
                // Create punch blast visual effect
                createPunchBlastEffect(blastCenter, blastDirection);
                
                // Play punch sound effect
                playPunchSound();
                
                // Affect boids within blast radius
                let affectedBoidsCount = 0;
                boids.forEach((boid, index) => {
                    if (boid && boid.position) {
                        const distance = boid.position.distanceTo(blastCenter);
                        if (distance < PUNCH_FORCE_RADIUS) {
                            // Push boids away instead of removing them
                            const pushDirection = new THREE.Vector3().subVectors(boid.position, blastCenter).normalize();
                            const pushForce = Math.max(0.1, (PUNCH_FORCE_RADIUS - distance) / PUNCH_FORCE_RADIUS);
                            boid.velocity.add(pushDirection.multiplyScalar(pushForce * 2.0));
                            
                            // Apply punch effect with lingering glow and trail
                            boid.punchAffected = true;
                            boid.punchEffectEndTime = clock.getElapsedTime() + 30; // 30 second effect
                            boid.punchGlowColor.setHSL(0.1, 1.0, 0.6); // Orange glow
                            boid.trailPositions = [boid.position.clone()];
                            
                            // Create particle explosion at boid position
                            createParticleExplosion(boid.position.clone());
                            affectedBoidsCount++;
                        }
                    }
                });
                
                // Also affect predators
                predators.forEach(predator => {
                    if (predator && predator.position) {
                        const distance = predator.position.distanceTo(blastCenter);
                        if (distance < PUNCH_FORCE_RADIUS) {
                            // Push predators away
                            const pushDirection = new THREE.Vector3().subVectors(predator.position, blastCenter).normalize();
                            const pushForce = Math.max(0.1, (PUNCH_FORCE_RADIUS - distance) / PUNCH_FORCE_RADIUS);
                            predator.velocity.add(pushDirection.multiplyScalar(pushForce * 1.5));
                        }
                    }
                });
                
                console.log(`üí• Punch affected ${affectedBoidsCount} boids!`);
                
            } catch (error) {
                console.warn('Punch blast error:', error);
            }
        }
        
        function createPunchBlastEffect(center, direction) {
            try {
                // Create expanding bubble effect
                const bubbleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bubbleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xff4400
                });
                const bubbleMesh = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubbleMesh.position.copy(center);
                scene.add(bubbleMesh);
                
                // Animate bubble expansion
                const startTime = clock.getElapsedTime();
                const animateBlast = () => {
                    const elapsed = clock.getElapsedTime() - startTime;
                    const progress = elapsed / 0.5; // 0.5 second animation
                    
                    if (progress < 1) {
                        // Expand bubble and fade out
                        const scale = 1 + progress * (PUNCH_FORCE_RADIUS * 8);
                        bubbleMesh.scale.set(scale, scale, scale);
                        bubbleMaterial.opacity = 0.8 * (1 - progress);
                        
                        requestAnimationFrame(animateBlast);
                    } else {
                        // Remove bubble
                        scene.remove(bubbleMesh);
                        bubbleGeometry.dispose();
                        bubbleMaterial.dispose();
                    }
                };
                animateBlast();
                
                // Create shockwave rings
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        createShockwaveRing(center, i * 0.1);
                    }, i * 100);
                }
                
            } catch (error) {
                console.warn('Punch blast effect error:', error);
            }
        }
        
        // Track active beams for cleanup and main loop updates
        const activeBeams = [];
        
        // Update all active beams in main loop (called from main update function)
        function updateActiveBeams(deltaTime) {
            for (let i = activeBeams.length - 1; i >= 0; i--) {
                const beam = activeBeams[i];
                if (beam && beam.update) {
                    try {
                        const shouldRemove = beam.update(deltaTime);
                        if (shouldRemove) {
                            beam.cleanup();
                            // Remove from active beams array to prevent reprocessing
                            activeBeams.splice(i, 1);
                            console.log(`üóëÔ∏è Removed beam from active list, ${activeBeams.length} beams remaining`);
                        }
                    } catch (error) {
                        console.error('Beam update error:', error);
                        // Force cleanup on error to prevent stuck beams
                        if (beam.cleanup) beam.cleanup();
                        activeBeams.splice(i, 1);
                        console.log(`‚ö†Ô∏è Force removed errored beam, ${activeBeams.length} beams remaining`);
                    }
                } else {
                    // Remove invalid beam objects
                    console.warn('Invalid beam object found, removing');
                    activeBeams.splice(i, 1);
                }
            }
            
            // Safety check: if we have too many active beams, something is wrong
            if (activeBeams.length > 10) {
                console.warn(`‚ö†Ô∏è Too many active beams (${activeBeams.length}), forcing cleanup of old ones`);
                cleanupAllBeams();
            }
        }
        
        function createForceBeam(origin, direction) {
            try {
                console.log('üåü Creating force beam from:', origin.toArray().map(v => v.toFixed(2)), 'direction:', direction.toArray().map(v => v.toFixed(2)));
                
                // Create beam projectile - larger for better VR visibility
                const beamGeometry = new THREE.CylinderGeometry(0.08, 0.20, 3.0, 8);
                const beamMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff3333, // Electric red
                    transparent: true,
                    opacity: 0.9, // Slightly more opaque
                    emissive: 0xff1100 // Bright red emissive for electric effect
                });
                const beamMesh = new THREE.Mesh(beamGeometry, beamMaterial);
                
                // Position and orient the beam
                beamMesh.position.copy(origin);
                beamMesh.lookAt(origin.clone().add(direction));
                beamMesh.rotateX(Math.PI / 2); // Align cylinder with direction
                scene.add(beamMesh);
                
                // Beam travel parameters - increased speed by 40%
                const beamSpeed = 11.2; // Units per second (8.0 * 1.4)
                const beamRange = 15.0; // Maximum travel distance (reduced from 20.0)
                const beamRadius = 1.5; // Effect radius
                let travelDistance = 0;
                const startTime = clock.getElapsedTime();
                let isActive = true;
                let animationId = null;
                
                // Create beam object for main loop updates (NO requestAnimationFrame)
                const beamData = {
                    mesh: beamMesh,
                    geometry: beamGeometry,
                    material: beamMaterial,
                    direction: direction.clone(),
                    travelDistance: 0,
                    startTime: startTime,
                    isActive: true,
                    
                    // Update method called from main loop
                    update: (deltaTime) => {
                        if (!beamData.isActive) return true; // Mark for removal
                        
                        // Check elapsed time for safety
                        const elapsedTime = clock.getElapsedTime() - beamData.startTime;
                        if (elapsedTime > 2.0) {
                            console.log('‚è∞ Force beam timed out');
                            return true; // Mark for removal
                        }
                        
                        // Move beam forward using main loop deltaTime
                        const moveDistance = beamSpeed * deltaTime;
                        beamData.travelDistance += moveDistance;
                        
                        if (beamData.travelDistance < beamRange) {
                            // Move beam forward
                            const movement = beamData.direction.clone().multiplyScalar(moveDistance);
                            beamMesh.position.add(movement);
                            
                            // Check for boid hits
                            boids.forEach(boid => {
                                if (boid && boid.position && beamData.isActive) {
                                    const distanceToBeam = boid.position.distanceTo(beamMesh.position);
                                    if (distanceToBeam < beamRadius) {
                                        // Apply force in beam direction
                                        const forceDirection = beamData.direction.clone();
                                        const forceMagnitude = Math.max(0.5, (beamRadius - distanceToBeam) / beamRadius * 3.0);
                                        boid.velocity.add(forceDirection.multiplyScalar(forceMagnitude));
                                        
                                        // Apply red force punch effect to boid
                                        boid.punchAffected = true;
                                        boid.punchEffectEndTime = clock.getElapsedTime() + 2.0; // 2 seconds
                                        boid.punchGlowColor = new THREE.Color(0xff2222); // Electric red to match beam
                                        
                                        // Visual hit effect
                                        createHitSpark(boid.position.clone());
                                        console.log('‚ö° Force beam hit boid!');
                                    }
                                }
                            });
                            
                            return false; // Keep beam active
                        } else {
                            // Beam reached max range
                            const impactPoint = origin.clone().add(beamData.direction.clone().multiplyScalar(beamRange));
                            createBeamImpact(impactPoint);
                            console.log('üéØ Force beam reached max range');
                            return true; // Mark for removal
                        }
                    },
                    
                    cleanup: () => {
                        if (beamData.isActive) {
                            beamData.isActive = false;
                            scene.remove(beamMesh);
                            beamGeometry.dispose();
                            beamMaterial.dispose();
                            console.log('üóëÔ∏è Force beam cleaned up');
                            // Note: Array removal handled by updateActiveBeams to prevent double-removal
                        }
                    }
                };
                
                // Add to active beams for main loop updates
                activeBeams.push(beamData);
                
                // Create muzzle flash at origin
                createMuzzleFlash(origin);
                
            } catch (error) {
                console.warn('Force beam error:', error);
            }
        }
        
        // Cleanup function for all active beams (call when needed)
        function cleanupAllBeams() {
            console.log(`üßπ Cleaning up ${activeBeams.length} active beams`);
            // Cleanup all beams and clear the array
            activeBeams.forEach(beam => beam.cleanup());
            activeBeams.length = 0; // Clear the array
        }
        
        function createMuzzleFlash(position) {
            const flashGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1.0,
                emissive: 0xffffff
            });
            const flashMesh = new THREE.Mesh(flashGeometry, flashMaterial);
            flashMesh.position.copy(position);
            scene.add(flashMesh);
            
            console.log('üí´ Creating muzzle flash at:', position.toArray().map(v => v.toFixed(2)));
            
            // Cleanup function
            const cleanupFlash = () => {
                if (flashMesh.parent) { // Only cleanup if still in scene
                    scene.remove(flashMesh);
                    flashGeometry.dispose();
                    flashMaterial.dispose();
                    console.log('üßπ Muzzle flash cleaned up');
                }
            };
            
            // Timeout-based cleanup as failsafe (always runs)
            setTimeout(cleanupFlash, 150); // 0.15 seconds max (much faster)
            
            // Quick flash animation (if this fails, timeout will still cleanup)
            let opacity = 1.0;
            let animationId = null;
            const fadeFlash = () => {
                opacity -= 0.2; // Fade out over ~5 frames (much faster)
                if (opacity > 0 && flashMesh.parent) { // Check if still in scene
                    flashMaterial.opacity = opacity;
                    animationId = requestAnimationFrame(fadeFlash);
                } else {
                    if (animationId) cancelAnimationFrame(animationId);
                    cleanupFlash();
                }
            };
            fadeFlash();
        }
        
        function createHitSpark(position) {
            const sparkCount = 5;
            for (let i = 0; i < sparkCount; i++) {
                const particle = getParticleFromPool();
                if (particle) {
                    particle.position.copy(position);
                    particle.velocity.set(
                        (Math.random() - 0.5) * 1.5,
                        (Math.random() - 0.5) * 1.5,
                        (Math.random() - 0.5) * 1.5
                    );
                    particle.life = 0.3;
                    particle.maxLife = 0.3;
                    particle.color = new THREE.Color(0xffff00);
                    particles.push(particle);
                }
            }
        }
        
        function createBeamImpact(position) {
            // Create impact explosion at beam end
            const impactGeometry = new THREE.SphereGeometry(0.8, 12, 12);
            const impactMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6,
                emissive: 0x0066cc
            });
            const impactMesh = new THREE.Mesh(impactGeometry, impactMaterial);
            impactMesh.position.copy(position);
            scene.add(impactMesh);
            
            // Expand and fade
            let scale = 1.0;
            let opacity = 0.6;
            const animateImpact = () => {
                scale += 0.1;
                opacity -= 0.05;
                if (opacity > 0) {
                    impactMesh.scale.set(scale, scale, scale);
                    impactMaterial.opacity = opacity;
                    requestAnimationFrame(animateImpact);
                } else {
                    scene.remove(impactMesh);
                    impactGeometry.dispose();
                    impactMaterial.dispose();
                }
            };
            animateImpact();
        }

        function createShockwaveRing(center, delay) {
            const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            ringMesh.position.copy(center);
            ringMesh.rotation.x = Math.random() * Math.PI;
            ringMesh.rotation.y = Math.random() * Math.PI;
            scene.add(ringMesh);
            
            // Animate ring expansion
            const startTime = clock.getElapsedTime();
            const animateRing = () => {
                const elapsed = clock.getElapsedTime() - startTime;
                const progress = elapsed / 0.8; // 0.8 second animation
                
                if (progress < 1) {
                    const scale = 1 + progress * 15;
                    ringMesh.scale.set(scale, scale, scale);
                    ringMaterial.opacity = 0.6 * (1 - progress);
                    
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ringMesh);
                    ringGeometry.dispose();
                    ringMaterial.dispose();
                }
            };
            animateRing();
        }
        
        function playPunchSound() {
            try {
                // Create punch sound using Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create punch sound with multiple frequency components
                const duration = 0.3;
                const sampleRate = audioContext.sampleRate;
                const frameCount = sampleRate * duration;
                
                const arrayBuffer = audioContext.createBuffer(1, frameCount, sampleRate);
                const channelData = arrayBuffer.getChannelData(0);
                
                // Generate punch sound (thump + high-frequency crack)
                for (let i = 0; i < frameCount; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-t * 8); // Quick decay
                    
                    // Low frequency thump (40-80 Hz)
                    const lowFreq = Math.sin(2 * Math.PI * 60 * t) * 0.8;
                    // High frequency crack (200-400 Hz)
                    const highFreq = Math.sin(2 * Math.PI * 300 * t) * 0.3 * Math.exp(-t * 15);
                    // Mid frequency punch (100-150 Hz)
                    const midFreq = Math.sin(2 * Math.PI * 125 * t) * 0.5;
                    
                    channelData[i] = (lowFreq + highFreq + midFreq) * envelope * 0.3;
                }
                
                // Play the sound
                const source = audioContext.createBufferSource();
                source.buffer = arrayBuffer;
                source.connect(audioContext.destination);
                source.start();
                
            } catch (error) {
                console.warn('Punch sound error:', error);
            }
        }
        
        function createPunchTrail(boid) {
            try {
                if (boid.trailPositions.length < 2) return;
                
                // Only create trail particles occasionally to avoid performance issues
                if (Math.random() < 0.3) {
                    const trailGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                    const trailMaterial = new THREE.MeshBasicMaterial({
                        color: boid.punchGlowColor,
                        transparent: true,
                        opacity: 0.6,
                        emissive: boid.punchGlowColor.clone().multiplyScalar(0.5)
                    });
                    
                    const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                    trailMesh.position.copy(boid.position);
                    scene.add(trailMesh);
                    
                    // Animate trail particle fade
                    const startTime = clock.getElapsedTime();
                    const animateTrail = () => {
                        const elapsed = clock.getElapsedTime() - startTime;
                        const progress = elapsed / 1.0; // 1 second fade
                        
                        if (progress < 1) {
                            trailMaterial.opacity = 0.6 * (1 - progress);
                            const scale = 1 + progress * 2;
                            trailMesh.scale.set(scale, scale, scale);
                            
                            requestAnimationFrame(animateTrail);
                        } else {
                            scene.remove(trailMesh);
                            trailGeometry.dispose();
                            trailMaterial.dispose();
                        }
                    };
                    animateTrail();
                }
                
            } catch (error) {
                console.warn('Punch trail error:', error);
            }
        }
        
        function handleGrabbing(hand, heldVoxelMesh) {
            try {
                console.log(`üîç GRABBING DEBUG: Starting handleGrabbing check`);
                const grabRadius = 0.15; // Increased grab radius
                
                // Extensive safety checks before attempting grab
                if (!hand) {
                    console.warn('‚ùå GRABBING ERROR: hand is null/undefined');
                    return;
                }
                if (!hand.userData) {
                    console.warn('‚ùå GRABBING ERROR: hand.userData is null/undefined');
                    return;
                }
                if (!heldVoxelMesh) {
                    console.warn('‚ùå GRABBING ERROR: heldVoxelMesh is null/undefined');
                    return;
                }
                if (!heldVoxelMesh.material) {
                    console.warn('‚ùå GRABBING ERROR: heldVoxelMesh.material is null/undefined');
                    return;
                }
                if (!groundVoxels) {
                    console.warn('‚ùå GRABBING ERROR: groundVoxels array is null/undefined');
                    return;
                }
                
                console.log(`üîç GRABBING DEBUG: isPinching=${hand.userData.isPinching}, handCenter=${!!hand.userData.handCenter}, heldVoxelIndex=${hand.userData.heldVoxelIndex}, heldBoidIndex=${hand.userData.heldBoidIndex}`);
                
                // Start grabbing - ENHANCED with extensive safety checks
                if (hand.userData.isPinching && hand.userData.heldVoxelIndex === null && hand.userData.heldBoidIndex === null && hand.userData.handCenter) {
                    console.log(`üîç GRABBING DEBUG: Attempting to grab from ${groundVoxels.length} ground voxels`);
                    
                    // Try to grab ground voxels
                    for (let i = 0; i < groundVoxels.length; i++) {
                        const voxel = groundVoxels[i];
                        console.log(`üîç GRABBING DEBUG: Checking voxel ${i}:`, {
                            exists: !!voxel,
                            active: voxel?.active,
                            hasPosition: !!voxel?.position,
                            isVector3: voxel?.position?.isVector3
                        });
                        
                        if (voxel && voxel.active && voxel.position && voxel.position.isVector3) {
                            try {
                                const distance = hand.userData.handCenter.distanceTo(voxel.position);
                                console.log(`üîç GRABBING DEBUG: Voxel ${i} distance: ${distance.toFixed(3)}`);
                                
                                if (distance < 0.3) {
                                    console.log(`‚úÖ GRABBING SUCCESS: Grabbing voxel ${i} at distance ${distance.toFixed(3)}`);
                                    
                                    // Safe state changes
                                    voxel.active = false;
                                    hand.userData.heldVoxelIndex = i;
                                    hand.userData.holdStartTime = clock.getElapsedTime();
                                    
                                    // Safe visual updates
                                    if (heldVoxelMesh.material && heldVoxelMesh.material.color) {
                                        heldVoxelMesh.material.color.set(0x6666ff);
                                        heldVoxelMesh.visible = true;
                                        console.log(`‚úÖ GRABBING SUCCESS: Visual state updated for voxel ${i}`);
                                    } else {
                                        console.warn('‚ö†Ô∏è GRABBING WARNING: Could not update visual state - material invalid');
                                    }
                                    
                                    return;
                                }
                            } catch (distanceError) {
                                console.error(`‚ùå GRABBING ERROR: Distance calculation failed for voxel ${i}:`, distanceError);
                                continue; // Skip this voxel and try next
                            }
                        }
                    }
                    
                    // Try to grab active boids with enhanced debugging
                    console.log(`üîç GRABBING DEBUG: Attempting to grab from ${boids.length} boids`);
                    for (let i = 0; i < boids.length; i++) {
                        const boid = boids[i];
                        
                        try {
                            if (boid && boid.position && !boid.isGrabbed && hand.userData.tipPositions && hand.userData.tipPositions.INDEX) {
                                const distance = hand.userData.tipPositions.INDEX.distanceTo(boid.position);
                                if (distance < grabRadius) {
                                    console.log(`‚úÖ BOID GRABBING SUCCESS: Grabbing boid ${i} at distance ${distance.toFixed(3)}`);
                                    
                                    // Safe state changes
                                    boid.isGrabbed = true;
                                    if (boid.originalVelocity && boid.velocity) {
                                        boid.originalVelocity.copy(boid.velocity);
                                    }
                                    hand.userData.heldBoidIndex = i;
                                    hand.userData.isGrabbingBoid = true;
                                    hand.userData.holdStartTime = clock.getElapsedTime();
                                    
                                    // Safe visual updates
                                    if (heldVoxelMesh.material && heldVoxelMesh.material.color) {
                                        heldVoxelMesh.material.color.set(0xff4444);
                                        heldVoxelMesh.visible = true;
                                        console.log(`‚úÖ BOID GRABBING SUCCESS: Visual state updated for boid ${i}`);
                                    }
                                    return;
                                }
                            }
                        } catch (boidGrabError) {
                            console.error(`‚ùå BOID GRABBING ERROR: Failed to grab boid ${i}:`, boidGrabError);
                            continue; // Skip this boid and try next
                        }
                    }
                }

                // Handle held voxel (revival or predator creation)
                if (hand.userData.heldVoxelIndex !== null) {
                    const holdDuration = clock.getElapsedTime() - hand.userData.holdStartTime;
                    const isShaking = hand.userData.shakeIntensity > SHAKE_THRESHOLD;
                    
                    // Debug logging for shake detection
                    if (frameCount % 30 === 0) { // Log every 30 frames
                        console.log('Shake detection:', {
                            shakeIntensity: hand.userData.shakeIntensity.toFixed(3),
                            threshold: SHAKE_THRESHOLD,
                            isShaking: isShaking,
                            holdDuration: holdDuration.toFixed(2)
                        });
                    }
                    
                    if (!hand.userData.isPinching) {
                        console.log(`üîç VOXEL RELEASE DEBUG: Starting release logic - isShaking=${isShaking}, holdDuration=${holdDuration.toFixed(2)}, REVIVAL_TIME=${REVIVAL_TIME}`);
                        
                        if (isShaking && holdDuration >= 1.0) {
                            console.log(`ü¶à PREDATOR CREATION: Attempting to create predator`);
                            try {
                                // Create predator from vigorous shaking - with safety checks
                                if (heldVoxelMesh && heldVoxelMesh.position) {
                                    const predatorPosition = heldVoxelMesh.position.clone();
                                    console.log(`ü¶à PREDATOR CREATION: Position cloned:`, predatorPosition.toArray());
                                    
                                    const predator = new Predator(predatorPosition);
                                    predators.push(predator);
                                    console.log(`‚úÖ PREDATOR CREATION SUCCESS: Total predators: ${predators.length}`);
                                } else {
                                    console.error(`‚ùå PREDATOR CREATION FAILED: Invalid heldVoxelMesh position`);
                                }
                            } catch (predatorError) {
                                console.error(`‚ùå PREDATOR CREATION FAILED:`, predatorError);
                            }
                        } else if (holdDuration >= REVIVAL_TIME) {
                            console.log(`üêü BOID REVIVAL: Attempting to revive boid`);
                            try {
                                // Normal revival - with safety checks
                                if (heldVoxelMesh && heldVoxelMesh.position) {
                                    const boidPosition = heldVoxelMesh.position.clone();
                                    console.log(`üêü BOID REVIVAL: Position cloned:`, boidPosition.toArray());
                                    
                                    const newBoid = new Boid(boidPosition);
                                    boids.push(newBoid);
                                    console.log(`‚úÖ BOID REVIVAL SUCCESS: Total boids: ${boids.length}`);
                                } else {
                                    console.error(`‚ùå BOID REVIVAL FAILED: Invalid heldVoxelMesh position`);
                                }
                            } catch (boidError) {
                                console.error(`‚ùå BOID REVIVAL FAILED:`, boidError);
                            }
                        } else {
                            console.log(`üì¶ VOXEL RETURN: Attempting to return voxel to ground`);
                            try {
                                // Return ground voxel to original position if released too early - ENHANCED SAFETY
                                const voxelIndex = hand.userData.heldVoxelIndex;
                                console.log(`üì¶ VOXEL RETURN: Index=${voxelIndex}, groundVoxels.length=${groundVoxels.length}`);
                                
                                if (voxelIndex !== null && voxelIndex >= 0 && voxelIndex < groundVoxels.length) {
                                    const voxel = groundVoxels[voxelIndex];
                                    console.log(`üì¶ VOXEL RETURN: Voxel exists=${!!voxel}, hasPosition=${!!voxel?.position}, heldMeshHasPosition=${!!heldVoxelMesh?.position}`);
                                    
                                    if (voxel && voxel.position && heldVoxelMesh && heldVoxelMesh.position) {
                                        voxel.active = true;
                                        voxel.position.copy(heldVoxelMesh.position);
                                        voxel.position.y = 0.1; // Reset to ground level
                                        voxel.originalY = 0.1;
                                        console.log(`‚úÖ VOXEL RETURN SUCCESS: Voxel ${voxelIndex} returned to position:`, voxel.position.toArray());
                                    } else {
                                        console.error(`‚ùå VOXEL RETURN FAILED: Invalid data:`, { 
                                            voxelExists: !!voxel, 
                                            voxelHasPosition: !!voxel?.position,
                                            heldMeshExists: !!heldVoxelMesh,
                                            heldMeshHasPosition: !!heldVoxelMesh?.position
                                        });
                                    }
                                } else {
                                    console.error(`‚ùå VOXEL RETURN FAILED: Invalid index=${voxelIndex}, array length=${groundVoxels.length}`);
                                }
                            } catch (returnError) {
                                console.error(`‚ùå VOXEL RETURN FAILED:`, returnError);
                            }
                        }
                        
                        // Safe cleanup
                        try {
                            console.log(`üßπ VOXEL CLEANUP: Starting cleanup`);
                            hand.userData.heldVoxelIndex = null;
                            
                            if (heldVoxelMesh) {
                                heldVoxelMesh.visible = false;
                                if (heldVoxelMesh.position) {
                                    heldVoxelMesh.position.set(0, -1000, 0); // Move far away
                                }
                                console.log(`‚úÖ VOXEL CLEANUP SUCCESS: Held mesh reset`);
                            } else {
                                console.warn(`‚ö†Ô∏è VOXEL CLEANUP WARNING: heldVoxelMesh is null`);
                            }
                        } catch (cleanupError) {
                            console.error(`‚ùå VOXEL CLEANUP FAILED:`, cleanupError);
                        }
                        
                    } else if (isShaking) {
                        console.log(`üî• SHAKING VISUAL: Updating shake visual feedback`);
                        try {
                            // Visual feedback for shaking - turn red - with safety checks
                            if (heldVoxelMesh && heldVoxelMesh.material && heldVoxelMesh.material.color) {
                                heldVoxelMesh.material.color.set(0xff0000);
                                console.log(`‚úÖ SHAKING VISUAL SUCCESS: Color updated to red`);
                            } else {
                                console.warn(`‚ö†Ô∏è SHAKING VISUAL WARNING: Invalid material or color property`);
                            }
                        } catch (shakeError) {
                            console.error(`‚ùå SHAKING VISUAL FAILED:`, shakeError);
                        }
                    }
                }
                
                // Handle held boid (tossing mechanic)
                if (hand.userData.heldBoidIndex !== null) {
                    const boid = boids[hand.userData.heldBoidIndex];
                    if (!hand.userData.isPinching) {
                        // Release and toss the boid
                        boid.isGrabbed = false;
                        boid.isBeingTossed = true;
                        boid.tossStartTime = clock.getElapsedTime();
                        boid.tossVelocity.copy(hand.userData.velocity);
                        boid.position.copy(heldVoxelMesh.position);
                        
                        hand.userData.heldBoidIndex = null;
                        hand.userData.isGrabbingBoid = false;
                        heldVoxelMesh.visible = false;
                        heldVoxelMesh.position.set(0, -1000, 0); // Move far away
                        console.log('Boid tossed');
                    }
                }
            } catch (error) {
                console.error('üö® CRITICAL GRABBING ERROR - MAIN HANDLER:', error);
                console.error('üö® ERROR STACK:', error.stack);
                console.error('üö® ERROR CONTEXT:', {
                    handExists: !!hand,
                    handUserDataExists: !!hand?.userData,
                    heldVoxelMeshExists: !!heldVoxelMesh,
                    groundVoxelsExists: !!groundVoxels,
                    groundVoxelsLength: groundVoxels?.length,
                    boidsExists: !!boids,
                    boidsLength: boids?.length
                });
                
                // Emergency cleanup to prevent crash propagation
                try {
                    if (hand && hand.userData) {
                        hand.userData.heldVoxelIndex = null;
                        hand.userData.heldBoidIndex = null;
                        hand.userData.isGrabbingBoid = false;
                    }
                    if (heldVoxelMesh) {
                        heldVoxelMesh.visible = false;
                        if (heldVoxelMesh.position) {
                            heldVoxelMesh.position.set(0, -1000, 0);
                        }
                    }
                    console.log('üÜò EMERGENCY CLEANUP: Grabbing state reset after error');
                } catch (cleanupError) {
                    console.error('üö® EMERGENCY CLEANUP FAILED:', cleanupError);
                }
            }
        }
        
        function createForceBlastEffect(center, direction) {
            // Create expanding ring of particles to show force blast
            const particleCount = 15; // Reduced for Quest performance
            for (let i = 0; i < particleCount; i++) {
                const particle = getParticleFromPool();
                if (particle) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 0.5;
                    particle.position.copy(center);
                    particle.velocity.set(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 0.5,
                        Math.sin(angle) * radius
                    ).add(direction.clone().multiplyScalar(0.5));
                    particle.life = 0.8;
                    particle.maxLife = 0.8;
                    particle.color = new THREE.Color(0x00aaff);
                    particles.push(particle);
                }
            }
        }
        
        function createParticleExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 10; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = getParticleFromPool();
                    if (particle) {
                        particle.position.copy(position);
                        particle.velocity.set(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        particle.life = 1.0;
                        particle.maxLife = 1.0;
                        particle.color = new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 1, 0.5);
                        particles.push(particle);
                    }
                }
            } catch (error) {
                console.warn('Particle explosion error:', error);
            }
        }
        
        // Fountain update and spawn functions removed - system eliminated

        function updateHandData(hand) {
            try {
                // Reset ready state
                hand.userData.isReady = false;
                
                // Check if we have the basic joints we need
                if (!hand.joints) {
                    console.warn('No hand.joints available');
                    return;
                }
                
                // Get essential joints
                const wrist = hand.joints['wrist'];
                const indexTip = hand.joints['index-finger-tip'];
                const thumbTip = hand.joints['thumb-tip'];
                const middleTip = hand.joints['middle-finger-tip'];
                
                if (!wrist || !indexTip || !thumbTip || !middleTip) {
                    console.warn('Missing essential hand joints');
                    return;
                }
                
                // All joints available - hand is ready
                hand.userData.isReady = true;
                
                // Store previous hand center for velocity - prevent initial velocity spike
                const isFirstFrame = !hand.userData.handCenter || hand.userData.handCenter.length() === 0;
                const previousCenter = isFirstFrame ? wrist.position.clone() : hand.userData.handCenter.clone();
                
                // Smooth joint positions to handle tracking loss (lerp with previous if valid)
                const smoothingFactor = 0.8; // Adjust for smoother tracking
                if (!hand.userData.prevThumb) hand.userData.prevThumb = new THREE.Vector3();
                if (!hand.userData.prevIndex) hand.userData.prevIndex = new THREE.Vector3();
                if (!hand.userData.prevMiddle) hand.userData.prevMiddle = new THREE.Vector3();
                if (!hand.userData.prevWrist) hand.userData.prevWrist = new THREE.Vector3();
                
                hand.userData.tipPositions.THUMB.lerpVectors(hand.userData.prevThumb, thumbTip.position, smoothingFactor);
                hand.userData.tipPositions.INDEX.lerpVectors(hand.userData.prevIndex, indexTip.position, smoothingFactor);
                hand.userData.tipPositions.MIDDLE.lerpVectors(hand.userData.prevMiddle, middleTip.position, smoothingFactor);
                hand.userData.wristPosition.lerpVectors(hand.userData.prevWrist, wrist.position, smoothingFactor);
                
                // Update previous positions
                hand.userData.prevThumb.copy(hand.userData.tipPositions.THUMB);
                hand.userData.prevIndex.copy(hand.userData.tipPositions.INDEX);
                hand.userData.prevMiddle.copy(hand.userData.tipPositions.MIDDLE);
                hand.userData.prevWrist.copy(hand.userData.wristPosition);
                
                // Calculate hand center (use wrist as primary reference)
                hand.userData.handCenter.copy(hand.userData.wristPosition);
                
                // Calculate velocity (simpler approach) - prevent initial spikes
                if (isFirstFrame) {
                    hand.userData.velocity.set(0, 0, 0); // Zero velocity on first frame
                    hand.userData.startupFrames = 0; // Initialize startup counter
                } else {
                    hand.userData.velocity.subVectors(hand.userData.handCenter, previousCenter);
                    hand.userData.velocity.multiplyScalar(120); // Scale for reasonable velocity values
                    hand.userData.velocity.clampLength(0, 10); // Clamp to prevent extreme values from tracking glitches
                }
                
                // Increment startup counter
                hand.userData.startupFrames = (hand.userData.startupFrames || 0) + 1;
                
                // Simple pinch detection
                const thumbIndexDist = hand.userData.tipPositions.THUMB.distanceTo(hand.userData.tipPositions.INDEX);
                hand.userData.isPinching = thumbIndexDist < 0.04;
                
                // Improved fist detection - fingers close to wrist with weighted scoring
                const thumbToWrist = hand.userData.tipPositions.THUMB.distanceTo(hand.userData.wristPosition);
                const indexToWrist = hand.userData.tipPositions.INDEX.distanceTo(hand.userData.wristPosition);
                const middleToWrist = hand.userData.tipPositions.MIDDLE.distanceTo(hand.userData.wristPosition);
                
                // More reliable fist detection - require at least 2 of 3 fingers to be close
                const fistThreshold = 0.12;
                const closedFingers = [
                    thumbToWrist < fistThreshold,
                    indexToWrist < fistThreshold, 
                    middleToWrist < fistThreshold
                ].filter(closed => closed).length;
                
                hand.userData.isFist = closedFingers >= 2;
                
                // Calculate punch velocity only when fist is detected
                hand.userData.recentMaxVelocity = hand.userData.recentMaxVelocity || 0;
                if (hand.userData.isFist) {
                  hand.userData.recentMaxVelocity = Math.max(hand.userData.recentMaxVelocity, hand.userData.velocity.length());
                } else {
                  hand.userData.recentMaxVelocity = 0;
                }
                hand.userData.punchVelocity = hand.userData.isFist ? hand.userData.recentMaxVelocity : 0;
                
                // Update debug info
                if (hand.userData.debugHandIndex !== undefined) {
                    const handInfo = hand.userData.debugHandIndex === 0 ? debugInfo.leftHand : debugInfo.rightHand;
                    handInfo.isFist = hand.userData.isFist;
                    handInfo.velocity = hand.userData.punchVelocity;
                    handInfo.isReady = hand.userData.isReady;
                    handInfo.thumbDist = thumbToWrist;
                    handInfo.indexDist = indexToWrist;
                    handInfo.middleDist = middleToWrist;
                }
                
                // Pointing detection for teleportation
                if (hand.userData.debugHandIndex === 1) { // Right hand only
                    // Simple pointing: index finger extended, others curled
                    const indexExtended = indexToWrist > 0.15;
                    const othersRetracted = thumbToWrist < 0.12 && middleToWrist < 0.12;
                    hand.userData.isPointing = indexExtended && othersRetracted;
                    
                    // Debug pointing detection
                    if (frameCount % 60 === 0) {
                        console.log(`üëâ POINTING CHECK: index=${indexToWrist.toFixed(3)}(need >0.15), thumb=${thumbToWrist.toFixed(3)}(<0.12), middle=${middleToWrist.toFixed(3)}(<0.12), isPointing=${hand.userData.isPointing}`);
                    }
                }
                
            } catch (error) {
                console.warn('Hand tracking error:', error);
                hand.userData.isReady = false;
            }
        }


        function update() {
            const elapsedTime = clock.getElapsedTime();
            const dummy = new THREE.Object3D();
            frameCount++;
            let deltaTime = clock.getDelta();
            // Fix deltaTime issues - clamp to reasonable values for 60-120fps
            if (deltaTime < 0.008) deltaTime = 0.008; // Min ~120fps
            if (deltaTime > 0.033) deltaTime = 0.016; // Max ~60fps, clamp to ~60fps
            
            // Debug deltaTime issues
            if (frameCount % 60 === 0) {
                console.log(`‚è±Ô∏è deltaTime: ${deltaTime.toFixed(6)}s (${(1/deltaTime).toFixed(1)}fps)`);
            }
            
            // Update frustum culling
            updateFrustumCulling();
            
            // Monitor frame rate and adjust quality for 120fps
            updateFrameRateMonitoring(deltaTime);
            
            
            // Update punch cooldowns
            if (punchCooldown1 > 0) {
                punchCooldown1 -= deltaTime;
                if (punchCooldown1 <= 0) {
                    punchCooldown1 = 0;
                    console.log(`‚úÖ Cooldown1 reset to 0`);
                }
                if (frameCount % 30 === 0) {
                    console.log(`‚è∞ Cooldown1 decreasing: ${punchCooldown1.toFixed(3)}s remaining`);
                }
            }
            if (punchCooldown2 > 0) {
                punchCooldown2 -= deltaTime;
                if (punchCooldown2 <= 0) {
                    punchCooldown2 = 0;
                    console.log(`‚úÖ Cooldown2 reset to 0`);
                }
                if (frameCount % 30 === 0) {
                    console.log(`‚è∞ Cooldown2 decreasing: ${punchCooldown2.toFixed(3)}s remaining`);
                }
            }

            // Only update hand data if XR is active
            if (renderer.xr.isPresenting) {
                updateHandData(hand1);
                updateHandData(hand2);
                handleGrabbing(hand1, heldVoxelMesh1);
                handleGrabbing(hand2, heldVoxelMesh2);
                
                // Update held voxel positions to follow hands - with crash protection
                try {
                    if (hand1.userData.heldVoxelIndex !== null || hand1.userData.heldBoidIndex !== null) {
                        if (hand1.userData.handCenter && hand1.userData.handCenter.isVector3 && 
                            heldVoxelMesh1 && heldVoxelMesh1.visible && heldVoxelMesh1.position) {
                            heldVoxelMesh1.position.copy(hand1.userData.handCenter);
                            heldVoxelMesh1.position.add(new THREE.Vector3(0, 0.05, 0));
                        }
                    }
                } catch (error) {
                    console.error('Hand1 voxel position update crash:', error);
                    // Emergency cleanup
                    if (heldVoxelMesh1) {
                        heldVoxelMesh1.visible = false;
                        heldVoxelMesh1.position.set(0, -1000, 0);
                    }
                    hand1.userData.heldVoxelIndex = null;
                    hand1.userData.heldBoidIndex = null;
                }
                
                try {
                    if (hand2.userData.heldVoxelIndex !== null || hand2.userData.heldBoidIndex !== null) {
                        if (hand2.userData.handCenter && hand2.userData.handCenter.isVector3 && 
                            heldVoxelMesh2 && heldVoxelMesh2.visible && heldVoxelMesh2.position) {
                            heldVoxelMesh2.position.copy(hand2.userData.handCenter);
                            heldVoxelMesh2.position.add(new THREE.Vector3(0, 0.05, 0));
                        }
                    }
                } catch (error) {
                    console.error('Hand2 voxel position update crash:', error);
                    // Emergency cleanup
                    if (heldVoxelMesh2) {
                        heldVoxelMesh2.visible = false;
                        heldVoxelMesh2.position.set(0, -1000, 0);
                    }
                    hand2.userData.heldVoxelIndex = null;
                    hand2.userData.heldBoidIndex = null;
                }
                
                // Game of Life touch interaction removed for performance
                
                // Handle teleportation (only use right hand to avoid conflicts)
                handleTeleportation(hand2, elapsedTime);
                
                // Handle punch detection - SIMPLIFIED
                [hand1, hand2].forEach((hand, index) => {
                    try {
                        const currentCooldown = index === 0 ? punchCooldown1 : punchCooldown2;
                        const startupFrames = hand.userData.startupFrames || 0;
                        
                        // Require startup grace period and no cooldown
                        if (currentCooldown > 0 || !hand.userData.isReady || startupFrames < 60) {
                            if (frameCount % 60 === 0 && currentCooldown > 0) {
                                console.log(`‚è∞ Hand ${index} on cooldown: ${currentCooldown.toFixed(2)}s remaining`);
                            }
                            if (frameCount % 60 === 0 && startupFrames < 60) {
                                console.log(`üöÄ Hand ${index} in startup: ${startupFrames}/60 frames`);
                            }
                            return;
                        }
                        
                        // Update debug info - calculate raw velocity once
                        const handInfo = index === 0 ? debugInfo.leftHand : debugInfo.rightHand;
                        const rawVelocity = hand.userData.velocity ? hand.userData.velocity.length() : 0;
                        
                        handInfo.isFist = hand.userData.isFist;
                        handInfo.velocity = rawVelocity; // Use raw velocity instead of broken punchVelocity
                        handInfo.cooldown = index === 0 ? punchCooldown1 : punchCooldown2; // Use actual cooldown variable
                        handInfo.isReady = hand.userData.isReady;
                        
                        // AGGRESSIVE DEBUG: Log every frame when conditions are close
                        if (frameCount % 10 === 0) {
                            console.log(`üîç DETAILED CHECK Hand ${index}:`, {
                                isFist: hand.userData.isFist,
                                rawVelocity: rawVelocity.toFixed(3),
                                startupFrames: hand.userData.startupFrames,
                                cooldown: currentCooldown.toFixed(3),
                                isReady: hand.userData.isReady,
                                handCenterExists: !!hand.userData.handCenter,
                                velocityExists: !!hand.userData.velocity
                            });
                        }
                        
                        // EXTRA DEBUG: Log when we have a fist but low velocity
                        if (hand.userData.isFist && rawVelocity < 4.0 && rawVelocity > 0.1) {
                            console.log(`‚ö†Ô∏è FIST BUT LOW VELOCITY Hand ${index}: velocity=${rawVelocity.toFixed(3)}, need >4.0`);
                        }
                        
                        // UNIFIED PUNCH DETECTION: Use raw velocity only
                        
                        // Debug logging every 30 frames when fist is detected
                        if (frameCount % 30 === 0 && hand.userData.isFist) {
                            console.log(`üëä PUNCH CHECK Hand ${index}: Fist=${hand.userData.isFist}, RawVelocity=${rawVelocity.toFixed(3)}, Will punch=${rawVelocity > 4.0}`);
                        }
                        
                        if (hand.userData.isFist && rawVelocity > 4.0) {
                            console.log('üëä PUNCH DETECTED! Hand:', index, 'Raw velocity:', rawVelocity.toFixed(3));
                            console.log('üìä Before increment - handInfo.punchCount:', handInfo.punchCount);
                            console.log('üìä debugInfo reference check:', index === 0 ? 'leftHand' : 'rightHand', debugInfo.leftHand.punchCount, debugInfo.rightHand.punchCount);
                            
                            handInfo.punchCount++;
                            
                            console.log('üìä After increment - handInfo.punchCount:', handInfo.punchCount);
                            console.log('üìä debugInfo after increment:', debugInfo.leftHand.punchCount, debugInfo.rightHand.punchCount);
                            console.log('üî¢ Punch count for hand', index, ':', handInfo.punchCount);
                            
                            // Create directional force beam effect
                            createForceBeam(hand.userData.handCenter.clone(), hand.userData.velocity.clone().normalize());
                            
                            // Note: Boid interactions now handled by the traveling beam
                            console.log(`üåü Force beam launched from hand!`);
                            
                            // Set cooldown
                            if (index === 0) {
                                punchCooldown1 = PUNCH_COOLDOWN;
                                console.log(`‚è∞ Set punchCooldown1 to ${PUNCH_COOLDOWN}s`);
                            } else {
                                punchCooldown2 = PUNCH_COOLDOWN;
                                console.log(`‚è∞ Set punchCooldown2 to ${PUNCH_COOLDOWN}s`);
                            }
                            hand.userData.recentMaxVelocity = 0;
                            console.log(`üîÑ Reset recentMaxVelocity to 0 for hand ${index}`);
                        }
                        
                    } catch (error) {
                        console.warn('Punch detection error:', error);
                    }
                });
            }
            
            // Update debug overlay in VR mode
            if (renderer.xr.isPresenting && debugOverlay) {
                debugOverlay.visible = true;
                debugInfo.frameCount = frameCount;
                updateDebugOverlay();
            } else if (debugOverlay) {
                debugOverlay.visible = false;
            }
            
            // Update particles with performance optimization using object pool
            try {
                const shouldUpdateParticles = frameCount % PARTICLE_UPDATE_INTERVAL === 0;
                
                if (shouldUpdateParticles) {
                    particles = particles.filter(particle => {
                        if (!particle || !particle.position || !particle.velocity) {
                            if (particle) returnParticleToPool(particle);
                            return false;
                        }
                        
                        particle.life -= deltaTime * 2 * PARTICLE_UPDATE_INTERVAL;
                        if (particle.life <= 0) {
                            returnParticleToPool(particle);
                            return false;
                        }
                        
                        particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime * PARTICLE_UPDATE_INTERVAL));
                        particle.velocity.multiplyScalar(0.98); // Friction
                        return true;
                    });
                }
            } catch (error) {
                console.warn('Particle update error:', error);
                particles.forEach(p => returnParticleToPool(p));
                particles = []; // Clear particles on error
            }

            // Update held objects for both hands
            [hand1, hand2].forEach((hand, handIndex) => {
                // Check if hand tracking data is available
                if (!hand.userData || !hand.userData.tipPositions || !hand.userData.tipPositions.INDEX) {
                    return; // Skip if hand tracking not ready
                }
                
                const heldMesh = handIndex === 0 ? heldVoxelMesh1 : heldVoxelMesh2;
                
                // Update held voxel (revival mechanic)
                if (hand.userData.heldVoxelIndex !== null) {
                    // Check if we're holding a ground voxel
                    if (hand.userData.heldVoxelIndex < groundVoxels.length) {
                        const voxel = groundVoxels[hand.userData.heldVoxelIndex];
                        if (voxel && hand.userData.tipPositions.INDEX) {
                            heldMesh.position.copy(hand.userData.tipPositions.INDEX);
                            heldMesh.visible = true; // Make visible when holding
                            const chargeRatio = Math.min((elapsedTime - hand.userData.holdStartTime) / REVIVAL_TIME, 1.0);
                            const finalColor = new THREE.Color(0x00ffaa); // Default final color
                            heldMesh.material.color.lerpColors(new THREE.Color(0x550055), finalColor, chargeRatio);
                            heldMesh.material.emissive.lerpColors(new THREE.Color(0x550055), finalColor, chargeRatio);
                        }
                    }
                } else if (hand.userData.heldBoidIndex !== null) {
                    // Update held boid position
                    const boid = boids[hand.userData.heldBoidIndex];
                    if (boid && hand.userData.tipPositions.INDEX) {
                        heldMesh.position.copy(hand.userData.tipPositions.INDEX);
                        heldMesh.visible = true; // Make visible when holding
                        boid.position.copy(heldMesh.position);
                    }
                    
                    // Visual feedback for held boid
                    const holdTime = elapsedTime - hand.userData.holdStartTime;
                    const pulseFactor = (Math.sin(holdTime * 10) + 1) / 2;
                    heldMesh.material.emissive.setRGB(0.8 * pulseFactor, 0.2 * pulseFactor, 0.2 * pulseFactor);
                } else {
                    // Hide held mesh when not holding anything
                    heldMesh.visible = false;
                    heldMesh.position.set(0, -1000, 0); // Move far away
                }
            });
            
            
            // Temporal spreading of expensive updates for 120fps
            const currentFrame = frameCount % TEMPORAL_SPREAD_FRAMES;
            
            // Fountain system removed - too problematic
            
            // Game of Life updates removed for performance
            
            // Update sky battle and starfield (frames 1, 3, 5)
            if (currentFrame === updateQueues.skyBattle) {
                updateSkyBattle(deltaTime, elapsedTime);
                updateQueues.skyBattle = (updateQueues.skyBattle + 2) % TEMPORAL_SPREAD_FRAMES;
            }
            
            // Update active force beams every frame for smooth movement
            updateActiveBeams(deltaTime);
            
            // Fountain mesh update removed - system eliminated
            
            // Update ground voxels with gentle glow effect
            if (groundVoxelsMesh) {
                const dummy = new THREE.Object3D();
                let activeGroundVoxels = 0;
                
                groundVoxels.forEach((voxel, i) => {
                    if (voxel && voxel.active) {
                        // Gentle floating animation
                        voxel.glowPhase += deltaTime * 2;
                        const glowOffset = Math.sin(voxel.glowPhase) * 0.02;
                        voxel.position.y = voxel.originalY + glowOffset;
                        
                        dummy.position.copy(voxel.position);
                        dummy.updateMatrix();
                        groundVoxelsMesh.setMatrixAt(activeGroundVoxels++, dummy.matrix);
                    }
                });
                
                groundVoxelsMesh.count = activeGroundVoxels;
                groundVoxelsMesh.instanceMatrix.needsUpdate = true;
                groundVoxelsMesh.visible = activeGroundVoxels > 0;
                
                // Occasionally respawn ground voxels if low count
                if (frameCount % 1800 === 0 && activeGroundVoxels < groundVoxelCount / 2) { // Every 15 seconds at 120fps
                    for (let i = 0; i < groundVoxels.length; i++) {
                        const voxel = groundVoxels[i];
                        if (voxel && !voxel.active) {
                            voxel.active = true;
                            voxel.position.set(
                                (Math.random() - 0.5) * boundSize * 0.8,
                                0.1,
                                (Math.random() - 0.5) * boundSize * 0.8
                            );
                            voxel.originalY = 0.1;
                            voxel.glowPhase = Math.random() * Math.PI * 2;
                            console.log('‚ú® Respawned ground voxel', i);
                            break; // Only respawn one per cycle
                        }
                    }
                }
            }

            const aliveVoxelsMesh = scene.getObjectByName('alive_voxels');
            if (aliveVoxelsMesh && boids.length > 0) {
                aliveVoxelsMesh.count = boids.length;
                
                // Performance optimization: only update flocking every few frames for distant boids
                const shouldUpdateFlocking = frameCount % OPTIMIZATION_INTERVAL === 0;
                
                // Spatial partitioning for 120fps collision detection
                spatialGrid.clear();
                boids.forEach(boid => spatialGrid.insert(boid));
                
                // LOD-based boid updates for 120fps
                let processedBoids = 0;
                const maxBoidsPerFrame = Math.ceil(boids.length * currentQualityLevel);
                
                // LOD-based flocking updates for performance
                
                boids.forEach((boid, i) => {
                    // Skip some boids based on quality level for 120fps
                    if (processedBoids >= maxBoidsPerFrame && !boid.isGrabbed) {
                        return; // Skip this boid this frame
                    }
                    
                    const distanceToCamera = camera.position.distanceTo(boid.position);
                    const lodLevel = getLODLevel(distanceToCamera);
                    const inFrustum = isObjectInFrustum(boid.position, 0.2);
                    
                    // Skip culled objects entirely
                    if (lodLevel === 'CULLED' && !boid.isGrabbed) {
                        return;
                    }
                    
                    if (!boid.isGrabbed && (inFrustum || distanceToCamera < CULLING_DISTANCE)) {
                        // Update frequency based on LOD level
                        let updateThisFrame = false;
                        switch(lodLevel) {
                            case 'CLOSE':
                                updateThisFrame = true; // Always update close objects
                                break;
                            case 'MEDIUM':
                                updateThisFrame = shouldUpdateFlocking || boid.isBeingTossed;
                                break;
                            case 'FAR':
                                updateThisFrame = (frameCount % (OPTIMIZATION_INTERVAL * 2) === 0) || boid.isBeingTossed;
                                break;
                        }
                        
                        if (updateThisFrame) {
                            // Use spatial partitioning for nearby boids instead of all boids
                            const nearbyBoids = spatialGrid.getNearby(boid.position, 3.0);
                            boid.flock(nearbyBoids, [hand1, hand2], [], predators);
                        }
                        boid.checkBounds();
                    }
                    
                    boid.update();
                    dummy.position.copy(boid.position);
                    
                    // Fix spinning issue: use smoothed direction instead of raw velocity
                    if (boid.velocity.length() > 0.05) {
                        const targetRotation = boid.position.clone().add(boid.smoothedDirection);
                        dummy.lookAt(targetRotation);
                    }
                    
                    dummy.updateMatrix();
                    aliveVoxelsMesh.setMatrixAt(i, dummy.matrix);
                    
                    // Update enhanced instance color with pulsing effects
                    if (aliveVoxelsMesh.instanceColor) {
                        aliveVoxelsMesh.instanceColor.setXYZ(i, 
                            boid.currentColor.r, 
                            boid.currentColor.g, 
                            boid.currentColor.b
                        );
                    }
                    
                    processedBoids++;
                });
                aliveVoxelsMesh.instanceMatrix.needsUpdate = true;
                if (aliveVoxelsMesh.instanceColor) {
                    aliveVoxelsMesh.instanceColor.needsUpdate = true;
                }
                
                // Update predators with performance optimization
                const predatorMesh = scene.getObjectByName('predators');
                if (predatorMesh && predators.length > 0) {
                    predatorMesh.count = predators.length;
                    const shouldUpdatePredatorMesh = frameCount % OPTIMIZATION_INTERVAL === 0;
                    
                    predators.forEach((predator, i) => {
                        try {
                            if (!predator.isGrabbed) {
                                if (shouldUpdatePredatorMesh) {
                                    predator.hunt(boids);
                                    predator.checkBounds();
                                }
                            }
                            predator.update();
                            
                            // Only update matrix if updating mesh
                            if (shouldUpdatePredatorMesh) {
                                dummy.position.copy(predator.position);
                                if (predator.velocity && predator.velocity.length() > 0.01) {
                                    dummy.lookAt(predator.position.clone().add(predator.velocity));
                                }
                                dummy.updateMatrix();
                                predatorMesh.setMatrixAt(i, dummy.matrix);
                            }
                        } catch (error) {
                            console.warn('Predator update error:', error);
                        }
                    });
                    
                    if (shouldUpdatePredatorMesh) {
                        predatorMesh.instanceMatrix.needsUpdate = true;
                    }
                }
            }
        }

        function render() { renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        // Object pooling for particles
        function initParticlePool() {
            particlePool = [];
            for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
                particlePool.push({
                    position: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    life: 0,
                    maxLife: 1,
                    inUse: false
                });
            }
        }
        
        function getParticleFromPool() {
            for (let i = 0; i < particlePool.length; i++) {
                if (!particlePool[i].inUse) {
                    particlePool[i].inUse = true;
                    return particlePool[i];
                }
            }
            return null; // Pool exhausted
        }
        
        function returnParticleToPool(particle) {
            particle.inUse = false;
            particle.life = 0;
        }
        
        // Frustum culling function
        function updateFrustumCulling() {
            cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(cameraMatrix);
        }
        
        function isObjectInFrustum(position, radius = 1.0) {
            const sphere = new THREE.Sphere(position, radius);
            return frustum.intersectsSphere(sphere);
        }
        
        // Initialize shared materials for performance optimization (120fps optimized)
        function initSharedMaterials() {
            // Use MeshBasicMaterial for maximum performance (no lighting calculations)
            sharedMaterials.boidMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                transparent: false, // Disable transparency for performance
                fog: false // Disable fog for performance
            });
            
            sharedMaterials.particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: false, // Disable transparency for performance
                fog: false
            });
            
            sharedMaterials.starMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffaa,
                transparent: false,
                fog: false
            });
            
            sharedMaterials.spaceMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: false,
                fog: false
            });
            
            // Fountain material removed - system eliminated
            
            // Quality-based material switching
            sharedMaterials.updateForQuality = function(qualityLevel) {
                const useBasicMaterials = qualityLevel < 0.7;
                
                if (useBasicMaterials) {
                    // Switch to basic materials for better performance
                    Object.values(sharedMaterials).forEach(material => {
                        if (material && material.type) {
                            material.transparent = false;
                            material.fog = false;
                        }
                    });
                }
            };
        }
        
        // Frame rate monitoring and dynamic quality scaling for 120fps
        function updateFrameRateMonitoring(deltaTime) {
            if (deltaTime > 0) {
                const currentFPS = 1 / deltaTime;
                frameRateHistory.push(currentFPS);
                
                // Keep only last 60 frames for rolling average
                if (frameRateHistory.length > 60) {
                    frameRateHistory.shift();
                }
                
                // Calculate average FPS every 60 frames
                if (frameRateHistory.length >= 60) {
                    const avgFPS = frameRateHistory.reduce((a, b) => a + b) / frameRateHistory.length;
                    
                    // Dynamic quality scaling
                    if (avgFPS < MIN_FRAME_RATE) {
                        currentQualityLevel = Math.max(0.3, currentQualityLevel - 0.1);
                        console.log(`üîª Quality reduced to ${(currentQualityLevel * 100).toFixed(0)}% (FPS: ${avgFPS.toFixed(1)})`);
                    } else if (avgFPS > TARGET_FRAME_RATE * 0.95 && currentQualityLevel < 1.0) {
                        currentQualityLevel = Math.min(1.0, currentQualityLevel + 0.05);
                        console.log(`üî∫ Quality increased to ${(currentQualityLevel * 100).toFixed(0)}% (FPS: ${avgFPS.toFixed(1)})`);
                    }
                    
                    frameRateHistory = []; // Reset for next measurement
                }
            }
        }
        
        // LOD system for objects based on distance
        function getLODLevel(distance) {
            if (distance < LOD_DISTANCES.CLOSE) return 'CLOSE';
            if (distance < LOD_DISTANCES.MEDIUM) return 'MEDIUM';
            if (distance < LOD_DISTANCES.FAR) return 'FAR';
            return 'CULLED';
        }
        
        // Initialize VR debug overlay
        function initDebugOverlay() {
            // Create debug overlay positioned in VR space
            debugOverlay = new THREE.Group();
            debugOverlay.position.set(2, 2, -3); // Position to upper right in VR
            
            // Create background panel
            const panelGeometry = new THREE.PlaneGeometry(6, 4.5);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            debugOverlay.add(panel);
            
            // Create text using canvas texture
            const canvas = document.createElement('canvas');
            canvas.width = 800;
            canvas.height = 600;
            const context = canvas.getContext('2d');
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const textGeometry = new THREE.PlaneGeometry(6, 4);
            debugText = new THREE.Mesh(textGeometry, textMaterial);
            debugText.position.z = 0.01; // Slightly in front of panel
            debugOverlay.add(debugText);
            
            // Store canvas and context for updating
            debugText.canvas = canvas;
            debugText.context = context;
            debugText.texture = texture;
            
            scene.add(debugOverlay);
            debugOverlay.visible = false; // Hidden by default
            
            console.log('üîç Debug overlay initialized');
        }

        // Update debug overlay with current info
        function updateDebugOverlay() {
            if (!debugText || !debugText.context) return;
            
            const ctx = debugText.context;
            const canvas = debugText.canvas;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set text style
            ctx.fillStyle = '#00ff00';
            ctx.font = '20px monospace';
            ctx.textAlign = 'left';
            
            // Draw debug information
            let y = 30;
            ctx.fillText('=== FORCE PUNCH DEBUG ===', 10, y);
            y += 25;
            ctx.fillText(`Frame: ${debugInfo.frameCount}`, 10, y);
            y += 35;
            
            ctx.fillText(`LEFT HAND:`, 10, y);
            y += 25;
            ctx.fillText(`  Ready: ${debugInfo.leftHand.isReady ? 'YES' : 'NO'}`, 10, y);
            y += 20;
            ctx.fillText(`  Fist: ${debugInfo.leftHand.isFist ? 'YES' : 'NO'}`, 10, y);
            y += 20;
            ctx.fillText(`  Velocity: ${debugInfo.leftHand.velocity.toFixed(3)} (need >4.0)`, 10, y);
            y += 20;
            ctx.fillText(`  Punches: ${debugInfo.leftHand.punchCount}`, 10, y);
            y += 20;
            ctx.fillText(`  Cooldown: ${debugInfo.leftHand.cooldown.toFixed(2)}s`, 10, y);
            y += 20;
            ctx.fillText(`  Thumb: ${debugInfo.leftHand.thumbDist.toFixed(3)} (<0.16)`, 10, y);
            y += 20;
            ctx.fillText(`  Index: ${debugInfo.leftHand.indexDist.toFixed(3)} (<0.16)`, 10, y);
            y += 20;
            ctx.fillText(`  Middle: ${debugInfo.leftHand.middleDist.toFixed(3)} (<0.16)`, 10, y);
            y += 30;
            
            ctx.fillText(`RIGHT HAND:`, 10, y);
            y += 25;
            ctx.fillText(`  Ready: ${debugInfo.rightHand.isReady ? 'YES' : 'NO'}`, 10, y);
            y += 20;
            ctx.fillText(`  Fist: ${debugInfo.rightHand.isFist ? 'YES' : 'NO'}`, 10, y);
            y += 20;
            ctx.fillText(`  Velocity: ${debugInfo.rightHand.velocity.toFixed(3)} (need >4.0)`, 10, y);
            y += 20;
            ctx.fillText(`  Punches: ${debugInfo.rightHand.punchCount}`, 10, y);
            y += 20;
            ctx.fillText(`  Cooldown: ${debugInfo.rightHand.cooldown.toFixed(2)}s`, 10, y);
            y += 20;
            ctx.fillText(`  Thumb: ${debugInfo.rightHand.thumbDist.toFixed(3)} (<0.16)`, 10, y);
            y += 20;
            ctx.fillText(`  Index: ${debugInfo.rightHand.indexDist.toFixed(3)} (<0.16)`, 10, y);
            y += 20;
            ctx.fillText(`  Middle: ${debugInfo.rightHand.middleDist.toFixed(3)} (<0.16)`, 10, y);
            y += 40;
            
            // Display VR Console Log
            ctx.fillText(`=== CONSOLE LOG ===`, 10, y);
            y += 25;
            ctx.font = '14px monospace'; // Smaller font for logs
            ctx.fillStyle = '#ffff00'; // Yellow for logs
            
            for (let i = Math.max(0, vrConsoleLog.length - 12); i < vrConsoleLog.length; i++) {
                const logEntry = vrConsoleLog[i];
                if (logEntry) {
                    // Truncate long log lines to fit
                    const truncated = logEntry.length > 90 ? logEntry.substring(0, 87) + '...' : logEntry;
                    ctx.fillText(truncated, 10, y);
                    y += 16;
                }
            }
            
            // Update texture
            debugText.texture.needsUpdate = true;
        }

        // Initialize teleportation system
        function initTeleportationSystem() {
            // Create teleport reticle
            const reticleGeometry = new THREE.RingGeometry(0.2, 0.3, 16);
            const reticleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            teleportReticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            teleportReticle.visible = false;
            teleportReticle.rotation.x = -Math.PI / 2; // Flat on ground
            scene.add(teleportReticle);
            
            // Create teleport progress indicator
            const indicatorGeometry = new THREE.RingGeometry(0.1, 0.4, 16);
            const indicatorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            teleportIndicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            teleportIndicator.visible = false;
            teleportIndicator.rotation.x = -Math.PI / 2; // Flat on ground
            scene.add(teleportIndicator);
            
            // Create teleport ray line
            const rayGeometry = new THREE.BufferGeometry();
            const rayPositions = new Float32Array(6); // 2 points * 3 coordinates
            rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
            const rayMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.7,
                linewidth: 3
            });
            teleportRayLine = new THREE.Line(rayGeometry, rayMaterial);
            teleportRayLine.visible = false;
            scene.add(teleportRayLine);
            
            console.log('üöÄ Teleportation system initialized');
        }

        async function init() {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Initialize camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Create global player rig for VR movement
            window.playerRig = new THREE.Group();
            scene.add(window.playerRig);
            window.playerRig.add(camera);
            window.playerRig.position.set(0, 0, 0); // Temporarily set to origin to fix positioning
            camera.position.set(0, 1.6, 0);
            
            // Initialize renderer with Quest 3 120fps optimizations
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, // Disable for 120fps performance
                alpha: false,
                depth: true,
                stencil: false,
                powerPreference: "high-performance" // Request high-performance GPU
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio for performance
            renderer.shadowMap.enabled = false; // Disable shadows for 120fps
            renderer.outputEncoding = THREE.sRGBEncoding; // Ensure correct color space
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Optimized tone mapping
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
            
            // Initialize clock
            clock = new THREE.Clock();
            
            // Initialize particle pool for better performance
            initParticlePool();
            
            // Initialize shared materials for performance optimization
            initSharedMaterials();
            
            // Initialize teleportation indicators
            initTeleportationSystem();
            
            // Initialize debug overlay
            initDebugOverlay();
            
            // Setup WebXR with Quest 3 optimizations
            renderer.xr.enabled = true;
            
            // Enable foveated rendering for Quest 3 120fps
            if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                if (session && session.supportedFrameRates) {
                    // Request 120fps if supported
                    session.requestReferenceSpace('local').then(referenceSpace => {
                        if (session.supportedFrameRates.includes(120)) {
                            session.updateRenderState({
                                baseLayer: new XRWebGLLayer(session, renderer.context, {
                                    antialias: false, // Disable for performance
                                    alpha: false,
                                    depth: true,
                                    stencil: false,
                                    framebufferScaleFactor: 0.8 // Reduce resolution for 120fps
                                }),
                                refreshRate: 120
                            });
                            console.log('üöÄ Quest 3 120fps mode enabled with foveated rendering');
                        }
                    });
                }
            }
            
            document.body.appendChild(VRButton.createButton(renderer));
            
            // Add hand tracking with proper mesh models
            const handModelFactory = new XRHandModelFactory();
            
            // Left hand (index 0)
            hand1 = renderer.xr.getHand(0);
            const handModel1 = handModelFactory.createHandModel(hand1, 'mesh');
            handModel1.name = 'leftHandMesh';
            hand1.add(handModel1);
            window.playerRig.add(hand1);
            console.log('‚úã Left hand model created:', handModel1.type || 'mesh');
            
            // Right hand (index 1)  
            hand2 = renderer.xr.getHand(1);
            const handModel2 = handModelFactory.createHandModel(hand2, 'mesh');
            handModel2.name = 'rightHandMesh';
            hand2.add(handModel2);
            window.playerRig.add(hand2);
            console.log('‚úã Right hand model created:', handModel2.type || 'mesh');
            
            // Ensure no sphere fallback - force mesh type only
            handModel1.visible = true;
            handModel2.visible = true;
            
            // Initialize hand userData
            [hand1, hand2].forEach((hand, index) => {
                hand.userData = {
                    tipPositions: {
                        THUMB: new THREE.Vector3(),
                        INDEX: new THREE.Vector3(),
                        MIDDLE: new THREE.Vector3()
                    },
                    wristPosition: new THREE.Vector3(),
                    handCenter: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    isPinching: false,
                    isFist: false,
                    isPointing: false,
                    isReady: false,
                    heldVoxelIndex: null,
                    heldBoidIndex: null,
                    holdStartTime: 0,
                    isGrabbingBoid: false,
                    punchVelocity: 0,
                    debugHandIndex: index
                };
            });
            
            // Setup lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create boids async
            await createBoidsAsync();
            
            // Create world content async
            await Promise.all([
                createVectorGridGround(),
                createGroundVoxels(),
                createBoidsSystem(),
                createSpaceBattle()
            ]);
            
            // Setup event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Add fallback controls for desktop
            addFallbackControls();
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }

        async function createBoidsAsync() {
            for (let i = 0; i < initialBoidCount; i++) {
                const boid = new Boid(
                    new THREE.Vector3(
                        (Math.random() - 0.5) * ATMOSPHERE_RADIUS,
                        Math.random() * (ATMOSPHERE_MAX_HEIGHT - 2) + 2, // 2-28m height
                        (Math.random() - 0.5) * ATMOSPHERE_RADIUS
                    )
                );
                boids.push(boid);
                if (i % 10 === 0) await new Promise(resolve => setTimeout(resolve, 0)); // Yield to prevent blocking
            }
        }
        
        function animate() {
            update();
            render();
        }

        // Call init after all definitions
        init();
    </script>
</body>
</html>