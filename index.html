<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Boids with Glowing Tree</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; background-color: #111; color: #fff; overflow: hidden; }
        #info { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); padding: 15px 25px; background-color: rgba(0, 0, 0, 0.5); border-radius: 12px; text-align: center; font-size: 16px; z-index: 10; max-width: 90%; }
        #vr-button { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; border: 1px solid #fff; background-color: rgba(0,0,0,0.5); color: #fff; padding: 12px 24px; border-radius: 999px; cursor: pointer; font-weight: 600; }
        #vr-button:hover { background-color: rgba(255,255,255,0.2); }
        
        /* VR Mode - Specifically target UI elements only, not WebXR internals */
        .vr-active #info {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active #vr-button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active #threejs-vr-button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active div:not([id]) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        /* Ensure canvas and WebXR elements remain visible */
        .vr-active canvas {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">
        WebXR Boids: Revival, Tossing, Predators & Force Punch<br>
        Pinch voxels to revive • Grab boids to toss • Shake voxels for predators • Make fist and punch to blast!<br>
        <small>Point with right hand for 3 seconds to teleport</small>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let camera, scene, renderer, clock;
        let boids = [];
        let predators = [];
        let particles = [];
        let particlePool = []; // Object pool for particles
        const PARTICLE_POOL_SIZE = 100;
        let hand1, hand2;
        
        let interactiveVoxels = [];
        let fountainVoxels = [];
        let heldVoxelMesh1, heldVoxelMesh2;
        let fountainMesh;
        let fountainVoxelsMesh;
        let monolithPanels = [];
        let gameOfLifeGrid = [];
        let gameOfLifeRunning = false;
        let lastGameOfLifeUpdate = 0;
        const GRID_SIZE_X = 16; // Horizontal panels
        const GRID_SIZE_Y = 80; // Vertical panels (covering full monolith from top to floor)
        const GAME_OF_LIFE_SPEED = 0.3; // Updates per second (reduced for Quest performance)
        const REVIVAL_TIME = 3; 
        const SHAKE_THRESHOLD = 0.8; // Reduced shake intensity needed to create predator

        const initialBoidCount = 25; // Further reduced by 50% for better performance
        const interactiveVoxelCount = 0; // Replaced with fountain system
        const fountainVoxelCount = 30; // Increased for better fountain visibility in VR
        const fountainSpawnRate = 4; // Much faster spawn rate for dramatic VR fountain effect
        const voxelLifetime = 8; // Shorter lifetime for better performance
        const boundSize = 20;
        
        // Punch blast variables
        let punchCooldown1 = 0;
        let punchCooldown2 = 0;
        const PUNCH_COOLDOWN = 0.5; // Seconds between punches
        const PUNCH_FORCE_RADIUS = 2.0; // Radius of punch force blast
        
        // Performance optimization variables - Aggressive for 120fps Quest 3
        let frameCount = 0;
        const OPTIMIZATION_INTERVAL = 40; // Reduced frequency for 120fps
        const SPACE_UPDATE_INTERVAL = 120; // Update stars every 120 frames (1 second at 120fps)
        const ORBITAL_UPDATE_INTERVAL = 60; // Update asteroids every 60 frames (0.5 seconds)
        const PARTICLE_UPDATE_INTERVAL = 30; // Update particles every 30 frames
        const FOUNTAIN_UPDATE_INTERVAL = 20; // Update fountain every 20 frames
        
        // Level-of-Detail (LOD) system for 120fps
        const LOD_DISTANCES = {
            CLOSE: 10,    // Full detail
            MEDIUM: 30,   // Reduced detail
            FAR: 60       // Minimal detail
        };
        
        // Frame rate monitoring for dynamic scaling
        let frameRateHistory = [];
        let currentQualityLevel = 1.0; // 1.0 = full quality, 0.5 = half quality
        const TARGET_FRAME_RATE = 120;
        const MIN_FRAME_RATE = 90;
        
        // Temporal update spreading for 120fps
        let updateQueues = {
            gameOfLife: 0,
            fountain: 0,
            skyBattle: 0,
            particles: 0
        };
        const TEMPORAL_SPREAD_FRAMES = 8; // Spread updates across 8 frames
        
        // Spatial partitioning for collision detection optimization
        class SpatialGrid {
            constructor(cellSize = 5.0) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }
            
            clear() {
                this.grid.clear();
            }
            
            getKey(x, y, z) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                const gz = Math.floor(z / this.cellSize);
                return `${gx},${gy},${gz}`;
            }
            
            insert(object) {
                const key = this.getKey(object.position.x, object.position.y, object.position.z);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(object);
            }
            
            getNearby(position, radius = 1.0) {
                const nearby = [];
                const cellsToCheck = Math.ceil(radius / this.cellSize);
                
                for (let dx = -cellsToCheck; dx <= cellsToCheck; dx++) {
                    for (let dy = -cellsToCheck; dy <= cellsToCheck; dy++) {
                        for (let dz = -cellsToCheck; dz <= cellsToCheck; dz++) {
                            const key = this.getKey(
                                position.x + dx * this.cellSize,
                                position.y + dy * this.cellSize,
                                position.z + dz * this.cellSize
                            );
                            const cell = this.grid.get(key);
                            if (cell) {
                                nearby.push(...cell);
                            }
                        }
                    }
                }
                return nearby;
            }
        }
        
        const spatialGrid = new SpatialGrid(3.0); // 3 unit cells for boid flocking
        
        // Frustum culling
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();
        const CULLING_DISTANCE = 100; // Distance beyond which objects are culled
        
        // Shared materials for performance optimization
        const sharedMaterials = {
            boidMaterial: null,
            particleMaterial: null,
            starMaterial: null,
            spaceMaterial: null,
            fountainMaterial: null
        };
        
        
        // Three-layer sky system
        let stars = [];
        let asteroids = [];
        let spaceShips = [];
        let spaceBullets = [];
        let shootingStars = [];
        
        // Layer 1: Atmosphere (0-30m above user) - Boids flight zone
        const ATMOSPHERE_MIN_HEIGHT = 0;
        const ATMOSPHERE_MAX_HEIGHT = 30;
        const ATMOSPHERE_RADIUS = 40;
        
        // Layer 2: Orbital Space (30-60m above user) - Asteroids simulation
        const ORBITAL_MIN_HEIGHT = 30;
        const ORBITAL_MAX_HEIGHT = 60;
        const ORBITAL_RADIUS = 35;
        const ASTEROID_COUNT = 6;
        const SPACESHIP_COUNT = 1;
        const ASTEROID_SPEED = 5.0;
        const SPACESHIP_SPEED = 8.0;
        const SPACE_BULLET_SPEED = 8.0;
        
        // Layer 3: Space (60m+ above user) - Distant starfield
        const SPACE_MIN_HEIGHT = 60;
        const SPACE_MAX_HEIGHT = 100;
        const SPACE_RADIUS = 60;
        const STAR_COUNT = 150; // More stars for distant effect
        const SHOOTING_STAR_SPAWN_RATE = 0.05;
        const SHOOTING_STAR_SPEED = 15.0;
        
        
        // Teleportation system
        let teleportRaycaster = new THREE.Raycaster();
        let teleportIndicator = null;
        let teleportHoldStartTime = 0;
        let teleportTargetPosition = null;
        let teleportReticle = null;
        let isPointingForTeleport = false;
        const TELEPORT_HOLD_TIME = 3.0; // Seconds to hold for teleport
        const TELEPORT_SHAKE_TOLERANCE = 0.2; // Allowance for hand shake
        const TELEPORT_MAX_DISTANCE = 15; // Maximum teleport range

        // --- NEW: Obstacles for boids to avoid ---
        let obstacles = []; // Will be populated when trees are created
        
        
        
        // --- Sky Asteroids Classes ---
        class Star {
            constructor() {
                // Position in distant space layer (60m+ above user)
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * SPACE_RADIUS,
                    SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                    (Math.random() - 0.5) * SPACE_RADIUS
                );
                this.brightness = Math.random() * 0.8 + 0.2;
                this.twinkleSpeed = Math.random() * 2 + 1;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const geometry = new THREE.SphereGeometry(0.1, 6, 6); // Reduced complexity for VR performance
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: this.brightness
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(elapsedTime) {
                if (this.mesh) {
                    const twinkle = (Math.sin(elapsedTime * this.twinkleSpeed) + 1) / 2;
                    this.mesh.material.opacity = this.brightness * (0.3 + 0.7 * twinkle);
                }
            }
        }
        
        class Asteroid {
            constructor(position, size = 'large') {
                // Position in orbital space layer (30-60m above user)
                this.position = position || new THREE.Vector3(
                    (Math.random() - 0.5) * ORBITAL_RADIUS,
                    ORBITAL_MIN_HEIGHT + Math.random() * (ORBITAL_MAX_HEIGHT - ORBITAL_MIN_HEIGHT),
                    (Math.random() - 0.5) * ORBITAL_RADIUS
                );
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * ASTEROID_SPEED * 2.0, // Much more varied movement
                    (Math.random() - 0.5) * ASTEROID_SPEED * 1.2, // More dramatic Y movement
                    (Math.random() - 0.5) * ASTEROID_SPEED * 2.0
                );
                this.rotation = new THREE.Vector3(
                    Math.random() * 0.02,
                    Math.random() * 0.02,
                    Math.random() * 0.02
                );
                this.size = size; // large, medium, small
                this.health = size === 'large' ? 3 : size === 'medium' ? 2 : 1;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const sizes = { large: 2.0, medium: 1.2, small: 0.7 };
                const radius = sizes[this.size];
                
                // Create irregular asteroid shape
                const geometry = new THREE.DodecahedronGeometry(radius, 0);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x888888,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                const oldPosition = this.position.clone();
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.x += this.rotation.x;
                    this.mesh.rotation.y += this.rotation.y;
                    this.mesh.rotation.z += this.rotation.z;
                }
                
                // Wrap around orbital space boundaries (30-60m layer)
                const halfRadius = ORBITAL_RADIUS / 2;
                if (this.position.x > halfRadius) {
                    this.position.x = -halfRadius;
                }
                if (this.position.x < -halfRadius) {
                    this.position.x = halfRadius;
                }
                if (this.position.z > halfRadius) {
                    this.position.z = -halfRadius;
                }
                if (this.position.z < -halfRadius) {
                    this.position.z = halfRadius;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                
                // Enhanced debug logging for asteroid movement
                const moved = oldPosition.distanceTo(this.position) > 0.1;
                if (moved && Math.random() < 0.05) { // More frequent logging
                    console.log(`🌌 Asteroid moving: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) speed=${ASTEROID_SPEED}`);
                }
            }
            
            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    this.split();
                    return true; // Mark for removal
                }
                return false;
            }
            
            split() {
                if (this.size === 'large') {
                    // Split into 2 medium asteroids
                    for (let i = 0; i < 2; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        const newAsteroid = new Asteroid(this.position.clone().add(offset), 'medium');
                        asteroids.push(newAsteroid);
                    }
                } else if (this.size === 'medium') {
                    // Split into 2 small asteroids
                    for (let i = 0; i < 2; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 1,
                            (Math.random() - 0.5) * 1,
                            (Math.random() - 0.5) * 1
                        );
                        const newAsteroid = new Asteroid(this.position.clone().add(offset), 'small');
                        asteroids.push(newAsteroid);
                    }
                }
                
                this.destroy();
                console.log(`💥 ${this.size} asteroid destroyed!`);
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        class SpaceShip {
            constructor() {
                // Position in orbital space layer (30-60m above user)
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * ORBITAL_RADIUS,
                    ORBITAL_MIN_HEIGHT + Math.random() * (ORBITAL_MAX_HEIGHT - ORBITAL_MIN_HEIGHT),
                    (Math.random() - 0.5) * ORBITAL_RADIUS
                );
                this.velocity = new THREE.Vector3();
                this.rotation = Math.random() * Math.PI * 2;
                this.angularVelocity = 0;
                this.target = null;
                this.lastFireTime = 0;
                this.mesh = null;
                this.thrust = false;
                
                this.createMesh();
            }
            
            createMesh() {
                const shipGroup = new THREE.Group();
                
                // Appropriately sized triangular ship shape for VR
                const shipGeometry = new THREE.ConeGeometry(1.0, 3.0, 3); // Reasonable size for VR visibility
                const shipMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 1.0,
                    emissive: 0x006666
                });
                const ship = new THREE.Mesh(shipGeometry, shipMaterial);
                ship.rotation.x = Math.PI / 2; // Point forward
                shipGroup.add(ship);
                
                // Add bright markers for visibility
                const markerGeometry = new THREE.SphereGeometry(0.6, 6, 6); // Reduced complexity for VR performance
                const markerMaterial = new THREE.MeshLambertMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00,
                    transparent: true,
                    opacity: 1.0
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.y = 1.0;
                shipGroup.add(marker);
                
                // Add pulsing effect marker
                const pulseGeometry = new THREE.SphereGeometry(0.5, 6, 6);
                const pulseMaterial = new THREE.MeshLambertMaterial({
                    color: 0xff0080,
                    emissive: 0xff0080,
                    transparent: true,
                    opacity: 0.5
                });
                const pulseMarker = new THREE.Mesh(pulseGeometry, pulseMaterial);
                pulseMarker.position.y = 1.0;
                shipGroup.add(pulseMarker);
                this.pulseMarker = pulseMarker;
                
                this.mesh = shipGroup;
                this.mesh.position.copy(this.position);
                this.mesh.visible = true;
                scene.add(shipGroup);
                
                console.log('Enhanced spaceship created with maximum visibility');
            }
            
            update(deltaTime, elapsedTime) {
                // Find nearest asteroid
                this.findTarget();
                
                // AI behavior
                this.updateAI(deltaTime);
                
                // Update physics
                const oldPosition = this.position.clone();
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.rotation += this.angularVelocity * deltaTime;
                
                // Apply drag
                this.velocity.multiplyScalar(0.98);
                this.angularVelocity *= 0.95;
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.y = this.rotation;
                    
                    // Add pulsing effect to marker
                    if (this.pulseMarker) {
                        const pulseScale = 1.0 + Math.sin(elapsedTime * 4.0) * 0.3;
                        this.pulseMarker.scale.setScalar(pulseScale);
                    }
                    
                    // Enhanced debug logging for spaceship movement
                    const moved = oldPosition.distanceTo(this.position) > 0.1;
                    if (moved && Math.random() < 0.05) { // More frequent logging
                        console.log(`🚀 Spaceship moving: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) target=${this.target ? 'YES' : 'NO'}`);
                    }
                }
                
                // Wrap around orbital space boundaries (30-60m layer)
                const halfRadius = ORBITAL_RADIUS / 2;
                if (this.position.x > halfRadius) {
                    this.position.x = -halfRadius;
                }
                if (this.position.x < -halfRadius) {
                    this.position.x = halfRadius;
                }
                if (this.position.z > halfRadius) {
                    this.position.z = -halfRadius;
                }
                if (this.position.z < -halfRadius) {
                    this.position.z = halfRadius;
                }
                if (this.position.y < ORBITAL_MIN_HEIGHT) {
                    this.position.y = ORBITAL_MAX_HEIGHT;
                }
                if (this.position.y > ORBITAL_MAX_HEIGHT) {
                    this.position.y = ORBITAL_MIN_HEIGHT;
                }
                
                // Try to fire
                this.tryFire(elapsedTime);
            }
            
            findTarget() {
                let closestAsteroid = null;
                let closestDistance = 40; // Much longer detection range to match firing range
                
                // Debug: Check if we have asteroids
                if (Math.random() < 0.01) {
                    console.log(`🔍 Spaceship checking ${asteroids.length} asteroids for targets...`);
                }
                
                for (const asteroid of asteroids) {
                    if (!asteroid || asteroid.health <= 0) continue;
                    const distance = this.position.distanceTo(asteroid.position);
                    if (distance < closestDistance) {
                        closestAsteroid = asteroid;
                        closestDistance = distance;
                    }
                }
                
                // Debug target acquisition
                if (this.target !== closestAsteroid) {
                    if (closestAsteroid) {
                        console.log(`🎯 Spaceship acquired new target at distance ${closestDistance.toFixed(1)}`);
                    } else if (this.target) {
                        console.log(`❌ Spaceship lost target`);
                    }
                }
                
                this.target = closestAsteroid;
            }
            
            updateAI(deltaTime) {
                if (this.target) {
                    const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                    const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                    
                    // Turn towards target
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    this.angularVelocity += Math.sign(angleDiff) * 0.1;
                    
                    // Always thrust towards target - more aggressive behavior
                    const thrustForce = new THREE.Vector3(
                        Math.sin(this.rotation),
                        0,
                        Math.cos(this.rotation)
                    ).multiplyScalar(SPACESHIP_SPEED * deltaTime * 6.0); // Even higher thrust for dramatic movement
                    
                    this.velocity.add(thrustForce);
                    this.thrust = true;
                    
                    // Much more aggressive turning for faster target acquisition
                    this.angularVelocity += Math.sign(angleDiff) * 0.4;
                } else {
                    // More active patrol when no target
                    if (Math.random() < 0.02) {
                        this.angularVelocity += (Math.random() - 0.5) * 0.8;
                    }
                    if (Math.random() < 0.01) {
                        const thrustForce = new THREE.Vector3(
                            Math.sin(this.rotation),
                            0,
                            Math.cos(this.rotation)
                        ).multiplyScalar(SPACESHIP_SPEED * deltaTime * 2.0); // Faster patrol movement
                        
                        this.velocity.add(thrustForce);
                    }
                }
            }
            
            tryFire(elapsedTime) {
                if (!this.target) return;
                if (elapsedTime - this.lastFireTime < 0.3) return; // Faster fire rate
                
                const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                const distance = toTarget.length();
                
                // Fire if target is within range and roughly aimed
                if (distance < 25) { // Much longer firing range for more action
                    const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Very lenient aiming requirement for more action
                    if (Math.abs(angleDiff) < Math.PI / 3) { // 60 degree cone instead of 30
                        this.fire();
                        this.lastFireTime = elapsedTime;
                        console.log(`🚀 Spaceship firing at asteroid! Distance: ${distance.toFixed(1)} units`);
                    }
                }
            }
            
            fire() {
                const bulletStart = this.position.clone();
                const direction = new THREE.Vector3(
                    Math.sin(this.rotation),
                    0,
                    Math.cos(this.rotation)
                );
                
                const bullet = new SpaceBullet(bulletStart, direction, this);
                spaceBullets.push(bullet);
                
                console.log('🚀 Space ship fired!');
            }
        }
        
        class SpaceBullet {
            constructor(position, direction, shooter) {
                this.position = position.clone();
                this.velocity = direction.clone().multiplyScalar(SPACE_BULLET_SPEED);
                this.shooter = shooter;
                this.life = 3.0; // Seconds
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const geometry = new THREE.SphereGeometry(0.08, 4, 4); // Further reduced for performance
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: 1.0
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.life -= deltaTime;
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                }
                
                // Check collision with asteroids
                for (const asteroid of asteroids) {
                    const distance = this.position.distanceTo(asteroid.position);
                    const hitRadius = asteroid.size === 'large' ? 2.0 : asteroid.size === 'medium' ? 1.2 : 0.7;
                    
                    if (distance < hitRadius) {
                        asteroid.takeDamage();
                        this.explode();
                        return true; // Mark for removal
                    }
                }
                
                // Remove if life expired or out of bounds
                if (this.life <= 0 || Math.abs(this.position.x) > SKY_RADIUS * 2) {
                    this.destroy();
                    return true; // Mark for removal
                }
                
                return false;
            }
            
            explode() {
                // Create small explosion effect
                createSpaceExplosion(this.position.clone());
                this.destroy();
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        class ShootingStar {
            constructor() {
                // Start from random edge of space layer area
                const side = Math.floor(Math.random() * 4);
                const spaceSize = SPACE_RADIUS * 1.5;
                
                // Position in space layer (60m+ above user)
                switch(side) {
                    case 0: // Top
                        this.position = new THREE.Vector3(
                            (Math.random() - 0.5) * spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            spaceSize
                        );
                        break;
                    case 1: // Right
                        this.position = new THREE.Vector3(
                            spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            (Math.random() - 0.5) * spaceSize
                        );
                        break;
                    case 2: // Bottom
                        this.position = new THREE.Vector3(
                            (Math.random() - 0.5) * spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            -spaceSize
                        );
                        break;
                    case 3: // Left
                        this.position = new THREE.Vector3(
                            -spaceSize,
                            SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT),
                            (Math.random() - 0.5) * spaceSize
                        );
                        break;
                }
                
                // Create velocity toward opposite side within space layer
                const targetX = (Math.random() - 0.5) * spaceSize;
                const targetY = SPACE_MIN_HEIGHT + Math.random() * (SPACE_MAX_HEIGHT - SPACE_MIN_HEIGHT);
                const targetZ = (Math.random() - 0.5) * spaceSize;
                
                const direction = new THREE.Vector3(targetX, targetY, targetZ).sub(this.position);
                direction.normalize();
                this.velocity = direction.multiplyScalar(SHOOTING_STAR_SPEED);
                
                this.life = 4.0; // Seconds
                this.brightness = 0.8 + Math.random() * 0.2;
                this.mesh = null;
                this.trailParticles = [];
                
                this.createMesh();
            }
            
            createMesh() {
                const starGeometry = new THREE.SphereGeometry(0.15, 4, 4); // Reduced complexity for background stars
                const starMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffaa,
                    transparent: true,
                    opacity: this.brightness
                });
                this.mesh = new THREE.Mesh(starGeometry, starMaterial);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime, elapsedTime) {
                // Update position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.life -= deltaTime;
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // Fade out as life decreases
                    const lifeFactor = Math.max(0, this.life / 4.0);
                    this.mesh.material.opacity = this.brightness * lifeFactor;
                }
                
                // Create trail particles
                this.createTrailParticle(elapsedTime);
                
                // Update trail particles
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    const particle = this.trailParticles[i];
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        if (particle.mesh) {
                            scene.remove(particle.mesh);
                        }
                        this.trailParticles.splice(i, 1);
                    } else {
                        // Fade trail particle
                        if (particle.mesh) {
                            particle.mesh.material.opacity = particle.life / 1.0;
                        }
                    }
                }
                
                // Remove if life expired
                return this.life <= 0;
            }
            
            createTrailParticle(elapsedTime) {
                // Create trail particle every few frames
                if (Math.random() < 0.3) {
                    const trailGeometry = new THREE.SphereGeometry(0.05, 3, 3); // Minimal for trail particles
                    const trailMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                    trailMesh.position.copy(this.position);
                    scene.add(trailMesh);
                    
                    this.trailParticles.push({
                        mesh: trailMesh,
                        life: 1.0 // Trail particles live for 1 second
                    });
                }
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
                
                // Clean up trail particles
                for (const particle of this.trailParticles) {
                    if (particle.mesh) {
                        scene.remove(particle.mesh);
                    }
                }
                this.trailParticles = [];
            }
        }
        
        
        
        // --- Predator Class ---
        class Predator {
            constructor(position, color) {
                this.position = position || new THREE.Vector3();
                this.velocity = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.velocity.setLength(Math.random() * 0.3 + 0.2);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.05;
                this.maxSpeed = 0.105; // Reduced by 30% to match boid speed reduction
                this.huntRadius = 4.0;
                this.color = color || new THREE.Color(0xff0000);
                this.isGrabbed = false;
            }
            
            update() {
                if (this.isGrabbed) return;
                
                this.position.add(this.velocity);
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.acceleration.multiplyScalar(0);
            }
            
            applyForce(force) {
                if (!this.isGrabbed) {
                    this.acceleration.add(force);
                }
            }
            
            hunt(boids) {
                if (!boids || !Array.isArray(boids)) {
                    return;
                }
                
                let closest = null;
                let closestDist = Infinity;
                
                for (let boid of boids) {
                    if (!boid || boid.isGrabbed) continue;
                    let d = this.position.distanceTo(boid.position);
                    if (d < this.huntRadius && d < closestDist) {
                        closest = boid;
                        closestDist = d;
                    }
                }
                
                if (closest) {
                    let huntForce = this.seek(closest.position);
                    huntForce.multiplyScalar(2.0); // Strong hunting drive
                    this.applyForce(huntForce);
                }
            }
            
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.normalize();
                desired.multiplyScalar(this.maxSpeed);
                let steer = desired.sub(this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            
            checkBounds() {
                if (this.isGrabbed) return;
                
                const halfRadius = ATMOSPHERE_RADIUS / 2;
                const turnFactor = 0.7;
                
                // Constrain to atmosphere layer (0-30m height)
                if (this.position.x > halfRadius) this.velocity.x -= turnFactor;
                if (this.position.x < -halfRadius) this.velocity.x += turnFactor;
                if (this.position.y > ATMOSPHERE_MAX_HEIGHT) this.velocity.y -= turnFactor;
                if (this.position.y < ATMOSPHERE_MIN_HEIGHT + 0.5) this.velocity.y += turnFactor;
                if (this.position.z > halfRadius) this.velocity.z -= turnFactor;
                if (this.position.z < -halfRadius) this.velocity.z += turnFactor;
            }
        }
        
        // --- Boid Class ---
        class Boid {
            constructor(position) {
                this.position = position || new THREE.Vector3(
                    Math.random() * boundSize - boundSize / 2,
                    Math.random() * (boundSize / 2) + 1,
                    Math.random() * boundSize - boundSize / 2
                );
                this.velocity = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                );
                this.velocity.setLength(Math.random() * 0.5 + 0.5);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.03;
                this.maxSpeed = 0.07; // Reduced by 30% for better performance
                this.isGrabbed = false;
                this.isBeingTossed = false;
                this.tossStartTime = 0;
                this.tossVelocity = new THREE.Vector3();
                this.originalVelocity = new THREE.Vector3();
            }
            
            update() {
                if (this.isGrabbed) return;
                
                if (this.isBeingTossed) {
                    this.handleTossedMovement();
                } else {
                    this.position.add(this.velocity);
                    this.velocity.add(this.acceleration);
                    this.velocity.clampLength(0, this.maxSpeed);
                    this.acceleration.multiplyScalar(0);
                }
            }
            
            handleTossedMovement() {
                const tossTime = clock.getElapsedTime() - this.tossStartTime;
                const transitionTime = 1.0; // Time to transition from toss to flight
                
                if (tossTime < transitionTime) {
                    // Newtonian trajectory with gravity
                    const gravity = new THREE.Vector3(0, -9.8, 0);
                    this.position.add(this.tossVelocity.clone().multiplyScalar(0.016)); // ~60fps
                    this.tossVelocity.add(gravity.clone().multiplyScalar(0.016));
                    
                    // Gradually blend back to boid behavior
                    const blendFactor = tossTime / transitionTime;
                    this.velocity.lerpVectors(this.tossVelocity, this.originalVelocity, blendFactor);
                } else {
                    // Return to normal boid behavior
                    this.isBeingTossed = false;
                    this.velocity.copy(this.originalVelocity);
                }
            }
            
            applyForce(force) {
                if (!this.isGrabbed && !this.isBeingTossed) {
                    this.acceleration.add(force);
                }
            }
            
            // --- MODIFIED: flock method now includes obstacle avoidance and predator fleeing ---
            flock(boids, hands, obstacles, predators) {
                let fleeForce = this.fleeFromHands(hands);
                let predatorFleeForce = this.fleeFromPredators(predators);
                let avoidForce = this.avoid(obstacles);
                let separation = this.separate(boids);
                let alignment = this.align(boids);
                let cohesion = this.cohere(boids);

                // Weight forces
                fleeForce.multiplyScalar(5.0);
                predatorFleeForce.multiplyScalar(8.0); // Very strong predator avoidance
                avoidForce.multiplyScalar(3.0);
                separation.multiplyScalar(1.5);
                alignment.multiplyScalar(1.0);
                cohesion.multiplyScalar(1.0);
                
                this.applyForce(fleeForce);
                this.applyForce(predatorFleeForce);
                this.applyForce(avoidForce);
                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }
            
            // --- NEW: Steer away from obstacles ---
            avoid(obstacles) {
                let steer = new THREE.Vector3();
                for (let obstacle of obstacles) {
                    let d = this.position.distanceTo(obstacle.position);
                    if (d < obstacle.radius) {
                        let diff = new THREE.Vector3().subVectors(this.position, obstacle.position);
                        diff.normalize();
                        diff.divideScalar(d); // Weight by distance
                        steer.add(diff);
                    }
                }
                if (steer.length() > 0) {
                    steer.normalize();
                    steer.multiplyScalar(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }

            fleeFromHands(hands) {
                let fleeForce = new THREE.Vector3();
                for (const hand of hands) {
                    if (hand.userData.isReady && !hand.userData.isGrabbingBoid) {
                        fleeForce.add(this.flee(hand.userData.tipPositions.MIDDLE));
                    }
                }
                return fleeForce;
            }
            
            fleeFromPredators(predators) {
                let fleeForce = new THREE.Vector3();
                if (!predators || !Array.isArray(predators)) {
                    return fleeForce;
                }
                for (const predator of predators) {
                    if (!predator || predator.isGrabbed) continue;
                    let d = this.position.distanceTo(predator.position);
                    if (d < 3.0) { // Flee radius from predators
                        let flee = this.flee(predator.position);
                        flee.multiplyScalar(3.0); // Strong flee response
                        fleeForce.add(flee);
                    }
                }
                return fleeForce;
            }
            separate(boids) {
                let desiredSeparation = 0.8;
                let steer = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < desiredSeparation)) {
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                }
                
                if (count > 0) {
                    steer.divideScalar(count);
                    steer.normalize();
                    steer.multiplyScalar(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }
            align(boids) {
                let neighborDist = 2.5;
                let sum = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divideScalar(count);
                    sum.normalize();
                    sum.multiplyScalar(this.maxSpeed);
                    let steer = sum.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                    return steer;
                } else {
                    return new THREE.Vector3();
                }
            }
            cohere(boids) {
                let neighborDist = 3;
                let sum = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.add(other.position);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divideScalar(count);
                    return this.seek(sum);
                } else {
                    return new THREE.Vector3();
                }
            }
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.normalize();
                desired.multiplyScalar(this.maxSpeed);
                let steer = desired.sub(this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            flee(target) {
                const fleeRadius = 1.5;
                let steer = new THREE.Vector3();
                let d = this.position.distanceTo(target);
                if (d < fleeRadius) {
                    let desired = new THREE.Vector3().subVectors(this.position, target);
                    desired.normalize();
                    desired.multiplyScalar(this.maxSpeed);
                    steer = desired.sub(this.velocity);
                    steer.clampLength(0, this.maxForce * 2.0);
                }
                return steer;
            }
            checkBounds() {
                if (this.isGrabbed) return;
                
                const halfBound = boundSize / 2;
                const turnFactor = 0.5;
                
                if (this.position.x > halfBound) this.velocity.x -= turnFactor;
                if (this.position.x < -halfBound) this.velocity.x += turnFactor;
                if (this.position.y > 8) this.velocity.y -= turnFactor; // Max Y=8, well below asteroids at Y=11.8
                if (this.position.y < 0.1) this.velocity.y += turnFactor;
                if (this.position.z > halfBound) this.velocity.z -= turnFactor;
                if (this.position.z < -halfBound) this.velocity.z += turnFactor;
            }
        }

        function addFallbackControls() {
            const fallbackDiv = document.createElement('div');
            fallbackDiv.style.position = 'absolute';
            fallbackDiv.style.bottom = '20px';
            fallbackDiv.style.left = '50%';
            fallbackDiv.style.transform = 'translateX(-50%)';
            fallbackDiv.style.padding = '12px 24px';
            fallbackDiv.style.backgroundColor = 'rgba(255, 100, 100, 0.8)';
            fallbackDiv.style.color = 'white';
            fallbackDiv.style.borderRadius = '8px';
            fallbackDiv.style.fontSize = '14px';
            fallbackDiv.textContent = 'VR not supported - use mouse to look around';
            document.body.appendChild(fallbackDiv);
            
            // Add basic mouse controls for fallback
            let mouseX = 0, mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                camera.position.x = mouseX * 5;
                camera.position.y = mouseY * 3 + 1.6;
                camera.lookAt(0, 2, 0);
            });
        }

        function createVectorGridGround() {
            // Create a simple, clean grid to avoid aliasing artifacts
            const gridSize = 80; // Smaller for better performance
            const divisions = 40; // Fewer divisions to reduce aliasing
            const gridHelper = new THREE.GridHelper(gridSize, divisions);
            
            // Simple cyan color without transparency to avoid artifacts
            gridHelper.material.color.setHex(0x004444);
            gridHelper.material.opacity = 0.5;
            gridHelper.material.transparent = true;
            gridHelper.position.y = 0; // Exactly at ground level
            
            scene.add(gridHelper);
            
            console.log('🌐 Created simplified grid ground');
        }

        function createTronTrees() {
            const treeConfigs = [
                // Central tree - tall crystalline structure
                {
                    position: new THREE.Vector3(0, 0, 0),
                    trunkGeometry: new THREE.CylinderGeometry(0.2, 0.4, 5, 6),
                    canopyGeometry: new THREE.ConeGeometry(3, 4, 8),
                    trunkColor: 0x00ffff,
                    canopyColor: 0x00ff88,
                    lightColor: 0x00ffaa,
                    lightIntensity: 6,
                    trunkHeight: 2.5,
                    canopyHeight: 6
                },
                // Pyramid tree - left side
                {
                    position: new THREE.Vector3(-8, 0, -3),
                    trunkGeometry: new THREE.BoxGeometry(0.6, 3, 0.6),
                    canopyGeometry: new THREE.TetrahedronGeometry(2.5, 1),
                    trunkColor: 0xff00ff,
                    canopyColor: 0xff0088,
                    lightColor: 0xff00aa,
                    lightIntensity: 4,
                    trunkHeight: 1.5,
                    canopyHeight: 4
                },
                // Octahedron tree - right side
                {
                    position: new THREE.Vector3(6, 0, -6),
                    trunkGeometry: new THREE.CylinderGeometry(0.15, 0.25, 4, 8),
                    canopyGeometry: new THREE.OctahedronGeometry(2.2, 1),
                    trunkColor: 0x0088ff,
                    canopyColor: 0x0066ff,
                    lightColor: 0x0088ff,
                    lightIntensity: 4,
                    trunkHeight: 2,
                    canopyHeight: 4.5
                },
                // Dodecahedron tree - back left
                {
                    position: new THREE.Vector3(-4, 0, 8),
                    trunkGeometry: new THREE.CylinderGeometry(0.3, 0.3, 2.5, 12),
                    canopyGeometry: new THREE.DodecahedronGeometry(2, 0),
                    trunkColor: 0xffaa00,
                    canopyColor: 0xff8800,
                    lightColor: 0xffaa00,
                    lightIntensity: 3,
                    trunkHeight: 1.25,
                    canopyHeight: 3.5
                },
                // Icosahedron tree - back right  
                {
                    position: new THREE.Vector3(3, 0, 6),
                    trunkGeometry: new THREE.CylinderGeometry(0.1, 0.2, 3.5, 6),
                    canopyGeometry: new THREE.IcosahedronGeometry(1.8, 1),
                    trunkColor: 0x88ff00,
                    canopyColor: 0x66ff00,
                    lightColor: 0x88ff00,
                    lightIntensity: 3,
                    trunkHeight: 1.75,
                    canopyHeight: 3.5
                }
            ];
            
            treeConfigs.forEach(config => {
                const tree = new THREE.Group();
                tree.position.copy(config.position);
                
                // Create trunk
                const trunkMat = new THREE.MeshBasicMaterial({ 
                    color: config.trunkColor, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const trunk = new THREE.Mesh(config.trunkGeometry, trunkMat);
                trunk.position.y = config.trunkHeight;
                tree.add(trunk);
                
                // Create canopy
                const canopyMat = new THREE.MeshBasicMaterial({ 
                    color: config.canopyColor, 
                    transparent: true, 
                    opacity: 0.25 
                });
                const canopy = new THREE.Mesh(config.canopyGeometry, canopyMat);
                canopy.position.y = config.canopyHeight;
                tree.add(canopy);
                
                // Create wireframe overlays for Tron effect
                const wireframeMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const trunkWireframe = new THREE.Mesh(config.trunkGeometry, wireframeMat);
                trunkWireframe.position.copy(trunk.position);
                tree.add(trunkWireframe);
                
                const canopyWireframe = new THREE.Mesh(config.canopyGeometry, wireframeMat);
                canopyWireframe.position.copy(canopy.position);
                tree.add(canopyWireframe);
                
                // Add glowing light
                const treeLight = new THREE.PointLight(config.lightColor, config.lightIntensity, 12);
                treeLight.position.y = config.canopyHeight;
                tree.add(treeLight);
                
                // Add to obstacles array
                obstacles.push(
                    { position: new THREE.Vector3().copy(config.position).add(new THREE.Vector3(0, config.trunkHeight, 0)), radius: 0.5 },
                    { position: new THREE.Vector3().copy(config.position).add(new THREE.Vector3(0, config.canopyHeight, 0)), radius: 2.5 }
                );
                
                scene.add(tree);
            });
        }
        
        function createFountain() {
            const fountain = new THREE.Group();
            fountain.position.set(-2, 0, 2); // Position near user spawn
            
            // Base pedestal
            const baseGeometry = new THREE.CylinderGeometry(2, 2.5, 0.5, 12);
            const baseMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x004466, 
                transparent: true, 
                opacity: 0.3 
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.25;
            fountain.add(base);
            
            // Base wireframe
            const baseWireframe = new THREE.Mesh(baseGeometry, new THREE.MeshBasicMaterial({ 
                color: 0x00aaff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.8 
            }));
            baseWireframe.position.copy(base.position);
            fountain.add(baseWireframe);
            
            // Central pillar
            const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const pillarMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x0066aa,
                transparent: true, 
                opacity: 0.4 
            });
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.y = 1.5;
            fountain.add(pillar);
            
            // Pillar wireframe
            const pillarWireframe = new THREE.Mesh(pillarGeometry, new THREE.MeshBasicMaterial({ 
                color: 0x00ddff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.9 
            }));
            pillarWireframe.position.copy(pillar.position);
            fountain.add(pillarWireframe);
            
            // Ornamental top crystal
            const crystalGeometry = new THREE.OctahedronGeometry(0.4, 1);
            const crystalMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.6 
            });
            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
            crystal.position.y = 2.8;
            fountain.add(crystal);
            
            // Crystal wireframe
            const crystalWireframe = new THREE.Mesh(crystalGeometry, new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                wireframe: true 
            }));
            crystalWireframe.position.copy(crystal.position);
            fountain.add(crystalWireframe);
            
            // Glowing light
            const fountainLight = new THREE.PointLight(0x00ccff, 8, 20);
            fountainLight.position.y = 2.8;
            fountain.add(fountainLight);
            
            // Add floating ring elements
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const ringGeometry = new THREE.TorusGeometry(0.15, 0.03, 6, 12);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff, 
                    transparent: true, 
                    opacity: 0.7 
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(
                    Math.cos(angle) * 1.2,
                    0.8 + Math.sin(i) * 0.2,
                    Math.sin(angle) * 1.2
                );
                ring.rotation.x = Math.PI / 2 + Math.sin(i) * 0.3;
                fountain.add(ring);
            }
            
            scene.add(fountain);
            
            // Store fountain position for voxel spawning
            window.fountainPosition = new THREE.Vector3(-2, 2.8, 2);
            
            // Create fountain voxel system
            const voxelSize = 0.08;
            const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
            const voxelMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ffff, 
                transparent: true,
                opacity: 0.9,
                emissive: 0x002244
            });
            
            // Create instanced mesh for fountain voxels
            fountainVoxelsMesh = new THREE.InstancedMesh(voxelGeometry, voxelMaterial, fountainVoxelCount);
            fountainVoxelsMesh.name = "fountain_voxels";
            fountainVoxelsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(fountainVoxelsMesh);
            
            // Initialize fountain voxels array
            for (let i = 0; i < fountainVoxelCount; i++) {
                fountainVoxels.push(null);
            }
            
            // Initialize fountain spawn timing
            window.lastFountainSpawn = 0;
            
            console.log(`💧 Created fountain voxel system with ${fountainVoxelCount} voxels`);
        }
        
        function createBoidsSystem() {
            // Create geometry and material for boids
            const boidSize = 0.15; // Larger for better VR visibility
            const boidGeometry = new THREE.BoxGeometry(boidSize, boidSize, boidSize);
            const boidMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ffaa, 
                transparent: true,
                opacity: 0.9,
                emissive: 0x002244
            });
            
            // Create instanced mesh for boids
            const boidsMesh = new THREE.InstancedMesh(boidGeometry, boidMaterial, initialBoidCount);
            boidsMesh.name = 'alive_voxels';
            boidsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(boidsMesh);
            
            // Initialize all boids with default matrices
            const dummy = new THREE.Object3D();
            for (let i = 0; i < initialBoidCount; i++) {
                dummy.position.set(0, -1000, 0); // Start hidden
                dummy.updateMatrix();
                boidsMesh.setMatrixAt(i, dummy.matrix);
            }
            boidsMesh.instanceMatrix.needsUpdate = true;
            
            // Create held voxel meshes for both hands
            heldVoxelMesh1 = new THREE.Mesh(boidGeometry, boidMaterial.clone());
            heldVoxelMesh1.visible = false;
            heldVoxelMesh1.position.set(0, -1000, 0);
            scene.add(heldVoxelMesh1);
            
            heldVoxelMesh2 = new THREE.Mesh(boidGeometry, boidMaterial.clone());
            heldVoxelMesh2.visible = false;
            heldVoxelMesh2.position.set(0, -1000, 0);
            scene.add(heldVoxelMesh2);
            
            console.log(`🐦 Created boids system with ${initialBoidCount} boids`);
        }
        
        function addGliderPattern(startX, startY) {
            // Classic glider pattern
            const glider = [
                [0, 1, 0],
                [0, 0, 1],
                [1, 1, 1]
            ];
            
            for (let y = 0; y < glider.length; y++) {
                for (let x = 0; x < glider[y].length; x++) {
                    const gridX = startX + x;
                    const gridY = startY + y;
                    if (gridX >= 0 && gridX < GRID_SIZE_X && gridY >= 0 && gridY < GRID_SIZE_Y) {
                        gameOfLifeGrid[gridX][gridY] = glider[y][x] === 1;
                        if (monolithPanels[gridX] && monolithPanels[gridX][gridY]) {
                            updatePanelAppearance(monolithPanels[gridX][gridY], glider[y][x] === 1);
                        }
                    }
                }
            }
        }
        
        function addOscillatorPattern(startX, startY) {
            // Blinker oscillator pattern
            const blinker = [
                [1],
                [1],
                [1]
            ];
            
            for (let y = 0; y < blinker.length; y++) {
                for (let x = 0; x < blinker[y].length; x++) {
                    const gridX = startX + x;
                    const gridY = startY + y;
                    if (gridX >= 0 && gridX < GRID_SIZE_X && gridY >= 0 && gridY < GRID_SIZE_Y) {
                        gameOfLifeGrid[gridX][gridY] = blinker[y][x] === 1;
                        if (monolithPanels[gridX] && monolithPanels[gridX][gridY]) {
                            updatePanelAppearance(monolithPanels[gridX][gridY], blinker[y][x] === 1);
                        }
                    }
                }
            }
        }
        
        function initializeGameOfLife() {
            // Initialize grid with some interesting starting patterns
            for (let x = 0; x < GRID_SIZE_X; x++) {
                gameOfLifeGrid[x] = [];
                for (let y = 0; y < GRID_SIZE_Y; y++) {
                    gameOfLifeGrid[x][y] = false;
                }
            }
            
            // Add some classic Conway patterns automatically throughout the height
            addGliderPattern(2, 2);
            addGliderPattern(12, 8);
            addOscillatorPattern(8, 15);
            addGliderPattern(4, 25);
            addOscillatorPattern(10, 35);
            addGliderPattern(6, 45);
            addOscillatorPattern(2, 55);
            addGliderPattern(11, 65);
            addOscillatorPattern(7, 75);
            
            // Start the game automatically
            gameOfLifeRunning = true;
            console.log('🎮 Game of Life started with predefined patterns!');
        }
        
        function createGameOfLifeMonolith() {
            const monolith = new THREE.Group();
            monolith.position.set(10, 0, -5); // Position away from other structures
            
            // Main monolith structure - tall and imposing
            const monolithGeometry = new THREE.BoxGeometry(0.8, 12, 3);
            const monolithMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x001133, 
                transparent: true, 
                opacity: 0.4 
            });
            const monolithCore = new THREE.Mesh(monolithGeometry, monolithMaterial);
            monolithCore.position.y = 6;
            monolith.add(monolithCore);
            
            // Monolith wireframe
            const monolithWireframe = new THREE.Mesh(monolithGeometry, new THREE.MeshBasicMaterial({ 
                color: 0x0055aa, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.6 
            }));
            monolithWireframe.position.copy(monolithCore.position);
            monolith.add(monolithWireframe);
            
            // Base platform
            const baseGeometry = new THREE.CylinderGeometry(2, 2.5, 1, 8);
            const baseMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x002244, 
                transparent: true, 
                opacity: 0.5 
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.5;
            monolith.add(base);
            
            // Base wireframe
            const baseWireframe = new THREE.Mesh(baseGeometry, new THREE.MeshBasicMaterial({ 
                color: 0x00aaff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.8 
            }));
            baseWireframe.position.copy(base.position);
            monolith.add(baseWireframe);
            
            // Create light panel grid
            createLightPanelGrid(monolith);
            
            // Add ambient lighting
            const monolithLight = new THREE.PointLight(0x0066ff, 6, 25);
            monolithLight.position.set(0, 8, 2);
            monolith.add(monolithLight);
            
            scene.add(monolith);
            
            // Initialize Game of Life grid
            initializeGameOfLife();
        }
        
        function createLightPanelGrid(monolith) {
            const panelSize = 0.12;
            const panelSpacing = 0.15;
            const gridWidth = GRID_SIZE_X * panelSpacing;
            const gridHeight = GRID_SIZE_Y * panelSpacing;
            
            // Position grid to cover entire monolith from top to floor
            const gridStartX = -gridWidth / 2 + panelSpacing / 2;
            const gridStartY = 12 - panelSpacing / 2; // Start from very top
            const gridZ = 1.6; // Just in front of monolith face
            
            for (let x = 0; x < GRID_SIZE_X; x++) {
                monolithPanels[x] = [];
                for (let y = 0; y < GRID_SIZE_Y; y++) {
                    // Create panel geometry
                    const panelGeometry = new THREE.PlaneGeometry(panelSize, panelSize);
                    const panelMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x001122,
                        emissive: 0x000000,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    panel.position.set(
                        gridStartX + x * panelSpacing,
                        gridStartY - y * panelSpacing,
                        gridZ
                    );
                    
                    // Store grid coordinates in userData
                    panel.userData = { gridX: x, gridY: y, isAlive: false };
                    
                    monolith.add(panel);
                    monolithPanels[x][y] = panel;
                    
                    // Add subtle wireframe border
                    const borderGeometry = new THREE.EdgesGeometry(panelGeometry);
                    const borderMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x004466, 
                        transparent: true, 
                        opacity: 0.5 
                    });
                    const border = new THREE.LineSegments(borderGeometry, borderMaterial);
                    border.position.copy(panel.position);
                    border.position.z += 0.001; // Slightly in front
                    monolith.add(border);
                }
            }
        }

        function handleGameOfLifeTouch(hand) {
            try {
                if (!hand.userData.isReady || !hand.userData.tipPositions.INDEX) return;
                
                const touchPosition = hand.userData.tipPositions.INDEX;
                const touchRadius = 0.08;
                
                // Check each panel for touch
                for (let x = 0; x < GRID_SIZE_X; x++) {
                    for (let y = 0; y < GRID_SIZE_Y; y++) {
                        if (!monolithPanels[x] || !monolithPanels[x][y]) continue;
                        
                        const panel = monolithPanels[x][y];
                        const distance = touchPosition.distanceTo(panel.position);
                        
                        if (distance < touchRadius) {
                            // Toggle cell state
                            gameOfLifeGrid[x][y] = !gameOfLifeGrid[x][y];
                            panel.userData.isAlive = gameOfLifeGrid[x][y];
                            
                            // Update panel appearance
                            updatePanelAppearance(panel, gameOfLifeGrid[x][y]);
                            
                            // Play zen sound (placeholder - in real implementation you'd use Web Audio API)
                            console.log('🎵 Zen touch sound at grid:', x, y);
                            
                            // Prevent multiple touches per frame
                            return;
                        }
                    }
                }
            } catch (error) {
                console.warn('Game of Life touch error:', error);
            }
        }
        
        function updatePanelAppearance(panel, isAlive) {
            if (!panel || !panel.material) return;
            
            if (isAlive) {
                panel.material.color.setHex(0x00ffaa);
                if (panel.material.emissive) {
                    panel.material.emissive.setHex(0x004422);
                }
                panel.material.opacity = 0.9;
            } else {
                panel.material.color.setHex(0x001122);
                if (panel.material.emissive) {
                    panel.material.emissive.setHex(0x000000);
                }
                panel.material.opacity = 0.3;
            }
        }
        
        function updateGameOfLife(elapsedTime) {
            try {
                // Auto-progress Game of Life
                if (gameOfLifeRunning && elapsedTime - lastGameOfLifeUpdate > (1.0 / GAME_OF_LIFE_SPEED)) {
                    stepGameOfLife();
                    lastGameOfLifeUpdate = elapsedTime;
                }
                
                // Keep the game running continuously
                if (!gameOfLifeRunning) {
                    gameOfLifeRunning = true;
                    console.log('🎮 Game of Life restarted!');
                }
            } catch (error) {
                console.warn('Game of Life update error:', error);
            }
        }
        
        function stepGameOfLife() {
            try {
                const newGrid = [];
                
                // Initialize new grid
                for (let x = 0; x < GRID_SIZE_X; x++) {
                    newGrid[x] = [];
                    for (let y = 0; y < GRID_SIZE_Y; y++) {
                        newGrid[x][y] = false;
                    }
                }
                
                // Apply Conway's Game of Life rules
                for (let x = 0; x < GRID_SIZE_X; x++) {
                    for (let y = 0; y < GRID_SIZE_Y; y++) {
                        const neighbors = countNeighbors(x, y);
                        const isAlive = gameOfLifeGrid[x][y];
                        
                        if (isAlive) {
                            // Live cell rules
                            if (neighbors === 2 || neighbors === 3) {
                                newGrid[x][y] = true; // Survives
                            }
                            // else dies (underpopulation or overpopulation)
                        } else {
                            // Dead cell rules
                            if (neighbors === 3) {
                                newGrid[x][y] = true; // Birth
                            }
                        }
                    }
                }
                
                // Update grid and panels
                let hasChanges = false;
                for (let x = 0; x < GRID_SIZE_X; x++) {
                    for (let y = 0; y < GRID_SIZE_Y; y++) {
                        if (gameOfLifeGrid[x][y] !== newGrid[x][y]) {
                            hasChanges = true;
                        }
                        gameOfLifeGrid[x][y] = newGrid[x][y];
                        
                        if (monolithPanels[x] && monolithPanels[x][y]) {
                            monolithPanels[x][y].userData.isAlive = newGrid[x][y];
                            updatePanelAppearance(monolithPanels[x][y], newGrid[x][y]);
                        }
                    }
                }
                
                // If no changes (stable state), add some new random patterns to keep it interesting
                if (!hasChanges) {
                    addRandomPattern();
                    console.log('🎮 Game of Life reached stable state - adding new patterns!');
                }
                
            } catch (error) {
                console.warn('Game of Life step error:', error);
            }
        }
        
        function countNeighbors(x, y) {
            let count = 0;
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue; // Skip center cell
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // Check bounds
                    if (nx >= 0 && nx < GRID_SIZE_X && ny >= 0 && ny < GRID_SIZE_Y) {
                        if (gameOfLifeGrid[nx][ny]) {
                            count++;
                        }
                    }
                }
            }
            
            return count;
        }
        
        function addRandomPattern() {
            // Add random patterns to keep the simulation interesting
            const patterns = [
                () => addGliderPattern(Math.floor(Math.random() * (GRID_SIZE_X - 3)), Math.floor(Math.random() * (GRID_SIZE_Y - 3))),
                () => addOscillatorPattern(Math.floor(Math.random() * (GRID_SIZE_X - 1)), Math.floor(Math.random() * (GRID_SIZE_Y - 3))),
                () => {
                    // Random small cluster
                    const x = Math.floor(Math.random() * (GRID_SIZE_X - 2));
                    const y = Math.floor(Math.random() * (GRID_SIZE_Y - 2));
                    for (let dx = 0; dx < 2; dx++) {
                        for (let dy = 0; dy < 2; dy++) {
                            if (Math.random() > 0.5) {
                                gameOfLifeGrid[x + dx][y + dy] = true;
                                if (monolithPanels[x + dx] && monolithPanels[x + dx][y + dy]) {
                                    updatePanelAppearance(monolithPanels[x + dx][y + dy], true);
                                }
                            }
                        }
                    }
                }
            ];
            
            // Add 1-3 random patterns
            const numPatterns = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < numPatterns; i++) {
                const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
                randomPattern();
            }
        }


        function createSpaceBattle() {
            // Clear existing space objects
            asteroids = [];
            spaceShips = [];
            
            // Create initial asteroids
            for (let i = 0; i < ASTEROID_COUNT; i++) {
                const asteroid = new Asteroid();
                asteroids.push(asteroid);
            }
            
            // Create initial spaceships
            for (let i = 0; i < SPACESHIP_COUNT; i++) {
                const spaceship = new SpaceShip();
                spaceShips.push(spaceship);
            }
            
            console.log(`🚀 Created ${ASTEROID_COUNT} asteroids and ${SPACESHIP_COUNT} spaceships for Space Battle`);
        }


        
        
        function createSpaceExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 6; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = getParticleFromPool();
                    if (particle) {
                        particle.position.copy(position);
                        particle.velocity.set(
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3
                        );
                        particle.life = 0.8;
                        particle.maxLife = 0.8;
                        particle.color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.1, 1, 0.8);
                        particles.push(particle);
                    }
                }
                
                console.log('✨ Space explosion!');
            } catch (error) {
                console.warn('Space explosion error:', error);
            }
        }
        
        function updateSkyBattle(deltaTime, elapsedTime) {
            try {
                // Performance optimization: update different elements at different intervals
                const shouldUpdateStars = frameCount % SPACE_UPDATE_INTERVAL === 0;
                const shouldUpdateOrbital = frameCount % ORBITAL_UPDATE_INTERVAL === 0;
                const shouldUpdateParticles = frameCount % PARTICLE_UPDATE_INTERVAL === 0;
                
                // Update stars at reduced frequency (space layer)
                if (shouldUpdateStars) {
                    for (const star of stars) {
                        star.update(elapsedTime);
                    }
                }
                
                // Spawn shooting stars randomly but check less frequently
                if (shouldUpdateParticles && Math.random() < SHOOTING_STAR_SPAWN_RATE * deltaTime * PARTICLE_UPDATE_INTERVAL) {
                    shootingStars.push(new ShootingStar());
                    console.log('✨ Shooting star appeared!');
                }
                
                // Update shooting stars
                for (let i = shootingStars.length - 1; i >= 0; i--) {
                    const shootingStar = shootingStars[i];
                    if (shootingStar.update(deltaTime, elapsedTime)) {
                        shootingStar.destroy();
                        shootingStars.splice(i, 1);
                    }
                }
                
                // Update asteroids at reduced frequency (orbital layer)
                if (shouldUpdateOrbital) {
                    for (let i = asteroids.length - 1; i >= 0; i--) {
                        const asteroid = asteroids[i];
                        asteroid.update(deltaTime * ORBITAL_UPDATE_INTERVAL);
                        
                        // Remove destroyed asteroids
                        if (asteroid.health <= 0) {
                            asteroids.splice(i, 1);
                        }
                    }
                    
                    // Maintain minimum asteroid count
                    while (asteroids.length < ASTEROID_COUNT / 2) {
                        asteroids.push(new Asteroid());
                    }
                }
                
                // Update space ships at reduced frequency
                if (shouldUpdateOrbital) {
                    for (const ship of spaceShips) {
                        ship.update(deltaTime * ORBITAL_UPDATE_INTERVAL, elapsedTime);
                    }
                }
                
                // Update space bullets (keep at normal frequency for responsiveness)
                for (let i = spaceBullets.length - 1; i >= 0; i--) {
                    const bullet = spaceBullets[i];
                    if (bullet.update(deltaTime)) {
                        spaceBullets.splice(i, 1);
                    }
                }
                
            } catch (error) {
                console.warn('Sky battle update error:', error);
            }
        }
        
        
        
        function handleTeleportation(hand, elapsedTime) {
            try {
                if (!hand.userData.isReady || !hand.userData.tipPositions.INDEX) return;
                
                const isPointing = detectPointingGesture(hand);
                
                if (isPointing) {
                    // Perform raycast from pointing finger
                    const rayDirection = getPointingDirection(hand);
                    const rayOrigin = hand.userData.tipPositions.INDEX.clone();
                    
                    teleportRaycaster.set(rayOrigin, rayDirection);
                    
                    // Raycast against ground plane (y = 0)
                    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const intersectPoint = new THREE.Vector3();
                    teleportRaycaster.ray.intersectPlane(groundPlane, intersectPoint);
                    
                    if (intersectPoint) {
                        const distance = rayOrigin.distanceTo(intersectPoint);
                        
                        // Check if within teleport range
                        if (distance <= TELEPORT_MAX_DISTANCE) {
                            // Show reticle at target location
                            teleportReticle.position.copy(intersectPoint);
                            teleportReticle.visible = true;
                            
                            // Check if this is a new pointing gesture or continuation
                            if (!isPointingForTeleport) {
                                // Start new teleport attempt
                                teleportHoldStartTime = elapsedTime;
                                teleportTargetPosition = intersectPoint.clone();
                                isPointingForTeleport = true;
                                console.log('📍 Teleport targeting started...');
                            } else {
                                // Check if pointing is stable (accounting for hand shake)
                                const positionDrift = intersectPoint.distanceTo(teleportTargetPosition);
                                
                                if (positionDrift > TELEPORT_SHAKE_TOLERANCE) {
                                    // Too much movement, restart timer
                                    teleportHoldStartTime = elapsedTime;
                                    teleportTargetPosition = intersectPoint.clone();
                                } else {
                                    // Stable pointing, check progress
                                    const holdTime = elapsedTime - teleportHoldStartTime;
                                    const progress = Math.min(holdTime / TELEPORT_HOLD_TIME, 1.0);
                                    
                                    // Update progress indicator
                                    teleportIndicator.position.copy(intersectPoint);
                                    teleportIndicator.visible = true;
                                    
                                    // Scale indicator based on progress
                                    const scale = 0.5 + (progress * 1.5);
                                    teleportIndicator.scale.set(scale, 1, scale);
                                    
                                    // Change color based on progress
                                    const hue = progress * 0.33; // Green to red
                                    teleportIndicator.material.color.setHSL(hue, 1, 0.5);
                                    
                                    // Teleport when timer completes
                                    if (progress >= 1.0) {
                                        performTeleport(intersectPoint);
                                        resetTeleportState();
                                    }
                                }
                            }
                        } else {
                            // Out of range
                            resetTeleportState();
                        }
                    } else {
                        // No ground intersection
                        resetTeleportState();
                    }
                } else {
                    // Not pointing anymore
                    resetTeleportState();
                }
                
            } catch (error) {
                console.warn('Teleportation error:', error);
                resetTeleportState();
            }
        }
        
        function detectPointingGesture(hand) {
            // Check if index finger is extended while other fingers are curled
            if (!hand.userData.tipPositions.INDEX || !hand.userData.tipPositions.MIDDLE) {
                return false;
            }
            
            const palmPosition = hand.userData.tipPositions.MIDDLE; // Approximate palm
            const indexTip = hand.userData.tipPositions.INDEX;
            
            // Simple pointing detection: index finger extended away from palm
            const pointingDistance = indexTip.distanceTo(palmPosition);
            return pointingDistance > 0.08; // Threshold for extended finger
        }
        
        function getPointingDirection(hand) {
            // Calculate pointing direction from palm toward index fingertip
            const palmPosition = hand.userData.tipPositions.MIDDLE; // Approximate palm
            const indexTip = hand.userData.tipPositions.INDEX;
            
            const direction = new THREE.Vector3().subVectors(indexTip, palmPosition);
            direction.normalize();
            
            return direction;
        }
        
        function performTeleport(targetPosition) {
            try {
                console.log('🚀 Teleporting to:', targetPosition);
                
                // Move the scene to effectively teleport the user
                const currentOffset = scene.position.clone();
                const userPosition = new THREE.Vector3(8, 1.8, 8); // Current user offset
                
                // Calculate new scene offset to place user at target
                const newOffset = new THREE.Vector3(
                    userPosition.x - targetPosition.x,
                    userPosition.y - targetPosition.y,
                    userPosition.z - targetPosition.z
                );
                
                scene.position.copy(newOffset);
                
                // Create teleport effect
                createTeleportEffect(targetPosition);
                
                console.log('✅ Teleport completed!');
                
            } catch (error) {
                console.warn('Teleport execution error:', error);
            }
        }
        
        function createTeleportEffect(position) {
            // Create particle effect at teleport location
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const particle = getParticleFromPool();
                if (particle) {
                    particle.position.copy(position).add(new THREE.Vector3(0, 0.1, 0));
                    particle.velocity.set(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    );
                    particle.life = 1.5;
                    particle.maxLife = 1.5;
                    particle.color = new THREE.Color().setHSL(0.5, 1, 0.8); // Cyan teleport effect
                    particles.push(particle);
                }
            }
        }
        
        function resetTeleportState() {
            isPointingForTeleport = false;
            teleportTargetPosition = null;
            teleportHoldStartTime = 0;
            
            if (teleportReticle) teleportReticle.visible = false;
            if (teleportIndicator) teleportIndicator.visible = false;
        }
        
        function detectFist(hand) {
            try {
                if (!hand.userData.isReady) return false;
                
                // Ensure we have valid tip positions
                if (!hand.userData.tipPositions.INDEX || !hand.userData.tipPositions.MIDDLE || !hand.userData.tipPositions.THUMB) {
                    return false;
                }
                
                // Get joint positions for better fist detection
                const joints = hand.joints;
                if (!joints || !joints['wrist']) return false;
                
                const wrist = joints['wrist'].position;
                const thumbTip = hand.userData.tipPositions.THUMB;
                const indexTip = hand.userData.tipPositions.INDEX;
                const middleTip = hand.userData.tipPositions.MIDDLE;
                
                // Check if fingertips are close to the wrist (curled fingers)
                const thumbToWrist = thumbTip.distanceTo(wrist);
                const indexToWrist = indexTip.distanceTo(wrist);
                const middleToWrist = middleTip.distanceTo(wrist);
                
                // Debug logging
                if (frameCount % 60 === 0) { // Log every 60 frames
                    console.log('Fist detection:', {
                        thumbToWrist: thumbToWrist.toFixed(3),
                        indexToWrist: indexToWrist.toFixed(3),
                        middleToWrist: middleToWrist.toFixed(3),
                        velocity: hand.userData.velocity ? hand.userData.velocity.length().toFixed(3) : '0'
                    });
                }
                
                // If fingertips are close to wrist, it's a fist
                return thumbToWrist < 0.12 && indexToWrist < 0.12 && middleToWrist < 0.12;
            } catch (error) {
                console.warn('Fist detection error:', error);
                return false;
            }
        }
        
        function punchBlast(hand) {
            try {
                if (!hand.userData.tipPositions.MIDDLE || !hand.userData.velocity) return;
                
                const blastCenter = hand.userData.tipPositions.MIDDLE.clone();
                const blastDirection = hand.userData.velocity.clone().normalize();
                
                console.log('Punch blast at:', blastCenter, 'direction:', blastDirection);
                
                // Create force blast effect
                createForceBlastEffect(blastCenter, blastDirection);
                
                // Affect boids within blast radius
                const boidsToRemove = [];
                boids.forEach((boid, index) => {
                    if (boid && boid.position) {
                        const distance = boid.position.distanceTo(blastCenter);
                        if (distance < PUNCH_FORCE_RADIUS) {
                            // Create particle explosion
                            createParticleExplosion(boid.position.clone());
                            boidsToRemove.push(index);
                        }
                    }
                });
                
                // Remove affected boids (in reverse order to maintain indices)
                boidsToRemove.reverse().forEach(index => {
                    boids.splice(index, 1);
                });
                
                console.log('Punch blast destroyed', boidsToRemove.length, 'boids');
                
                // Also affect predators
                predators.forEach(predator => {
                    if (predator && predator.position) {
                        const distance = predator.position.distanceTo(blastCenter);
                        if (distance < PUNCH_FORCE_RADIUS) {
                            // Push predators away
                            const pushDirection = new THREE.Vector3().subVectors(predator.position, blastCenter).normalize();
                            predator.velocity.add(pushDirection.multiplyScalar(0.5));
                        }
                    }
                });
            } catch (error) {
                console.warn('Punch blast error:', error);
            }
        }
        
        function handleGrabbing(hand, heldVoxelMesh) {
            try {
                const grabRadius = 0.15; // Increased grab radius
                
                // Start grabbing
                if (hand.userData.isPinching && hand.userData.heldVoxelIndex === null && hand.userData.heldBoidIndex === null) {
                    // Try to grab fountain voxels first
                    for (let i = 0; i < fountainVoxels.length; i++) {
                        const voxel = fountainVoxels[i];
                        if (voxel && voxel.active && hand.userData.tipPositions.INDEX.distanceTo(voxel.position) < grabRadius) {
                            voxel.active = false;
                            hand.userData.heldVoxelIndex = i;
                            hand.userData.holdStartTime = clock.getElapsedTime();
                            
                            heldVoxelMesh.material.color.set(0x550055);
                            heldVoxelMesh.material.emissive.set(0x550055);
                            heldVoxelMesh.visible = true;
                            console.log('Grabbed fountain voxel', i);
                            return;
                        }
                    }
                    
                    // Try to grab active boids
                    for (let i = 0; i < boids.length; i++) {
                        const boid = boids[i];
                        if (!boid.isGrabbed && hand.userData.tipPositions.INDEX.distanceTo(boid.position) < grabRadius) {
                            boid.isGrabbed = true;
                            boid.originalVelocity.copy(boid.velocity);
                            hand.userData.heldBoidIndex = i;
                            hand.userData.isGrabbingBoid = true;
                            hand.userData.holdStartTime = clock.getElapsedTime();
                            
                            heldVoxelMesh.material.color.set(0xff4444);
                            heldVoxelMesh.material.emissive.set(0xff2222);
                            heldVoxelMesh.visible = true;
                            console.log('Grabbed boid', i);
                            return;
                        }
                    }
                }

                // Handle held voxel (revival or predator creation)
                if (hand.userData.heldVoxelIndex !== null) {
                    const holdDuration = clock.getElapsedTime() - hand.userData.holdStartTime;
                    const isShaking = hand.userData.shakeIntensity > SHAKE_THRESHOLD;
                    
                    // Debug logging for shake detection
                    if (frameCount % 30 === 0) { // Log every 30 frames
                        console.log('Shake detection:', {
                            shakeIntensity: hand.userData.shakeIntensity.toFixed(3),
                            threshold: SHAKE_THRESHOLD,
                            isShaking: isShaking,
                            holdDuration: holdDuration.toFixed(2)
                        });
                    }
                    
                    if (!hand.userData.isPinching) {
                        if (isShaking && holdDuration >= 1.0) {
                            // Create predator from vigorous shaking
                            const predator = new Predator(heldVoxelMesh.position.clone());
                            predators.push(predator);
                            console.log('Predator created! Total predators:', predators.length);
                        } else if (holdDuration >= REVIVAL_TIME) {
                            // Normal revival
                            boids.push(new Boid(heldVoxelMesh.position.clone()));
                            console.log('Boid revived! Total boids:', boids.length);
                        } else {
                            // Don't return fountain voxels - they should fade naturally
                            console.log('Fountain voxel released');
                        }
                        
                        hand.userData.heldVoxelIndex = null;
                        heldVoxelMesh.visible = false;
                        heldVoxelMesh.position.set(0, -1000, 0); // Move far away
                    } else if (isShaking) {
                        // Visual feedback for shaking - turn red
                        heldVoxelMesh.material.color.set(0xff0000);
                        heldVoxelMesh.material.emissive.set(0xff0000);
                    }
                }
                
                // Handle held boid (tossing mechanic)
                if (hand.userData.heldBoidIndex !== null) {
                    const boid = boids[hand.userData.heldBoidIndex];
                    if (!hand.userData.isPinching) {
                        // Release and toss the boid
                        boid.isGrabbed = false;
                        boid.isBeingTossed = true;
                        boid.tossStartTime = clock.getElapsedTime();
                        boid.tossVelocity.copy(hand.userData.velocity);
                        boid.position.copy(heldVoxelMesh.position);
                        
                        hand.userData.heldBoidIndex = null;
                        hand.userData.isGrabbingBoid = false;
                        heldVoxelMesh.visible = false;
                        heldVoxelMesh.position.set(0, -1000, 0); // Move far away
                        console.log('Boid tossed');
                    }
                }
            } catch (error) {
                console.warn('Grabbing error:', error);
            }
        }
        
        function createForceBlastEffect(center, direction) {
            // Create expanding ring of particles to show force blast
            const particleCount = 15; // Reduced for Quest performance
            for (let i = 0; i < particleCount; i++) {
                const particle = getParticleFromPool();
                if (particle) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 0.5;
                    particle.position.copy(center);
                    particle.velocity.set(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 0.5,
                        Math.sin(angle) * radius
                    ).add(direction.clone().multiplyScalar(0.5));
                    particle.life = 0.8;
                    particle.maxLife = 0.8;
                    particle.color = new THREE.Color(0x00aaff);
                    particles.push(particle);
                }
            }
        }
        
        function createParticleExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 10; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = getParticleFromPool();
                    if (particle) {
                        particle.position.copy(position);
                        particle.velocity.set(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        particle.life = 1.0;
                        particle.maxLife = 1.0;
                        particle.color = new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 1, 0.5);
                        particles.push(particle);
                    }
                }
            } catch (error) {
                console.warn('Particle explosion error:', error);
            }
        }
        
        function updateFountainVoxels(elapsedTime, deltaTime) {
            try {
                // Performance optimization: spawn voxels at reduced frequency
                const shouldUpdateFountain = frameCount % FOUNTAIN_UPDATE_INTERVAL === 0;
                
                // Spawn new voxels more frequently but check less often
                if (shouldUpdateFountain && elapsedTime - window.lastFountainSpawn > (1.0 / fountainSpawnRate)) {
                    spawnFountainVoxel();
                    window.lastFountainSpawn = elapsedTime;
                    
                    // Occasional fountain activity log
                    if (Math.random() < 0.1) {
                        console.log(`⛲ Fountain spawning voxel - active count: ${fountainVoxels.filter(v => v?.active).length}`);
                    }
                }
                
                // Update existing voxels (always update physics for smooth motion)
                fountainVoxels.forEach((voxel, index) => {
                    if (!voxel) return;
                    
                    // Smooth physics for better VR fountain visibility
                    voxel.velocity.y -= 15.0 * deltaTime; // Stronger gravity for dramatic arcs
                    voxel.position.add(voxel.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Age the voxel
                    voxel.age += deltaTime;
                    
                    // Fade out over time (only update appearance at intervals)
                    if (shouldUpdateFountain) {
                        const fadeStart = voxelLifetime * 0.7;
                        if (voxel.age > fadeStart) {
                            const fadeProgress = (voxel.age - fadeStart) / (voxelLifetime - fadeStart);
                            voxel.opacity = Math.max(0, 1 - fadeProgress);
                        }
                    }
                    
                    // Remove expired or fallen voxels
                    if (voxel.age > voxelLifetime || voxel.position.y < -2) {
                        fountainVoxels[index] = null;
                    }
                });
                
            } catch (error) {
                console.warn('Fountain voxel update error:', error);
            }
        }
        
        function spawnFountainVoxel() {
            try {
                // Find empty slot
                let emptyIndex = fountainVoxels.findIndex(voxel => voxel === null);
                if (emptyIndex === -1) {
                    // Remove oldest voxel to make space
                    emptyIndex = 0;
                    fountainVoxels[0] = null;
                }
                
                // Create new voxel with dramatic fountain physics for VR visibility
                const angle = Math.random() * Math.PI * 2;
                const speed = 4.0 + Math.random() * 4.0; // Much faster horizontal speed (4-8)
                const upwardSpeed = 6.0 + Math.random() * 6.0; // Much faster upward speed (6-12)
                
                const newVoxel = {
                    position: window.fountainPosition.clone(),
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        upwardSpeed,
                        Math.sin(angle) * speed
                    ),
                    age: 0,
                    opacity: 1.0,
                    active: true,
                    finalColor: new THREE.Color().setHSL(0.5 + Math.random() * 0.3, 0.8, 0.6)
                };
                
                fountainVoxels[emptyIndex] = newVoxel;
                
                // Occasional debug output to confirm fountain activity
                if (Math.random() < 0.05) {
                    console.log(`Fountain active: ${fountainVoxels.filter(v => v?.active).length}/${fountainVoxelCount} voxels`);
                }
                
            } catch (error) {
                console.warn('Fountain voxel spawn error:', error);
            }
        }

        function updateHandData(hand) {
            try {
                if (hand.joints && hand.joints['index-finger-tip'] && hand.joints['thumb-tip'] && hand.joints['middle-finger-tip']) {
                    hand.userData.isReady = true;
                    const thumbTip = hand.joints['thumb-tip'].position;
                    const indexTip = hand.joints['index-finger-tip'].position;
                    const middleTip = hand.joints['middle-finger-tip'].position;
                    
                    // Store previous position for velocity calculation
                    hand.userData.lastPosition.copy(hand.userData.tipPositions.INDEX);
                    
                    hand.userData.tipPositions.THUMB.copy(thumbTip);
                    hand.userData.tipPositions.INDEX.copy(indexTip);
                    hand.userData.tipPositions.MIDDLE.copy(middleTip);
                    
                    // Update hand indicator position for better hand visibility
                    if (hand.userData.handIndicator) {
                        hand.userData.handIndicator.position.copy(indexTip);
                        hand.userData.handIndicator.visible = true;
                    }
                    
                    // Update hand indicator with pulsing effect
                    if (hand.userData.handIndicator && hand.userData.pulsePhase !== undefined) {
                        const pulseScale = 1.0 + Math.sin(clock.getElapsedTime() * 3.0 + hand.userData.pulsePhase) * 0.3;
                        hand.userData.handIndicator.scale.setScalar(pulseScale);
                    }
                    
                    // Calculate hand velocity
                    hand.userData.velocity.subVectors(hand.userData.tipPositions.INDEX, hand.userData.lastPosition);
                    hand.userData.velocity.multiplyScalar(60); // Approximate fps for velocity
                    
                    // Calculate shake intensity
                    const currentSpeed = hand.userData.velocity.length();
                    hand.userData.shakeHistory.push(currentSpeed);
                    if (hand.userData.shakeHistory.length > 5) { // Shorter history for more responsive shaking
                        hand.userData.shakeHistory.shift();
                    }
                    // Use max speed in recent history instead of average for better shake detection
                    hand.userData.shakeIntensity = Math.max(...hand.userData.shakeHistory);
                    
                    // Improved pinch detection
                    const thumbIndexDist = thumbTip.distanceTo(indexTip);
                    const thumbMiddleDist = thumbTip.distanceTo(middleTip);
                    hand.userData.isPinching = thumbIndexDist < 0.03 || thumbMiddleDist < 0.03;
                } else {
                    hand.userData.isReady = false;
                    // Hide hand indicator when hand tracking is not available
                    if (hand.userData.handIndicator) {
                        hand.userData.handIndicator.visible = false;
                    }
                }
            } catch (error) {
                console.warn('Hand tracking error:', error);
                hand.userData.isReady = false;
            }
        }


        function update() {
            const elapsedTime = clock.getElapsedTime();
            const dummy = new THREE.Object3D();
            frameCount++;
            const deltaTime = clock.getDelta();
            
            // Update frustum culling
            updateFrustumCulling();
            
            // Monitor frame rate and adjust quality for 120fps
            updateFrameRateMonitoring(deltaTime);
            
            
            // Update punch cooldowns
            if (punchCooldown1 > 0) {
                punchCooldown1 -= deltaTime;
            }
            if (punchCooldown2 > 0) {
                punchCooldown2 -= deltaTime;
            }

            // Only update hand data if XR is active
            if (renderer.xr.isPresenting) {
                updateHandData(hand1);
                updateHandData(hand2);
                handleGrabbing(hand1, heldVoxelMesh1);
                handleGrabbing(hand2, heldVoxelMesh2);
                
                // Handle Game of Life touch interaction
                handleGameOfLifeTouch(hand1);
                handleGameOfLifeTouch(hand2);
                
                // Handle teleportation (only use right hand to avoid conflicts)
                handleTeleportation(hand2, elapsedTime);
                
                // Handle punch detection
                [hand1, hand2].forEach((hand, index) => {
                    try {
                        const currentCooldown = index === 0 ? punchCooldown1 : punchCooldown2;
                        if (currentCooldown > 0 || !hand.userData.isReady) return;
                        
                        hand.userData.isFist = detectFist(hand);
                    
                    // Detect punch (fist moving fast) - reduced threshold
                    if (hand.userData.isFist && hand.userData.punchVelocity > 0.5) {
                        console.log('PUNCH DETECTED! Velocity:', hand.userData.punchVelocity.toFixed(3));
                        punchBlast(hand);
                        if (index === 0) {
                            punchCooldown1 = PUNCH_COOLDOWN;
                        } else {
                            punchCooldown2 = PUNCH_COOLDOWN;
                        }
                    }
                    
                    // Debug punch detection
                    if (frameCount % 60 === 0 && hand.userData.isFist) {
                        console.log('Fist detected, velocity:', hand.userData.punchVelocity.toFixed(3), 'threshold: 0.5');
                    }
                    
                    // Track punch velocity (change in fist position)
                    if (hand.userData.isFist) {
                        hand.userData.punchVelocity = hand.userData.velocity ? hand.userData.velocity.length() : 0;
                    } else {
                        hand.userData.punchVelocity = 0;
                    }
                } catch (error) {
                    console.warn('Punch detection error:', error);
                }
            });
            }
            
            // Update particles with performance optimization using object pool
            try {
                const shouldUpdateParticles = frameCount % PARTICLE_UPDATE_INTERVAL === 0;
                
                if (shouldUpdateParticles) {
                    particles = particles.filter(particle => {
                        if (!particle || !particle.position || !particle.velocity) {
                            if (particle) returnParticleToPool(particle);
                            return false;
                        }
                        
                        particle.life -= deltaTime * 2 * PARTICLE_UPDATE_INTERVAL;
                        if (particle.life <= 0) {
                            returnParticleToPool(particle);
                            return false;
                        }
                        
                        particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime * PARTICLE_UPDATE_INTERVAL));
                        particle.velocity.multiplyScalar(0.98); // Friction
                        return true;
                    });
                }
            } catch (error) {
                console.warn('Particle update error:', error);
                particles.forEach(p => returnParticleToPool(p));
                particles = []; // Clear particles on error
            }

            // Update held objects for both hands
            [hand1, hand2].forEach((hand, handIndex) => {
                // Check if hand tracking data is available
                if (!hand.userData || !hand.userData.tipPositions || !hand.userData.tipPositions.INDEX) {
                    return; // Skip if hand tracking not ready
                }
                
                const heldMesh = handIndex === 0 ? heldVoxelMesh1 : heldVoxelMesh2;
                
                // Update held voxel (revival mechanic)
                if (hand.userData.heldVoxelIndex !== null) {
                    const voxelData = fountainVoxels[hand.userData.heldVoxelIndex];
                    if (voxelData) {
                        heldMesh.position.copy(hand.userData.tipPositions.INDEX);
                        const chargeRatio = Math.min((elapsedTime - hand.userData.holdStartTime) / REVIVAL_TIME, 1.0);
                        const finalColor = new THREE.Color(0x00ffaa); // Default final color
                        heldMesh.material.color.lerpColors(new THREE.Color(0x550055), finalColor, chargeRatio);
                        heldMesh.material.emissive.lerpColors(new THREE.Color(0x550055), finalColor, chargeRatio);
                    }
                }
                
                // Update held boid position
                if (hand.userData.heldBoidIndex !== null) {
                    const boid = boids[hand.userData.heldBoidIndex];
                    heldMesh.position.copy(hand.userData.tipPositions.INDEX);
                    boid.position.copy(heldMesh.position);
                    
                    // Visual feedback for held boid
                    const holdTime = elapsedTime - hand.userData.holdStartTime;
                    const pulseFactor = (Math.sin(holdTime * 10) + 1) / 2;
                    heldMesh.material.emissive.setRGB(0.8 * pulseFactor, 0.2 * pulseFactor, 0.2 * pulseFactor);
                }
            });
            
            
            // Temporal spreading of expensive updates for 120fps
            const currentFrame = frameCount % TEMPORAL_SPREAD_FRAMES;
            
            // Update fountain voxels (frames 0, 4)
            if (currentFrame === updateQueues.fountain) {
                updateFountainVoxels(elapsedTime, deltaTime);
                updateQueues.fountain = (updateQueues.fountain + 4) % TEMPORAL_SPREAD_FRAMES;
            }
            
            // Update Game of Life (frames 1, 5)
            if (currentFrame === updateQueues.gameOfLife) {
                updateGameOfLife(elapsedTime);
                updateQueues.gameOfLife = (updateQueues.gameOfLife + 4) % TEMPORAL_SPREAD_FRAMES;
            }
            
            // Update sky battle and starfield (frames 2, 6)
            if (currentFrame === updateQueues.skyBattle) {
                updateSkyBattle(deltaTime, elapsedTime);
                updateQueues.skyBattle = (updateQueues.skyBattle + 4) % TEMPORAL_SPREAD_FRAMES;
            }
            
            // Performance optimization: only update fountain mesh at intervals
            const shouldUpdateFountainMesh = frameCount % FOUNTAIN_UPDATE_INTERVAL === 0;
            if (shouldUpdateFountainMesh) {
                let activeFountainCount = 0;
                fountainVoxels.forEach((voxel, i) => {
                    if (voxel && voxel.active) {
                        dummy.position.copy(voxel.position);
                        dummy.updateMatrix();
                        fountainVoxelsMesh.setMatrixAt(activeFountainCount++, dummy.matrix);
                    }
                });
                
                // Update fountain mesh if it exists
                if (fountainVoxelsMesh) {
                    fountainVoxelsMesh.count = activeFountainCount;
                    fountainVoxelsMesh.instanceMatrix.needsUpdate = true;
                    fountainVoxelsMesh.visible = true;
                }
            }

            const aliveVoxelsMesh = scene.getObjectByName('alive_voxels');
            if (aliveVoxelsMesh && boids.length > 0) {
                aliveVoxelsMesh.count = boids.length;
                
                // Performance optimization: only update flocking every few frames for distant boids
                const shouldUpdateFlocking = frameCount % OPTIMIZATION_INTERVAL === 0;
                
                // Spatial partitioning for 120fps collision detection
                spatialGrid.clear();
                boids.forEach(boid => spatialGrid.insert(boid));
                
                // LOD-based boid updates for 120fps
                let processedBoids = 0;
                const maxBoidsPerFrame = Math.ceil(boids.length * currentQualityLevel);
                
                boids.forEach((boid, i) => {
                    // Skip some boids based on quality level for 120fps
                    if (processedBoids >= maxBoidsPerFrame && !boid.isGrabbed) {
                        return; // Skip this boid this frame
                    }
                    
                    const distanceToCamera = camera.position.distanceTo(boid.position);
                    const lodLevel = getLODLevel(distanceToCamera);
                    const inFrustum = isObjectInFrustum(boid.position, 0.2);
                    
                    // Skip culled objects entirely
                    if (lodLevel === 'CULLED' && !boid.isGrabbed) {
                        return;
                    }
                    
                    if (!boid.isGrabbed && (inFrustum || distanceToCamera < CULLING_DISTANCE)) {
                        // Update frequency based on LOD level
                        let updateThisFrame = false;
                        switch(lodLevel) {
                            case 'CLOSE':
                                updateThisFrame = true; // Always update close objects
                                break;
                            case 'MEDIUM':
                                updateThisFrame = shouldUpdateFlocking || boid.isBeingTossed;
                                break;
                            case 'FAR':
                                updateThisFrame = (frameCount % (OPTIMIZATION_INTERVAL * 2) === 0) || boid.isBeingTossed;
                                break;
                        }
                        
                        if (updateThisFrame) {
                            // Use spatial partitioning for nearby boids instead of all boids
                            const nearbyBoids = spatialGrid.getNearby(boid.position, 3.0);
                            boid.flock(nearbyBoids, [hand1, hand2], obstacles, predators);
                        }
                        boid.checkBounds();
                    }
                    
                    boid.update();
                    dummy.position.copy(boid.position);
                    if (boid.velocity.length() > 0.01) {
                        dummy.lookAt(boid.position.clone().add(boid.velocity));
                    }
                    dummy.updateMatrix();
                    aliveVoxelsMesh.setMatrixAt(i, dummy.matrix);
                    processedBoids++;
                });
                aliveVoxelsMesh.instanceMatrix.needsUpdate = true;
                
                // Update predators with performance optimization
                const predatorMesh = scene.getObjectByName('predators');
                if (predatorMesh && predators.length > 0) {
                    predatorMesh.count = predators.length;
                    const shouldUpdatePredatorMesh = frameCount % OPTIMIZATION_INTERVAL === 0;
                    
                    predators.forEach((predator, i) => {
                        try {
                            if (!predator.isGrabbed) {
                                if (shouldUpdatePredatorMesh) {
                                    predator.hunt(boids);
                                    predator.checkBounds();
                                }
                            }
                            predator.update();
                            
                            // Only update matrix if updating mesh
                            if (shouldUpdatePredatorMesh) {
                                dummy.position.copy(predator.position);
                                if (predator.velocity && predator.velocity.length() > 0.01) {
                                    dummy.lookAt(predator.position.clone().add(predator.velocity));
                                }
                                dummy.updateMatrix();
                                predatorMesh.setMatrixAt(i, dummy.matrix);
                            }
                        } catch (error) {
                            console.warn('Predator update error:', error);
                        }
                    });
                    
                    if (shouldUpdatePredatorMesh) {
                        predatorMesh.instanceMatrix.needsUpdate = true;
                    }
                }
            }
        }

        function render() { renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        // Object pooling for particles
        function initParticlePool() {
            particlePool = [];
            for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
                particlePool.push({
                    position: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    life: 0,
                    maxLife: 1,
                    inUse: false
                });
            }
        }
        
        function getParticleFromPool() {
            for (let i = 0; i < particlePool.length; i++) {
                if (!particlePool[i].inUse) {
                    particlePool[i].inUse = true;
                    return particlePool[i];
                }
            }
            return null; // Pool exhausted
        }
        
        function returnParticleToPool(particle) {
            particle.inUse = false;
            particle.life = 0;
        }
        
        // Frustum culling function
        function updateFrustumCulling() {
            cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(cameraMatrix);
        }
        
        function isObjectInFrustum(position, radius = 1.0) {
            const sphere = new THREE.Sphere(position, radius);
            return frustum.intersectsSphere(sphere);
        }
        
        // Initialize shared materials for performance optimization (120fps optimized)
        function initSharedMaterials() {
            // Use MeshBasicMaterial for maximum performance (no lighting calculations)
            sharedMaterials.boidMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                transparent: false, // Disable transparency for performance
                fog: false // Disable fog for performance
            });
            
            sharedMaterials.particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: false, // Disable transparency for performance
                fog: false
            });
            
            sharedMaterials.starMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffaa,
                transparent: false,
                fog: false
            });
            
            sharedMaterials.spaceMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: false,
                fog: false
            });
            
            sharedMaterials.fountainMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: false,
                fog: false
            });
            
            // Quality-based material switching
            sharedMaterials.updateForQuality = function(qualityLevel) {
                const useBasicMaterials = qualityLevel < 0.7;
                
                if (useBasicMaterials) {
                    // Switch to basic materials for better performance
                    Object.values(sharedMaterials).forEach(material => {
                        if (material && material.type) {
                            material.transparent = false;
                            material.fog = false;
                        }
                    });
                }
            };
        }
        
        // Frame rate monitoring and dynamic quality scaling for 120fps
        function updateFrameRateMonitoring(deltaTime) {
            if (deltaTime > 0) {
                const currentFPS = 1 / deltaTime;
                frameRateHistory.push(currentFPS);
                
                // Keep only last 60 frames for rolling average
                if (frameRateHistory.length > 60) {
                    frameRateHistory.shift();
                }
                
                // Calculate average FPS every 60 frames
                if (frameRateHistory.length >= 60) {
                    const avgFPS = frameRateHistory.reduce((a, b) => a + b) / frameRateHistory.length;
                    
                    // Dynamic quality scaling
                    if (avgFPS < MIN_FRAME_RATE) {
                        currentQualityLevel = Math.max(0.3, currentQualityLevel - 0.1);
                        console.log(`🔻 Quality reduced to ${(currentQualityLevel * 100).toFixed(0)}% (FPS: ${avgFPS.toFixed(1)})`);
                    } else if (avgFPS > TARGET_FRAME_RATE * 0.95 && currentQualityLevel < 1.0) {
                        currentQualityLevel = Math.min(1.0, currentQualityLevel + 0.05);
                        console.log(`🔺 Quality increased to ${(currentQualityLevel * 100).toFixed(0)}% (FPS: ${avgFPS.toFixed(1)})`);
                    }
                    
                    frameRateHistory = []; // Reset for next measurement
                }
            }
        }
        
        // LOD system for objects based on distance
        function getLODLevel(distance) {
            if (distance < LOD_DISTANCES.CLOSE) return 'CLOSE';
            if (distance < LOD_DISTANCES.MEDIUM) return 'MEDIUM';
            if (distance < LOD_DISTANCES.FAR) return 'FAR';
            return 'CULLED';
        }

        function init() {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Initialize camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 3);
            
            // Initialize renderer with Quest 3 120fps optimizations
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, // Disable for 120fps performance
                alpha: false,
                depth: true,
                stencil: false,
                powerPreference: "high-performance" // Request high-performance GPU
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio for performance
            renderer.shadowMap.enabled = false; // Disable shadows for 120fps
            renderer.outputEncoding = THREE.sRGBEncoding; // Ensure correct color space
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Optimized tone mapping
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
            
            // Initialize clock
            clock = new THREE.Clock();
            
            // Initialize particle pool for better performance
            initParticlePool();
            
            // Initialize shared materials for performance optimization
            initSharedMaterials();
            
            // Setup WebXR with Quest 3 optimizations
            renderer.xr.enabled = true;
            
            // Enable foveated rendering for Quest 3 120fps
            if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                if (session && session.supportedFrameRates) {
                    // Request 120fps if supported
                    session.requestReferenceSpace('local').then(referenceSpace => {
                        if (session.supportedFrameRates.includes(120)) {
                            session.updateRenderState({
                                baseLayer: new XRWebGLLayer(session, renderer.context, {
                                    antialias: false, // Disable for performance
                                    alpha: false,
                                    depth: true,
                                    stencil: false,
                                    framebufferScaleFactor: 0.8 // Reduce resolution for 120fps
                                })
                            });
                            console.log('🚀 Quest 3 120fps mode enabled with foveated rendering');
                        }
                    });
                }
            }
            
            document.body.appendChild(VRButton.createButton(renderer));
            
            // Add hand tracking with simple visualization
            const handModelFactory = new XRHandModelFactory();
            hand1 = renderer.xr.getHand(0);
            hand1.add(handModelFactory.createHandModel(hand1));
            scene.add(hand1);
            
            hand2 = renderer.xr.getHand(1);
            hand2.add(handModelFactory.createHandModel(hand2));
            scene.add(hand2);
            
            // Add simple hand indicators for better visibility
            const handIndicatorGeometry = new THREE.SphereGeometry(0.05, 4, 4); // Reduced for hand indicators
            const handIndicatorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.6,
                emissive: 0x002244
            });
            
            const handIndicator1 = new THREE.Mesh(handIndicatorGeometry, handIndicatorMaterial);
            handIndicator1.visible = false;
            scene.add(handIndicator1);
            
            const handIndicator2 = new THREE.Mesh(handIndicatorGeometry, handIndicatorMaterial);
            handIndicator2.visible = false;
            scene.add(handIndicator2);
            
            // Initialize hand userData
            [hand1, hand2].forEach((hand, index) => {
                hand.userData = {
                    handIndicator: index === 0 ? handIndicator1 : handIndicator2,
                    tipPositions: {
                        THUMB: new THREE.Vector3(),
                        INDEX: new THREE.Vector3(),
                        MIDDLE: new THREE.Vector3()
                    },
                    lastPosition: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    shakeHistory: [0, 0, 0, 0, 0],
                    shakeIntensity: 0,
                    isPinching: false,
                    isFist: false,
                    isReady: false,
                    heldVoxelIndex: null,
                    heldBoidIndex: null,
                    holdStartTime: 0,
                    isGrabbingBoid: false,
                    punchVelocity: 0
                };
            });
            
            // Setup lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create boids
            for (let i = 0; i < initialBoidCount; i++) {
                const boid = new Boid(
                    new THREE.Vector3(
                        (Math.random() - 0.5) * ATMOSPHERE_RADIUS,
                        Math.random() * (ATMOSPHERE_MAX_HEIGHT - 2) + 2, // 2-28m height
                        (Math.random() - 0.5) * ATMOSPHERE_RADIUS
                    )
                );
                boids.push(boid);
            }
            
            // Create world content
            createVectorGridGround();
            createTronTrees();
            createFountain();
            createBoidsSystem();
            createGameOfLifeMonolith();
            createSpaceBattle();
            
            // Setup event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Add fallback controls for desktop
            addFallbackControls();
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }
        
        function animate() {
            update();
            render();
        }

        // Call init after all definitions
        init();
    </script>
</body>
</html>