<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Boids with Glowing Tree</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; background-color: #111; color: #fff; overflow: hidden; }
        #info { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); padding: 15px 25px; background-color: rgba(0, 0, 0, 0.5); border-radius: 12px; text-align: center; font-size: 16px; z-index: 10; max-width: 90%; }
        #vr-button { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; border: 1px solid #fff; background-color: rgba(0,0,0,0.5); color: #fff; padding: 12px 24px; border-radius: 999px; cursor: pointer; font-weight: 600; }
        #vr-button:hover { background-color: rgba(255,255,255,0.2); }
        
        /* VR Mode - Specifically target UI elements only, not WebXR internals */
        .vr-active #info {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active #vr-button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active #threejs-vr-button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active button {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        .vr-active div:not([id]) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        /* Ensure canvas and WebXR elements remain visible */
        .vr-active canvas {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">
        WebXR Boids: Revival, Tossing, Predators & Force Punch<br>
        Pinch voxels to revive • Grab boids to toss • Shake voxels for predators • Make fist and punch to blast!<br>
        <small>Point with right hand for 3 seconds to teleport</small>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let camera, scene, renderer, clock;
        let boids = [];
        let predators = [];
        let particles = [];
        let hand1, hand2;
        
        let interactiveVoxels = [];
        let fountainVoxels = [];
        let heldVoxelMesh1, heldVoxelMesh2;
        let fountainMesh;
        let fountainVoxelsMesh;
        let monolithPanels = [];
        let gameOfLifeGrid = [];
        let gameOfLifeRunning = false;
        let lastGameOfLifeUpdate = 0;
        const GRID_SIZE_X = 16; // Horizontal panels
        const GRID_SIZE_Y = 80; // Vertical panels (covering full monolith from top to floor)
        const GAME_OF_LIFE_SPEED = 0.3; // Updates per second (reduced for Quest performance)
        const REVIVAL_TIME = 3; 
        const SHAKE_THRESHOLD = 0.8; // Reduced shake intensity needed to create predator

        const initialBoidCount = 25; // Further reduced by 50% for better performance
        const interactiveVoxelCount = 0; // Replaced with fountain system
        const fountainVoxelCount = 30; // Increased for better fountain visibility in VR
        const fountainSpawnRate = 4; // Much faster spawn rate for dramatic VR fountain effect
        const voxelLifetime = 8; // Shorter lifetime for better performance
        const boundSize = 20;
        
        // Punch blast variables
        let punchCooldown1 = 0;
        let punchCooldown2 = 0;
        const PUNCH_COOLDOWN = 0.5; // Seconds between punches
        const PUNCH_FORCE_RADIUS = 2.0; // Radius of punch force blast
        
        // Performance optimization variables
        let frameCount = 0;
        const OPTIMIZATION_INTERVAL = 25; // Update every 25 frames (further increased for better performance)
        
        // Battle Zone tank system
        let tanks = [];
        let projectiles = [];
        const TANK_COUNT = 8; // Increased for more dramatic tank battles
        const BATTLEFIELD_MIN_DISTANCE = 12; // Much closer for VR visibility
        const BATTLEFIELD_MAX_DISTANCE = 25; // Much closer battlefield for visibility
        const TANK_SPEED = 3.0; // Much faster for dramatic VR battles
        const PROJECTILE_SPEED = 4.0; // Faster projectiles
        const TANK_FIRE_RATE = 0.8; // Increased fire rate for more action
        const TANK_DETECTION_RANGE = 18; // Increased detection range
        
        // Sky Asteroids system
        let stars = [];
        let asteroids = [];
        let spaceShips = [];
        let spaceBullets = [];
        let shootingStars = [];
        const STAR_COUNT = 100; // Reduced for Quest performance
        const ASTEROID_COUNT = 6; // Reduced for Quest performance
        const SPACESHIP_COUNT = 1; // Single active hunter spaceship
        const SKY_HEIGHT = 15; // Lower height for better visibility
        const SKY_RADIUS = 25; // Smaller radius for closer action
        const ASTEROID_SPEED = 5.0; // Much faster for dramatic movement
        const SPACESHIP_SPEED = 8.0; // Much faster for aggressive hunting
        const SPACE_BULLET_SPEED = 8.0;
        const SHOOTING_STAR_SPAWN_RATE = 0.05; // Chance per second
        const SHOOTING_STAR_SPEED = 15.0;
        
        // Tron Light Cycles Racing system
        let lightCycles = [];
        let lightTrails = [];
        const LIGHT_CYCLE_COUNT = 2;
        const CYCLE_SPEED = 8.0; // Moderate speed for strategic racing
        const RACE_TRACK_LENGTH = 30; // Length of racing track
        const RACE_LANE_WIDTH = 4; // Distance between racing lanes
        const TRAIL_SEGMENT_LENGTH = 0.3; // Closer trail segments for denser walls
        const TRAIL_LIFETIME = 30; // Longer lifetime for persistent light walls
        const RACE_RESET_TIME = 8; // Seconds before race resets after winner
        
        // Track dimensions and positioning
        const TRACK_CENTER_X = -15; // X position of track center
        const TRACK_CENTER_Z = 15; // Z position of track center  
        const TRACK_WIDTH = 20; // Width of racing track
        const TRACK_HEIGHT = 25; // Height of racing track
        
        // Racing state management
        let raceState = 'racing'; // 'racing', 'victory', 'resetting'
        let raceWinner = null;
        let raceEndTime = 0;
        
        // Teleportation system
        let teleportRaycaster = new THREE.Raycaster();
        let teleportIndicator = null;
        let teleportHoldStartTime = 0;
        let teleportTargetPosition = null;
        let teleportReticle = null;
        let isPointingForTeleport = false;
        const TELEPORT_HOLD_TIME = 3.0; // Seconds to hold for teleport
        const TELEPORT_SHAKE_TOLERANCE = 0.2; // Allowance for hand shake
        const TELEPORT_MAX_DISTANCE = 15; // Maximum teleport range

        // --- NEW: Obstacles for boids to avoid ---
        let obstacles = []; // Will be populated when trees are created
        
        // --- Battle Zone Tank Class ---
        class BattleTank {
            constructor(position, team) {
                this.position = position || new THREE.Vector3();
                this.rotation = Math.random() * Math.PI * 2;
                this.velocity = new THREE.Vector3();
                this.team = team || 0; // 0 or 1 for different teams
                this.health = 3;
                this.lastFireTime = 0;
                this.target = null;
                this.mesh = null;
                this.turretRotation = 0;
                this.state = 'patrol'; // patrol, engage, retreat
                this.patrolTarget = this.generatePatrolTarget();
                this.maxSpeed = TANK_SPEED;
                this.isMoving = false; // Track movement state for debugging
                
                this.createMesh();
            }
            
            createMesh() {
                const tankGroup = new THREE.Group();
                
                // Tank body (larger wireframe box for VR visibility)
                const bodyGeometry = new THREE.BoxGeometry(2.4, 1.6, 4.0); // 2x larger for VR
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.team === 0 ? 0x00ff00 : 0xff0000,
                    wireframe: true,
                    transparent: false, // Solid for better visibility
                    opacity: 1.0,
                    emissive: this.team === 0 ? 0x004400 : 0x440000 // Emissive glow
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.4;
                tankGroup.add(body);
                
                // Tank turret (wireframe cylinder)
                const turretGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.4, 8);
                const turretMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.team === 0 ? 0x00aa00 : 0xaa0000,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.9
                });
                const turret = new THREE.Mesh(turretGeometry, turretMaterial);
                turret.position.y = 1.0;
                tankGroup.add(turret);
                
                // Tank barrel (wireframe cylinder)
                const barrelGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
                const barrelMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.team === 0 ? 0x00ff00 : 0xff0000,
                    wireframe: true,
                    transparent: true,
                    opacity: 1.0
                });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.rotation.z = Math.PI / 2;
                barrel.position.set(0.75, 1.0, 0);
                turret.add(barrel);
                
                this.mesh = tankGroup;
                this.turret = turret;
                this.barrel = barrel;
                scene.add(tankGroup);
            }
            
            generatePatrolTarget() {
                const angle = Math.random() * Math.PI * 2;
                const distance = BATTLEFIELD_MIN_DISTANCE + Math.random() * (BATTLEFIELD_MAX_DISTANCE - BATTLEFIELD_MIN_DISTANCE);
                // Generate patrol targets relative to VR user position (8, 1.8, 8)
                return new THREE.Vector3(
                    8 + Math.cos(angle) * distance,
                    0.5, // Slightly above ground
                    8 + Math.sin(angle) * distance
                );
            }
            
            update(deltaTime, elapsedTime) {
                if (this.health <= 0) return;
                
                // Find nearest enemy tank
                this.findTarget();
                
                // Update AI state
                this.updateAI(deltaTime);
                
                // Update movement
                this.updateMovement(deltaTime);
                
                // Update mesh position and rotation
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.y = this.rotation;
                    
                    // Track if tank is actually moving
                    const wasMoving = this.isMoving;
                    this.isMoving = this.velocity.length() > 0.1;
                    
                    // Occasional debug output for tank activity
                    if (!wasMoving && this.isMoving && Math.random() < 0.1) {
                        console.log(`🚜 Tank (team ${this.team}) moving: ${this.state}`);
                    }
                }
                
                // Update turret rotation towards target
                if (this.target && this.turret) {
                    const targetDirection = new THREE.Vector3().subVectors(this.target.position, this.position);
                    this.turretRotation = Math.atan2(targetDirection.x, targetDirection.z);
                    this.turret.rotation.y = this.turretRotation - this.rotation;
                }
                
                // Try to fire
                this.tryFire(elapsedTime);
            }
            
            findTarget() {
                let closestEnemy = null;
                let closestDistance = TANK_DETECTION_RANGE;
                
                for (const tank of tanks) {
                    if (tank === this || tank.team === this.team || tank.health <= 0) continue;
                    
                    const distance = this.position.distanceTo(tank.position);
                    if (distance < closestDistance) {
                        closestEnemy = tank;
                        closestDistance = distance;
                    }
                }
                
                this.target = closestEnemy;
            }
            
            updateAI(deltaTime) {
                if (this.target) {
                    this.state = 'engage';
                } else if (this.position.distanceTo(this.patrolTarget) < 2.0) {
                    this.patrolTarget = this.generatePatrolTarget();
                    this.state = 'patrol';
                } else {
                    this.state = 'patrol';
                }
            }
            
            updateMovement(deltaTime) {
                let targetPos = this.patrolTarget;
                
                if (this.state === 'engage' && this.target) {
                    // More aggressive movement towards enemy
                    const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                    const distance = toTarget.length();
                    
                    if (distance > 10.0) {
                        // Move directly towards target
                        targetPos = this.target.position;
                    } else if (distance < 6.0) {
                        // Retreat slightly to maintain firing distance
                        targetPos = new THREE.Vector3().subVectors(this.position, toTarget.normalize().multiplyScalar(4));
                    } else {
                        // Circle around target for tactical positioning
                        const perpendicular = new THREE.Vector3(-toTarget.z, 0, toTarget.x).normalize();
                        targetPos = new THREE.Vector3().addVectors(this.position, perpendicular.multiplyScalar(3));
                    }
                } else {
                    // More active patrolling when no target
                    const distanceToPatrol = this.position.distanceTo(this.patrolTarget);
                    if (distanceToPatrol < 3.0) {
                        this.patrolTarget = this.generatePatrolTarget();
                    }
                }
                
                // Move towards target position with improved movement
                const direction = new THREE.Vector3().subVectors(targetPos, this.position);
                direction.y = 0; // Keep on ground
                
                if (direction.length() > 0.2) {
                    direction.normalize();
                    const speedMultiplier = this.state === 'engage' ? 1.2 : 0.8; // Faster when engaging
                    this.velocity.lerp(direction.multiplyScalar(this.maxSpeed * speedMultiplier), deltaTime * 3.0);
                    this.rotation = Math.atan2(this.velocity.x, this.velocity.z);
                }
                
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.position.y = 0; // Keep on ground
            }
            
            tryFire(elapsedTime) {
                if (!this.target || this.health <= 0) return;
                if (elapsedTime - this.lastFireTime < (1.0 / TANK_FIRE_RATE)) return;
                
                const distance = this.position.distanceTo(this.target.position);
                if (distance > TANK_DETECTION_RANGE) return;
                
                // Fire projectile
                this.fire();
                this.lastFireTime = elapsedTime;
            }
            
            fire() {
                if (!this.barrel) return;
                
                const barrelEnd = new THREE.Vector3();
                this.barrel.getWorldPosition(barrelEnd);
                
                const direction = new THREE.Vector3().subVectors(this.target.position, barrelEnd);
                direction.y += 0.5; // Slight upward trajectory
                direction.normalize();
                
                const projectile = new Projectile(barrelEnd.clone(), direction, this.team, this);
                projectiles.push(projectile);
                
                console.log(`🔥 Tank (team ${this.team}) fired at enemy!`);
            }
            
            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    this.destroy();
                }
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
                console.log('💥 Tank destroyed!');
            }
        }
        
        // --- Projectile Class ---
        class Projectile {
            constructor(position, direction, team, shooter) {
                this.position = position.clone();
                this.velocity = direction.clone().multiplyScalar(PROJECTILE_SPEED);
                this.team = team;
                this.shooter = shooter;
                this.life = 5.0; // Seconds before disappearing
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const geometry = new THREE.SphereGeometry(0.05, 6, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: this.team === 0 ? 0x00ffff : 0xffff00,
                    transparent: true,
                    opacity: 0.9
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.life -= deltaTime;
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                }
                
                // Check collision with tanks
                for (const tank of tanks) {
                    if (tank === this.shooter || tank.team === this.team || tank.health <= 0) continue;
                    
                    const distance = this.position.distanceTo(tank.position);
                    if (distance < 1.5) {
                        tank.takeDamage();
                        this.explode();
                        return true; // Mark for removal
                    }
                }
                
                // Remove if life expired or hit ground
                if (this.life <= 0 || this.position.y < -1) {
                    this.destroy();
                    return true; // Mark for removal
                }
                
                return false;
            }
            
            explode() {
                // Create explosion effect
                createProjectileExplosion(this.position.clone());
                this.destroy();
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        // --- Sky Asteroids Classes ---
        class Star {
            constructor() {
                // Adjust position for VR scene offset (8, 1.8, 8) - stars at highest layer
                this.position = new THREE.Vector3(
                    8 + (Math.random() - 0.5) * SKY_RADIUS * 2,
                    1.8 + SKY_HEIGHT + 25 + Math.random() * 15, // Much higher than asteroids (Y=35-50)
                    8 + (Math.random() - 0.5) * SKY_RADIUS * 2
                );
                this.brightness = Math.random() * 0.8 + 0.2;
                this.twinkleSpeed = Math.random() * 2 + 1;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8); // Much larger and higher quality for VR visibility
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: this.brightness
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(elapsedTime) {
                if (this.mesh) {
                    const twinkle = (Math.sin(elapsedTime * this.twinkleSpeed) + 1) / 2;
                    this.mesh.material.opacity = this.brightness * (0.3 + 0.7 * twinkle);
                }
            }
        }
        
        class Asteroid {
            constructor(position, size = 'large') {
                // Adjust position for VR scene offset (8, 1.8, 8)
                this.position = position || new THREE.Vector3(
                    8 + (Math.random() - 0.5) * SKY_RADIUS,
                    1.8 + SKY_HEIGHT + Math.random() * 10,
                    8 + (Math.random() - 0.5) * SKY_RADIUS
                );
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * ASTEROID_SPEED * 2.0, // Much more varied movement
                    (Math.random() - 0.5) * ASTEROID_SPEED * 1.2, // More dramatic Y movement
                    (Math.random() - 0.5) * ASTEROID_SPEED * 2.0
                );
                this.rotation = new THREE.Vector3(
                    Math.random() * 0.02,
                    Math.random() * 0.02,
                    Math.random() * 0.02
                );
                this.size = size; // large, medium, small
                this.health = size === 'large' ? 3 : size === 'medium' ? 2 : 1;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const sizes = { large: 2.0, medium: 1.2, small: 0.7 };
                const radius = sizes[this.size];
                
                // Create irregular asteroid shape
                const geometry = new THREE.DodecahedronGeometry(radius, 0);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x888888,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                const oldPosition = this.position.clone();
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.x += this.rotation.x;
                    this.mesh.rotation.y += this.rotation.y;
                    this.mesh.rotation.z += this.rotation.z;
                }
                
                // Wrap around sky boundaries (adjusted for VR offset)
                if (Math.abs(this.position.x - 8) > SKY_RADIUS) {
                    this.position.x = 8 - Math.sign(this.position.x - 8) * SKY_RADIUS;
                }
                if (Math.abs(this.position.z - 8) > SKY_RADIUS) {
                    this.position.z = 8 - Math.sign(this.position.z - 8) * SKY_RADIUS;
                }
                if (this.position.y < 1.8 + SKY_HEIGHT - 5) {
                    this.position.y = 1.8 + SKY_HEIGHT + 15;
                }
                if (this.position.y > 1.8 + SKY_HEIGHT + 15) {
                    this.position.y = 1.8 + SKY_HEIGHT - 5;
                }
                
                // Enhanced debug logging for asteroid movement
                const moved = oldPosition.distanceTo(this.position) > 0.1;
                if (moved && Math.random() < 0.05) { // More frequent logging
                    console.log(`🌌 Asteroid moving: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) speed=${ASTEROID_SPEED}`);
                }
            }
            
            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    this.split();
                    return true; // Mark for removal
                }
                return false;
            }
            
            split() {
                if (this.size === 'large') {
                    // Split into 2 medium asteroids
                    for (let i = 0; i < 2; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        const newAsteroid = new Asteroid(this.position.clone().add(offset), 'medium');
                        asteroids.push(newAsteroid);
                    }
                } else if (this.size === 'medium') {
                    // Split into 2 small asteroids
                    for (let i = 0; i < 2; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 1,
                            (Math.random() - 0.5) * 1,
                            (Math.random() - 0.5) * 1
                        );
                        const newAsteroid = new Asteroid(this.position.clone().add(offset), 'small');
                        asteroids.push(newAsteroid);
                    }
                }
                
                this.destroy();
                console.log(`💥 ${this.size} asteroid destroyed!`);
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        class SpaceShip {
            constructor() {
                // Adjust position for VR scene offset (8, 1.8, 8)
                this.position = new THREE.Vector3(
                    8 + (Math.random() - 0.5) * SKY_RADIUS,
                    1.8 + SKY_HEIGHT + Math.random() * 10,
                    8 + (Math.random() - 0.5) * SKY_RADIUS
                );
                this.velocity = new THREE.Vector3();
                this.rotation = Math.random() * Math.PI * 2;
                this.angularVelocity = 0;
                this.target = null;
                this.lastFireTime = 0;
                this.mesh = null;
                this.thrust = false;
                
                this.createMesh();
            }
            
            createMesh() {
                const shipGroup = new THREE.Group();
                
                // Appropriately sized triangular ship shape for VR
                const shipGeometry = new THREE.ConeGeometry(1.0, 3.0, 3); // Reasonable size for VR visibility
                const shipMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 1.0,
                    emissive: 0x006666
                });
                const ship = new THREE.Mesh(shipGeometry, shipMaterial);
                ship.rotation.x = Math.PI / 2; // Point forward
                shipGroup.add(ship);
                
                // Add bright markers for visibility
                const markerGeometry = new THREE.SphereGeometry(0.6, 8, 8); // Moderate markers for VR
                const markerMaterial = new THREE.MeshLambertMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00,
                    transparent: true,
                    opacity: 1.0
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.y = 1.0;
                shipGroup.add(marker);
                
                // Add pulsing effect marker
                const pulseGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const pulseMaterial = new THREE.MeshLambertMaterial({
                    color: 0xff0080,
                    emissive: 0xff0080,
                    transparent: true,
                    opacity: 0.5
                });
                const pulseMarker = new THREE.Mesh(pulseGeometry, pulseMaterial);
                pulseMarker.position.y = 1.0;
                shipGroup.add(pulseMarker);
                this.pulseMarker = pulseMarker;
                
                this.mesh = shipGroup;
                this.mesh.position.copy(this.position);
                this.mesh.visible = true;
                scene.add(shipGroup);
                
                console.log('Enhanced spaceship created with maximum visibility');
            }
            
            update(deltaTime, elapsedTime) {
                // Find nearest asteroid
                this.findTarget();
                
                // AI behavior
                this.updateAI(deltaTime);
                
                // Update physics
                const oldPosition = this.position.clone();
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.rotation += this.angularVelocity * deltaTime;
                
                // Apply drag
                this.velocity.multiplyScalar(0.98);
                this.angularVelocity *= 0.95;
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.y = this.rotation;
                    
                    // Add pulsing effect to marker
                    if (this.pulseMarker) {
                        const pulseScale = 1.0 + Math.sin(elapsedTime * 4.0) * 0.3;
                        this.pulseMarker.scale.setScalar(pulseScale);
                    }
                    
                    // Enhanced debug logging for spaceship movement
                    const moved = oldPosition.distanceTo(this.position) > 0.1;
                    if (moved && Math.random() < 0.05) { // More frequent logging
                        console.log(`🚀 Spaceship moving: pos(${this.position.x.toFixed(1)}, ${this.position.y.toFixed(1)}, ${this.position.z.toFixed(1)}) vel(${this.velocity.length().toFixed(2)}) target=${this.target ? 'YES' : 'NO'}`);
                    }
                }
                
                // Wrap around boundaries (adjusted for VR offset)
                if (Math.abs(this.position.x - 8) > SKY_RADIUS) {
                    this.position.x = 8 - Math.sign(this.position.x - 8) * SKY_RADIUS;
                }
                if (Math.abs(this.position.z - 8) > SKY_RADIUS) {
                    this.position.z = 8 - Math.sign(this.position.z - 8) * SKY_RADIUS;
                }
                
                // Try to fire
                this.tryFire(elapsedTime);
            }
            
            findTarget() {
                let closestAsteroid = null;
                let closestDistance = 40; // Much longer detection range to match firing range
                
                // Debug: Check if we have asteroids
                if (Math.random() < 0.01) {
                    console.log(`🔍 Spaceship checking ${asteroids.length} asteroids for targets...`);
                }
                
                for (const asteroid of asteroids) {
                    if (!asteroid || asteroid.health <= 0) continue;
                    const distance = this.position.distanceTo(asteroid.position);
                    if (distance < closestDistance) {
                        closestAsteroid = asteroid;
                        closestDistance = distance;
                    }
                }
                
                // Debug target acquisition
                if (this.target !== closestAsteroid) {
                    if (closestAsteroid) {
                        console.log(`🎯 Spaceship acquired new target at distance ${closestDistance.toFixed(1)}`);
                    } else if (this.target) {
                        console.log(`❌ Spaceship lost target`);
                    }
                }
                
                this.target = closestAsteroid;
            }
            
            updateAI(deltaTime) {
                if (this.target) {
                    const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                    const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                    
                    // Turn towards target
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    this.angularVelocity += Math.sign(angleDiff) * 0.1;
                    
                    // Always thrust towards target - more aggressive behavior
                    const thrustForce = new THREE.Vector3(
                        Math.sin(this.rotation),
                        0,
                        Math.cos(this.rotation)
                    ).multiplyScalar(SPACESHIP_SPEED * deltaTime * 6.0); // Even higher thrust for dramatic movement
                    
                    this.velocity.add(thrustForce);
                    this.thrust = true;
                    
                    // Much more aggressive turning for faster target acquisition
                    this.angularVelocity += Math.sign(angleDiff) * 0.4;
                } else {
                    // More active patrol when no target
                    if (Math.random() < 0.02) {
                        this.angularVelocity += (Math.random() - 0.5) * 0.8;
                    }
                    if (Math.random() < 0.01) {
                        const thrustForce = new THREE.Vector3(
                            Math.sin(this.rotation),
                            0,
                            Math.cos(this.rotation)
                        ).multiplyScalar(SPACESHIP_SPEED * deltaTime * 2.0); // Faster patrol movement
                        
                        this.velocity.add(thrustForce);
                    }
                }
            }
            
            tryFire(elapsedTime) {
                if (!this.target) return;
                if (elapsedTime - this.lastFireTime < 0.3) return; // Faster fire rate
                
                const toTarget = new THREE.Vector3().subVectors(this.target.position, this.position);
                const distance = toTarget.length();
                
                // Fire if target is within range and roughly aimed
                if (distance < 25) { // Much longer firing range for more action
                    const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Very lenient aiming requirement for more action
                    if (Math.abs(angleDiff) < Math.PI / 3) { // 60 degree cone instead of 30
                        this.fire();
                        this.lastFireTime = elapsedTime;
                        console.log(`🚀 Spaceship firing at asteroid! Distance: ${distance.toFixed(1)} units`);
                    }
                }
            }
            
            fire() {
                const bulletStart = this.position.clone();
                const direction = new THREE.Vector3(
                    Math.sin(this.rotation),
                    0,
                    Math.cos(this.rotation)
                );
                
                const bullet = new SpaceBullet(bulletStart, direction, this);
                spaceBullets.push(bullet);
                
                console.log('🚀 Space ship fired!');
            }
        }
        
        class SpaceBullet {
            constructor(position, direction, shooter) {
                this.position = position.clone();
                this.velocity = direction.clone().multiplyScalar(SPACE_BULLET_SPEED);
                this.shooter = shooter;
                this.life = 3.0; // Seconds
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const geometry = new THREE.SphereGeometry(0.08, 6, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: 1.0
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.life -= deltaTime;
                
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                }
                
                // Check collision with asteroids
                for (const asteroid of asteroids) {
                    const distance = this.position.distanceTo(asteroid.position);
                    const hitRadius = asteroid.size === 'large' ? 2.0 : asteroid.size === 'medium' ? 1.2 : 0.7;
                    
                    if (distance < hitRadius) {
                        asteroid.takeDamage();
                        this.explode();
                        return true; // Mark for removal
                    }
                }
                
                // Remove if life expired or out of bounds
                if (this.life <= 0 || Math.abs(this.position.x) > SKY_RADIUS * 2) {
                    this.destroy();
                    return true; // Mark for removal
                }
                
                return false;
            }
            
            explode() {
                // Create small explosion effect
                createSpaceExplosion(this.position.clone());
                this.destroy();
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }
        
        class ShootingStar {
            constructor() {
                // Start from random edge of sky area
                const side = Math.floor(Math.random() * 4);
                const skySize = SKY_RADIUS * 1.5;
                
                // Adjust all positions for VR scene offset (8, 1.8, 8)
                switch(side) {
                    case 0: // Top
                        this.position = new THREE.Vector3(
                            8 + (Math.random() - 0.5) * skySize,
                            1.8 + SKY_HEIGHT + 25 + Math.random() * 10,
                            8 + skySize
                        );
                        break;
                    case 1: // Right
                        this.position = new THREE.Vector3(
                            8 + skySize,
                            1.8 + SKY_HEIGHT + 25 + Math.random() * 10,
                            8 + (Math.random() - 0.5) * skySize
                        );
                        break;
                    case 2: // Bottom
                        this.position = new THREE.Vector3(
                            8 + (Math.random() - 0.5) * skySize,
                            1.8 + SKY_HEIGHT + 25 + Math.random() * 10,
                            8 + (-skySize)
                        );
                        break;
                    case 3: // Left
                        this.position = new THREE.Vector3(
                            8 + (-skySize),
                            1.8 + SKY_HEIGHT + 25 + Math.random() * 10,
                            8 + (Math.random() - 0.5) * skySize
                        );
                        break;
                }
                
                // Create velocity toward opposite side with downward angle (adjusted for VR offset)
                const targetX = 8 + (Math.random() - 0.5) * skySize;
                const targetY = 1.8 + SKY_HEIGHT + Math.random() * 15;
                const targetZ = 8 + (Math.random() - 0.5) * skySize;
                
                const direction = new THREE.Vector3(targetX, targetY, targetZ).sub(this.position);
                direction.normalize();
                this.velocity = direction.multiplyScalar(SHOOTING_STAR_SPEED);
                
                this.life = 4.0; // Seconds
                this.brightness = 0.8 + Math.random() * 0.2;
                this.mesh = null;
                this.trailParticles = [];
                
                this.createMesh();
            }
            
            createMesh() {
                const starGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const starMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffaa,
                    transparent: true,
                    opacity: this.brightness
                });
                this.mesh = new THREE.Mesh(starGeometry, starMaterial);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(deltaTime, elapsedTime) {
                // Update position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.life -= deltaTime;
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // Fade out as life decreases
                    const lifeFactor = Math.max(0, this.life / 4.0);
                    this.mesh.material.opacity = this.brightness * lifeFactor;
                }
                
                // Create trail particles
                this.createTrailParticle(elapsedTime);
                
                // Update trail particles
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    const particle = this.trailParticles[i];
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        if (particle.mesh) {
                            scene.remove(particle.mesh);
                        }
                        this.trailParticles.splice(i, 1);
                    } else {
                        // Fade trail particle
                        if (particle.mesh) {
                            particle.mesh.material.opacity = particle.life / 1.0;
                        }
                    }
                }
                
                // Remove if life expired
                return this.life <= 0;
            }
            
            createTrailParticle(elapsedTime) {
                // Create trail particle every few frames
                if (Math.random() < 0.3) {
                    const trailGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                    const trailMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                    trailMesh.position.copy(this.position);
                    scene.add(trailMesh);
                    
                    this.trailParticles.push({
                        mesh: trailMesh,
                        life: 1.0 // Trail particles live for 1 second
                    });
                }
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
                
                // Clean up trail particles
                for (const particle of this.trailParticles) {
                    if (particle.mesh) {
                        scene.remove(particle.mesh);
                    }
                }
                this.trailParticles = [];
            }
        }
        
        // --- Tron Light Cycle Racing Classes ---
        class LightCycle {
            constructor(teamColor, lane, cycleId) {
                this.cycleId = cycleId; // 0 or 1 for identification
                this.lane = lane; // 0 = left lane, 1 = right lane
                
                // Start positions side by side at VR user location + offset
                const startX = 8 + 15; // 15 units away from user
                const startZ = 8 + (lane === 0 ? -RACE_LANE_WIDTH/2 : RACE_LANE_WIDTH/2);
                
                this.startPosition = new THREE.Vector3(startX, 0.5, startZ);
                this.position = this.startPosition.clone();
                this.velocity = new THREE.Vector3();
                this.direction = 0; // Start facing forward (along X axis)
                this.speed = CYCLE_SPEED;
                this.teamColor = teamColor;
                this.mesh = null;
                this.lastTrailTime = 0;
                this.isAlive = true;
                this.trailSegments = [];
                
                // Racing AI behavior
                this.nextTurnTime = Date.now() + (2000 + Math.random() * 4000);
                this.aggressiveness = Math.random() * 0.5 + 0.3; // How likely to make risky moves
                this.racingStrategy = Math.random() > 0.5 ? 'aggressive' : 'defensive';
                
                this.createMesh();
                this.setInitialVelocity();
            }
            
            createMesh() {
                const cycleGroup = new THREE.Group();
                
                // Larger, more visible main body for Quest 3
                const bodyGeometry = new THREE.BoxGeometry(1.2, 0.6, 3.0);
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.teamColor,
                    wireframe: true,
                    transparent: true,
                    opacity: 1.0,
                    emissive: this.teamColor
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.4; // Raised higher above ground
                cycleGroup.add(body);
                
                // Enhanced light strips for better visibility
                const stripGeometry = new THREE.BoxGeometry(1.3, 0.1, 3.1);
                const stripMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.teamColor,
                    transparent: true,
                    opacity: 1.0,
                    emissive: this.teamColor
                });
                
                // Top strip
                const topStrip = new THREE.Mesh(stripGeometry, stripMaterial);
                topStrip.position.y = 0.75; // Raised with body
                cycleGroup.add(topStrip);
                
                // Bottom strip
                const bottomStrip = new THREE.Mesh(stripGeometry, stripMaterial);
                bottomStrip.position.y = 0.25; // Above ground level
                cycleGroup.add(bottomStrip);
                
                // Larger, more visible wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
                const wheelMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.teamColor,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.9,
                    emissive: this.teamColor
                });
                
                const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                frontWheel.position.set(0, 0.3, 1.0); // Raised above ground
                frontWheel.rotation.z = Math.PI / 2;
                cycleGroup.add(frontWheel);
                
                const backWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                backWheel.position.set(0, 0.3, -1.0); // Raised above ground
                backWheel.rotation.z = Math.PI / 2;
                cycleGroup.add(backWheel);
                
                // Add bright marker for extra visibility
                const markerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const markerMaterial = new THREE.MeshLambertMaterial({
                    color: this.teamColor,
                    emissive: this.teamColor,
                    transparent: true,
                    opacity: 0.8
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.y = 0.9; // Raised with body
                cycleGroup.add(marker);
                
                this.mesh = cycleGroup;
                this.mesh.position.copy(this.position);
                this.mesh.visible = true;
                scene.add(cycleGroup);
                
                console.log(`Light cycle created at position:`, this.position, `with color:`, this.teamColor.toString(16));
            }
            
            setInitialVelocity() {
                this.velocity.set(
                    Math.cos(this.direction) * this.speed,
                    0,
                    Math.sin(this.direction) * this.speed
                );
            }
            
            reset() {
                this.position.copy(this.startPosition);
                this.direction = 0; // Reset to forward direction
                this.isAlive = true;
                this.setInitialVelocity();
                this.nextTurnTime = Date.now() + (2000 + Math.random() * 4000);
                
                // Clear old trail segments
                this.trailSegments.forEach(segment => {
                    if (segment && segment.mesh) {
                        scene.remove(segment.mesh);
                    }
                });
                this.trailSegments = [];
                
                console.log(`🏍️ Light cycle ${this.cycleId} reset for new race`);
            }
            
            update(deltaTime, elapsedTime) {
                if (!this.isAlive) return;
                
                // Racing AI logic
                if (raceState === 'racing') {
                    this.updateRacingAI(deltaTime, elapsedTime);
                }
                
                // Update position
                const oldPosition = this.position.clone();
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Keep light cycle above ground level
                this.position.y = Math.max(this.position.y, 0.5);
                
                // Check for collisions with light walls
                this.checkTrailCollisions();
                
                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.y = this.direction;
                    
                    // Debug logging for movement
                    const moved = oldPosition.distanceTo(this.position) > 0.01;
                    if (moved && Math.random() < 0.01) {
                        console.log(`🏍️ Cycle ${this.cycleId} racing: pos(${this.position.x.toFixed(1)}, ${this.position.z.toFixed(1)}) strategy=${this.racingStrategy}`);
                    }
                }
                
                // Create light trail
                this.updateTrail(elapsedTime);
            }
            
            updateRacingAI(deltaTime, elapsedTime) {
                // Get opponent position
                const opponent = lightCycles.find(cycle => cycle.cycleId !== this.cycleId);
                if (!opponent || !opponent.isAlive) return;
                
                // Strategic racing behavior
                if (Date.now() > this.nextTurnTime) {
                    this.makeStrategicTurn(opponent);
                    this.nextTurnTime = Date.now() + (1500 + Math.random() * 3000);
                }
            }
            
            makeStrategicTurn(opponent) {
                // Strategic racing turns based on opponent position and strategy
                const toOpponent = new THREE.Vector3().subVectors(opponent.position, this.position);
                const distanceToOpponent = toOpponent.length();
                
                let newDirection;
                
                if (this.racingStrategy === 'aggressive' && distanceToOpponent < 8) {
                    // Try to cut off opponent or force them into walls
                    if (Math.random() < this.aggressiveness) {
                        // Turn toward opponent to create blocking moves
                        const angleToOpponent = Math.atan2(toOpponent.z, toOpponent.x);
                        const turnOptions = [
                            angleToOpponent,                    // Direct intercept
                            angleToOpponent + Math.PI / 4,      // Cutting angle
                            angleToOpponent - Math.PI / 4       // Alternate cutting angle
                        ];
                        newDirection = turnOptions[Math.floor(Math.random() * turnOptions.length)];
                        console.log(`⚔️ Cycle ${this.cycleId} making aggressive move toward opponent!`);
                    } else {
                        newDirection = this.makeRandomTurn90();
                    }
                } else {
                    // Defensive or standard racing - avoid opponent and create strategic walls
                    if (Math.random() < 0.7) {
                        newDirection = this.makeRandomTurn90();
                    } else {
                        // Sometimes make a defensive move away from opponent
                        const awayFromOpponent = Math.atan2(-toOpponent.z, -toOpponent.x);
                        newDirection = awayFromOpponent + (Math.random() - 0.5) * Math.PI / 2;
                        console.log(`🛡️ Cycle ${this.cycleId} making defensive move away from opponent`);
                    }
                }
                
                this.direction = newDirection;
                this.setInitialVelocity();
            }
            
            makeRandomTurn90() {
                // Classic 90-degree Tron turns
                const turnOptions = [
                    this.direction + Math.PI / 2,   // Right
                    this.direction - Math.PI / 2,   // Left
                    this.direction                  // Straight (rare)
                ];
                
                const weights = [0.45, 0.45, 0.1]; // Prefer turning over straight
                const random = Math.random();
                
                if (random < weights[0]) {
                    return turnOptions[0];
                } else if (random < weights[0] + weights[1]) {
                    return turnOptions[1];
                } else {
                    return turnOptions[2];
                }
            }
            
            checkTrailCollisions() {
                // Check collision with all trail segments (including own trail after initial segment)
                for (const trail of lightTrails) {
                    if (!trail || !trail.isAlive) continue;
                    
                    // Skip own recent trail segments to prevent immediate collision
                    if (trail.cycleId === this.cycleId && trail.age < 1.0) continue;
                    
                    const distanceToTrail = this.position.distanceTo(trail.position);
                    
                    if (distanceToTrail < 0.8) { // Collision threshold
                        this.explode();
                        return;
                    }
                }
                
                // Check boundaries - explode if too far from racing area
                const userX = 8, userZ = 8;
                const distanceFromUser = Math.sqrt((this.position.x - userX) * (this.position.x - userX) + (this.position.z - userZ) * (this.position.z - userZ));
                
                if (distanceFromUser > 40) { // Race boundary
                    this.explode();
                }
            }
            
            explode() {
                if (!this.isAlive) return;
                
                this.isAlive = false;
                console.log(`💥 Light cycle ${this.cycleId} exploded! Creating explosion effect...`);
                
                // Create explosion effect
                this.createExplosion();
                
                // Determine winner
                const opponent = lightCycles.find(cycle => cycle.cycleId !== this.cycleId);
                if (opponent && opponent.isAlive && raceState === 'racing') {
                    raceWinner = opponent.cycleId;
                    raceState = 'victory';
                    raceEndTime = Date.now();
                    console.log(`🏆 Light cycle ${raceWinner} wins the race!`);
                }
            }
            
            createExplosion() {
                // Create dramatic explosion effect at cycle position
                try {
                    const particleCount = 20;
                    for (let i = 0; i < particleCount; i++) {
                        const particle = {
                            position: this.position.clone(),
                            velocity: new THREE.Vector3(
                                (Math.random() - 0.5) * 15,
                                Math.random() * 10 + 5,
                                (Math.random() - 0.5) * 15
                            ),
                            life: 2.0,
                            maxLife: 2.0,
                            color: this.teamColor,
                            size: 0.3 + Math.random() * 0.4
                        };
                        particles.push(particle);
                    }
                } catch (error) {
                    console.warn('Light cycle explosion error:', error);
                }
            }
            
            updateTrail(elapsedTime) {
                // Add new trail segment if enough distance has been covered
                if (this.trailSegments.length === 0 || 
                    this.position.distanceTo(this.trailSegments[this.trailSegments.length - 1].position) > TRAIL_SEGMENT_LENGTH) {
                    
                    const trailSegment = new LightTrail(this.position.clone(), this.teamColor, elapsedTime, this.cycleId);
                    this.trailSegments.push(trailSegment);
                    lightTrails.push(trailSegment);
                }
                
                // Clean up old trail segments
                this.trailSegments = this.trailSegments.filter(segment => segment.isAlive);
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
                this.isAlive = false;
                console.log('💥 Light cycle destroyed!');
            }
        }
        
        class LightTrail {
            constructor(position, color, creationTime, cycleId) {
                this.position = position.clone();
                this.color = color;
                this.creationTime = creationTime;
                this.cycleId = cycleId; // Which cycle created this trail
                this.age = 0;
                this.isAlive = true;
                this.mesh = null;
                
                this.createMesh();
            }
            
            createMesh() {
                const trailGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.8);
                const trailMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.color,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.mesh = new THREE.Mesh(trailGeometry, trailMaterial);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
            
            update(elapsedTime) {
                // Update age and fade out over time
                this.age = elapsedTime - this.creationTime;
                const fadeProgress = this.age / TRAIL_LIFETIME;
                
                if (fadeProgress >= 1.0) {
                    this.destroy();
                    return;
                }
                
                // Update opacity
                if (this.mesh) {
                    this.mesh.material.opacity = 0.8 * (1 - fadeProgress);
                }
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
                this.isAlive = false;
            }
        }
        
        // --- Predator Class ---
        class Predator {
            constructor(position, color) {
                this.position = position || new THREE.Vector3();
                this.velocity = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.velocity.setLength(Math.random() * 0.3 + 0.2);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.05;
                this.maxSpeed = 0.105; // Reduced by 30% to match boid speed reduction
                this.huntRadius = 4.0;
                this.color = color || new THREE.Color(0xff0000);
                this.isGrabbed = false;
            }
            
            update() {
                if (this.isGrabbed) return;
                
                this.position.add(this.velocity);
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.acceleration.multiplyScalar(0);
            }
            
            applyForce(force) {
                if (!this.isGrabbed) {
                    this.acceleration.add(force);
                }
            }
            
            hunt(boids) {
                if (!boids || !Array.isArray(boids)) {
                    return;
                }
                
                let closest = null;
                let closestDist = Infinity;
                
                for (let boid of boids) {
                    if (!boid || boid.isGrabbed) continue;
                    let d = this.position.distanceTo(boid.position);
                    if (d < this.huntRadius && d < closestDist) {
                        closest = boid;
                        closestDist = d;
                    }
                }
                
                if (closest) {
                    let huntForce = this.seek(closest.position);
                    huntForce.multiplyScalar(2.0); // Strong hunting drive
                    this.applyForce(huntForce);
                }
            }
            
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.normalize();
                desired.multiplyScalar(this.maxSpeed);
                let steer = desired.sub(this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            
            checkBounds() {
                if (this.isGrabbed) return;
                
                const halfBound = boundSize / 2;
                const turnFactor = 0.7;
                
                if (this.position.x > halfBound) this.velocity.x -= turnFactor;
                if (this.position.x < -halfBound) this.velocity.x += turnFactor;
                if (this.position.y > boundSize) this.velocity.y -= turnFactor;
                if (this.position.y < 0.1) this.velocity.y += turnFactor;
                if (this.position.z > halfBound) this.velocity.z -= turnFactor;
                if (this.position.z < -halfBound) this.velocity.z += turnFactor;
            }
        }
        
        // --- Boid Class ---
        class Boid {
            constructor(position) {
                this.position = position || new THREE.Vector3(
                    Math.random() * boundSize - boundSize / 2,
                    Math.random() * (boundSize / 2) + 1,
                    Math.random() * boundSize - boundSize / 2
                );
                this.velocity = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                );
                this.velocity.setLength(Math.random() * 0.5 + 0.5);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.03;
                this.maxSpeed = 0.07; // Reduced by 30% for better performance
                this.isGrabbed = false;
                this.isBeingTossed = false;
                this.tossStartTime = 0;
                this.tossVelocity = new THREE.Vector3();
                this.originalVelocity = new THREE.Vector3();
            }
            
            update() {
                if (this.isGrabbed) return;
                
                if (this.isBeingTossed) {
                    this.handleTossedMovement();
                } else {
                    this.position.add(this.velocity);
                    this.velocity.add(this.acceleration);
                    this.velocity.clampLength(0, this.maxSpeed);
                    this.acceleration.multiplyScalar(0);
                }
            }
            
            handleTossedMovement() {
                const tossTime = clock.getElapsedTime() - this.tossStartTime;
                const transitionTime = 1.0; // Time to transition from toss to flight
                
                if (tossTime < transitionTime) {
                    // Newtonian trajectory with gravity
                    const gravity = new THREE.Vector3(0, -9.8, 0);
                    this.position.add(this.tossVelocity.clone().multiplyScalar(0.016)); // ~60fps
                    this.tossVelocity.add(gravity.clone().multiplyScalar(0.016));
                    
                    // Gradually blend back to boid behavior
                    const blendFactor = tossTime / transitionTime;
                    this.velocity.lerpVectors(this.tossVelocity, this.originalVelocity, blendFactor);
                } else {
                    // Return to normal boid behavior
                    this.isBeingTossed = false;
                    this.velocity.copy(this.originalVelocity);
                }
            }
            
            applyForce(force) {
                if (!this.isGrabbed && !this.isBeingTossed) {
                    this.acceleration.add(force);
                }
            }
            
            // --- MODIFIED: flock method now includes obstacle avoidance and predator fleeing ---
            flock(boids, hands, obstacles, predators) {
                let fleeForce = this.fleeFromHands(hands);
                let predatorFleeForce = this.fleeFromPredators(predators);
                let avoidForce = this.avoid(obstacles);
                let separation = this.separate(boids);
                let alignment = this.align(boids);
                let cohesion = this.cohere(boids);

                // Weight forces
                fleeForce.multiplyScalar(5.0);
                predatorFleeForce.multiplyScalar(8.0); // Very strong predator avoidance
                avoidForce.multiplyScalar(3.0);
                separation.multiplyScalar(1.5);
                alignment.multiplyScalar(1.0);
                cohesion.multiplyScalar(1.0);
                
                this.applyForce(fleeForce);
                this.applyForce(predatorFleeForce);
                this.applyForce(avoidForce);
                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
            }
            
            // --- NEW: Steer away from obstacles ---
            avoid(obstacles) {
                let steer = new THREE.Vector3();
                for (let obstacle of obstacles) {
                    let d = this.position.distanceTo(obstacle.position);
                    if (d < obstacle.radius) {
                        let diff = new THREE.Vector3().subVectors(this.position, obstacle.position);
                        diff.normalize();
                        diff.divideScalar(d); // Weight by distance
                        steer.add(diff);
                    }
                }
                if (steer.length() > 0) {
                    steer.normalize();
                    steer.multiplyScalar(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }

            fleeFromHands(hands) {
                let fleeForce = new THREE.Vector3();
                for (const hand of hands) {
                    if (hand.userData.isReady && !hand.userData.isGrabbingBoid) {
                        fleeForce.add(this.flee(hand.userData.tipPositions.MIDDLE));
                    }
                }
                return fleeForce;
            }
            
            fleeFromPredators(predators) {
                let fleeForce = new THREE.Vector3();
                if (!predators || !Array.isArray(predators)) {
                    return fleeForce;
                }
                for (const predator of predators) {
                    if (!predator || predator.isGrabbed) continue;
                    let d = this.position.distanceTo(predator.position);
                    if (d < 3.0) { // Flee radius from predators
                        let flee = this.flee(predator.position);
                        flee.multiplyScalar(3.0); // Strong flee response
                        fleeForce.add(flee);
                    }
                }
                return fleeForce;
            }
            separate(boids) {
                let desiredSeparation = 0.8;
                let steer = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < desiredSeparation)) {
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                }
                
                if (count > 0) {
                    steer.divideScalar(count);
                    steer.normalize();
                    steer.multiplyScalar(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }
            align(boids) {
                let neighborDist = 2.5;
                let sum = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divideScalar(count);
                    sum.normalize();
                    sum.multiplyScalar(this.maxSpeed);
                    let steer = sum.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                    return steer;
                } else {
                    return new THREE.Vector3();
                }
            }
            cohere(boids) {
                let neighborDist = 3;
                let sum = new THREE.Vector3();
                let count = 0;
                
                for (let other of boids) {
                    if (other.isGrabbed) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < neighborDist)) {
                        sum.add(other.position);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divideScalar(count);
                    return this.seek(sum);
                } else {
                    return new THREE.Vector3();
                }
            }
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.normalize();
                desired.multiplyScalar(this.maxSpeed);
                let steer = desired.sub(this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            flee(target) {
                const fleeRadius = 1.5;
                let steer = new THREE.Vector3();
                let d = this.position.distanceTo(target);
                if (d < fleeRadius) {
                    let desired = new THREE.Vector3().subVectors(this.position, target);
                    desired.normalize();
                    desired.multiplyScalar(this.maxSpeed);
                    steer = desired.sub(this.velocity);
                    steer.clampLength(0, this.maxForce * 2.0);
                }
                return steer;
            }
            checkBounds() {
                if (this.isGrabbed) return;
                
                const halfBound = boundSize / 2;
                const turnFactor = 0.5;
                
                if (this.position.x > halfBound) this.velocity.x -= turnFactor;
                if (this.position.x < -halfBound) this.velocity.x += turnFactor;
                if (this.position.y > 8) this.velocity.y -= turnFactor; // Max Y=8, well below asteroids at Y=11.8
                if (this.position.y < 0.1) this.velocity.y += turnFactor;
                if (this.position.z > halfBound) this.velocity.z -= turnFactor;
                if (this.position.z < -halfBound) this.velocity.z += turnFactor;
            }
        }

        function addFallbackControls() {
            const fallbackDiv = document.createElement('div');
            fallbackDiv.style.position = 'absolute';
            fallbackDiv.style.bottom = '20px';
            fallbackDiv.style.left = '50%';
            fallbackDiv.style.transform = 'translateX(-50%)';
            fallbackDiv.style.padding = '12px 24px';
            fallbackDiv.style.backgroundColor = 'rgba(255, 100, 100, 0.8)';
            fallbackDiv.style.color = 'white';
            fallbackDiv.style.borderRadius = '8px';
            fallbackDiv.style.fontSize = '14px';
            fallbackDiv.textContent = 'VR not supported - use mouse to look around';
            document.body.appendChild(fallbackDiv);
            
            // Add basic mouse controls for fallback
            let mouseX = 0, mouseY = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                camera.position.x = mouseX * 5;
                camera.position.y = mouseY * 3 + 1.6;
                camera.lookAt(0, 2, 0);
            });
        }

        function createVectorGridGround() {
            // Create a large Tron-style wireframe grid ground plane
            const gridSize = 100; // Size of the overall grid
            const divisions = 50; // Number of grid divisions
            const gridHelper = new THREE.GridHelper(gridSize, divisions);
            
            // Style the grid with retro neon cyan color
            gridHelper.material.color.setHex(0x00ffff);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            gridHelper.position.y = -0.1; // Slightly below ground level
            
            scene.add(gridHelper);
            
            // Add additional crossing lines for enhanced vector graphics look
            const linesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00aaff, 
                opacity: 0.4, 
                transparent: true 
            });
            
            // Create major grid lines every 10 units
            const majorLines = new THREE.Group();
            const step = gridSize / 10;
            
            for (let i = -5; i <= 5; i++) {
                if (i === 0) continue; // Skip center lines (already handled by GridHelper)
                
                // Horizontal major lines
                const hGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-gridSize/2, 0, i * step),
                    new THREE.Vector3(gridSize/2, 0, i * step)
                ]);
                const hLine = new THREE.Line(hGeometry, new THREE.LineBasicMaterial({ 
                    color: 0x00ffaa, 
                    opacity: 0.6, 
                    transparent: true 
                }));
                majorLines.add(hLine);
                
                // Vertical major lines  
                const vGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(i * step, 0, -gridSize/2),
                    new THREE.Vector3(i * step, 0, gridSize/2)
                ]);
                const vLine = new THREE.Line(vGeometry, new THREE.LineBasicMaterial({ 
                    color: 0x00ffaa, 
                    opacity: 0.6, 
                    transparent: true 
                }));
                majorLines.add(vLine);
            }
            
            majorLines.position.y = -0.05; // Slightly above the basic grid
            scene.add(majorLines);
            
            // Add animated pulse lines for extra retro effect
            const pulseGroup = new THREE.Group();
            
            // Center cross-hair lines that pulse
            const centerHGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-gridSize/2, 0, 0),
                new THREE.Vector3(gridSize/2, 0, 0)
            ]);
            const centerHLine = new THREE.Line(centerHGeometry, new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                opacity: 0.8, 
                transparent: true 
            }));
            
            const centerVGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -gridSize/2),
                new THREE.Vector3(0, 0, gridSize/2)
            ]);
            const centerVLine = new THREE.Line(centerVGeometry, new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                opacity: 0.8, 
                transparent: true 
            }));
            
            pulseGroup.add(centerHLine);
            pulseGroup.add(centerVLine);
            pulseGroup.position.y = 0.05; // Above other grid lines
            pulseGroup.name = 'gridPulseLines'; // For animation reference
            scene.add(pulseGroup);
            
            console.log('🌐 Created vector graphics grid ground');
        }

        function createTronTrees() {
            const treeConfigs = [
                // Central tree - tall crystalline structure
                {
                    position: new THREE.Vector3(0, 0, 0),
                    trunkGeometry: new THREE.CylinderGeometry(0.2, 0.4, 5, 6),
                    canopyGeometry: new THREE.ConeGeometry(3, 4, 8),
                    trunkColor: 0x00ffff,
                    canopyColor: 0x00ff88,
                    lightColor: 0x00ffaa,
                    lightIntensity: 6,
                    trunkHeight: 2.5,
                    canopyHeight: 6
                },
                // Pyramid tree - left side
                {
                    position: new THREE.Vector3(-8, 0, -3),
                    trunkGeometry: new THREE.BoxGeometry(0.6, 3, 0.6),
                    canopyGeometry: new THREE.TetrahedronGeometry(2.5, 1),
                    trunkColor: 0xff00ff,
                    canopyColor: 0xff0088,
                    lightColor: 0xff00aa,
                    lightIntensity: 4,
                    trunkHeight: 1.5,
                    canopyHeight: 4
                },
                // Octahedron tree - right side
                {
                    position: new THREE.Vector3(6, 0, -6),
                    trunkGeometry: new THREE.CylinderGeometry(0.15, 0.25, 4, 8),
                    canopyGeometry: new THREE.OctahedronGeometry(2.2, 1),
                    trunkColor: 0x0088ff,
                    canopyColor: 0x0066ff,
                    lightColor: 0x0088ff,
                    lightIntensity: 4,
                    trunkHeight: 2,
                    canopyHeight: 4.5
                },
                // Dodecahedron tree - back left
                {
                    position: new THREE.Vector3(-4, 0, 8),
                    trunkGeometry: new THREE.CylinderGeometry(0.3, 0.3, 2.5, 12),
                    canopyGeometry: new THREE.DodecahedronGeometry(2, 0),
                    trunkColor: 0xffaa00,
                    canopyColor: 0xff8800,
                    lightColor: 0xffaa00,
                    lightIntensity: 3,
                    trunkHeight: 1.25,
                    canopyHeight: 3.5
                },
                // Icosahedron tree - back right  
                {
                    position: new THREE.Vector3(3, 0, 6),
                    trunkGeometry: new THREE.CylinderGeometry(0.1, 0.2, 3.5, 6),
                    canopyGeometry: new THREE.IcosahedronGeometry(1.8, 1),
                    trunkColor: 0x88ff00,
                    canopyColor: 0x66ff00,
                    lightColor: 0x88ff00,
                    lightIntensity: 3,
                    trunkHeight: 1.75,
                    canopyHeight: 3.5
                }
            ];
            
            treeConfigs.forEach(config => {
                const tree = new THREE.Group();
                tree.position.copy(config.position);
                
                // Create trunk
                const trunkMat = new THREE.MeshBasicMaterial({ 
                    color: config.trunkColor, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const trunk = new THREE.Mesh(config.trunkGeometry, trunkMat);
                trunk.position.y = config.trunkHeight;
                tree.add(trunk);
                
                // Create canopy
                const canopyMat = new THREE.MeshBasicMaterial({ 
                    color: config.canopyColor, 
                    transparent: true, 
                    opacity: 0.25 
                });
                const canopy = new THREE.Mesh(config.canopyGeometry, canopyMat);
                canopy.position.y = config.canopyHeight;
                tree.add(canopy);
                
                // Create wireframe overlays for Tron effect
                const wireframeMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const trunkWireframe = new THREE.Mesh(config.trunkGeometry, wireframeMat);
                trunkWireframe.position.copy(trunk.position);
                tree.add(trunkWireframe);
                
                const canopyWireframe = new THREE.Mesh(config.canopyGeometry, wireframeMat);
                canopyWireframe.position.copy(canopy.position);
                tree.add(canopyWireframe);
                
                // Add glowing light
                const treeLight = new THREE.PointLight(config.lightColor, config.lightIntensity, 12);
                treeLight.position.y = config.canopyHeight;
                tree.add(treeLight);
                
                // Add to obstacles array
                obstacles.push(
                    { position: new THREE.Vector3().copy(config.position).add(new THREE.Vector3(0, config.trunkHeight, 0)), radius: 0.5 },
                    { position: new THREE.Vector3().copy(config.position).add(new THREE.Vector3(0, config.canopyHeight, 0)), radius: 2.5 }
                );
                
                scene.add(tree);
            });
        }
        
        function createFountain() {
            const fountain = new THREE.Group();
            fountain.position.set(-2, 0, 2); // Position near user spawn
            
            // Base pedestal
            const baseGeometry = new THREE.CylinderGeometry(2, 2.5, 0.5, 12);
            const baseMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x004466, 
                transparent: true, 
                opacity: 0.3 
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.25;
            fountain.add(base);
            
            // Base wireframe
            const baseWireframe = new THREE.Mesh(baseGeometry, new THREE.MeshBasicMaterial({ 
                color: 0x00aaff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.8 
            }));
            baseWireframe.position.copy(base.position);
            fountain.add(baseWireframe);
            
            // Central pillar
            const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const pillarMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x0066aa,
                transparent: true, 
                opacity: 0.4 
            });
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.y = 1.5;
            fountain.add(pillar);
            
            // Pillar wireframe
            const pillarWireframe = new THREE.Mesh(pillarGeometry, new THREE.MeshBasicMaterial({ 
                color: 0x00ddff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.9 
            }));
            pillarWireframe.position.copy(pillar.position);
            fountain.add(pillarWireframe);
            
            // Ornamental top crystal
            const crystalGeometry = new THREE.OctahedronGeometry(0.4, 1);
            const crystalMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.6 
            });
            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
            crystal.position.y = 2.8;
            fountain.add(crystal);
            
            // Crystal wireframe
            const crystalWireframe = new THREE.Mesh(crystalGeometry, new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                wireframe: true 
            }));
            crystalWireframe.position.copy(crystal.position);
            fountain.add(crystalWireframe);
            
            // Glowing light
            const fountainLight = new THREE.PointLight(0x00ccff, 8, 20);
            fountainLight.position.y = 2.8;
            fountain.add(fountainLight);
            
            // Add floating ring elements
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const ringGeometry = new THREE.TorusGeometry(0.15, 0.03, 6, 12);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0088ff, 
                    transparent: true, 
                    opacity: 0.7 
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(
                    Math.cos(angle) * 1.2,
                    0.8 + Math.sin(i) * 0.2,
                    Math.sin(angle) * 1.2
                );
                ring.rotation.x = Math.PI / 2 + Math.sin(i) * 0.3;
                fountain.add(ring);
            }
            
            scene.add(fountain);
            
            // Store fountain position for voxel spawning
            window.fountainPosition = new THREE.Vector3(-2, 2.8, 2);
        }
        
        function addGliderPattern(startX, startY) {
            // Classic glider pattern
            const glider = [
                [0, 1, 0],
                [0, 0, 1],
                [1, 1, 1]
            ];
            
            for (let y = 0; y < glider.length; y++) {
                for (let x = 0; x < glider[y].length; x++) {
                    const gridX = startX + x;
                    const gridY = startY + y;
                    if (gridX >= 0 && gridX < GRID_SIZE_X && gridY >= 0 && gridY < GRID_SIZE_Y) {
                        gameOfLifeGrid[gridX][gridY] = glider[y][x] === 1;
                        if (monolithPanels[gridX] && monolithPanels[gridX][gridY]) {
                            updatePanelAppearance(monolithPanels[gridX][gridY], glider[y][x] === 1);
                        }
                    }
                }
            }
        }
        
        function addOscillatorPattern(startX, startY) {
            // Blinker oscillator pattern
            const blinker = [
                [1],
                [1],
                [1]
            ];
            
            for (let y = 0; y < blinker.length; y++) {
                for (let x = 0; x < blinker[y].length; x++) {
                    const gridX = startX + x;
                    const gridY = startY + y;
                    if (gridX >= 0 && gridX < GRID_SIZE_X && gridY >= 0 && gridY < GRID_SIZE_Y) {
                        gameOfLifeGrid[gridX][gridY] = blinker[y][x] === 1;
                        if (monolithPanels[gridX] && monolithPanels[gridX][gridY]) {
                            updatePanelAppearance(monolithPanels[gridX][gridY], blinker[y][x] === 1);
                        }
                    }
                }
            }
        }
        
        function initializeGameOfLife() {
            // Initialize grid with some interesting starting patterns
            for (let x = 0; x < GRID_SIZE_X; x++) {
                gameOfLifeGrid[x] = [];
                for (let y = 0; y < GRID_SIZE_Y; y++) {
                    gameOfLifeGrid[x][y] = false;
                }
            }
            
            // Add some classic Conway patterns automatically throughout the height
            addGliderPattern(2, 2);
            addGliderPattern(12, 8);
            addOscillatorPattern(8, 15);
            addGliderPattern(4, 25);
            addOscillatorPattern(10, 35);
            addGliderPattern(6, 45);
            addOscillatorPattern(2, 55);
            addGliderPattern(11, 65);
            addOscillatorPattern(7, 75);
            
            // Start the game automatically
            gameOfLifeRunning = true;
            console.log('🎮 Game of Life started with predefined patterns!');
        }
        
        function createGameOfLifeMonolith() {
            const monolith = new THREE.Group();
            monolith.position.set(10, 0, -5); // Position away from other structures
            
            // Main monolith structure - tall and imposing
            const monolithGeometry = new THREE.BoxGeometry(0.8, 12, 3);
            const monolithMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x001133, 
                transparent: true, 
                opacity: 0.4 
            });
            const monolithCore = new THREE.Mesh(monolithGeometry, monolithMaterial);
            monolithCore.position.y = 6;
            monolith.add(monolithCore);
            
            // Monolith wireframe
            const monolithWireframe = new THREE.Mesh(monolithGeometry, new THREE.MeshBasicMaterial({ 
                color: 0x0055aa, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.6 
            }));
            monolithWireframe.position.copy(monolithCore.position);
            monolith.add(monolithWireframe);
            
            // Base platform
            const baseGeometry = new THREE.CylinderGeometry(2, 2.5, 1, 8);
            const baseMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x002244, 
                transparent: true, 
                opacity: 0.5 
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.5;
            monolith.add(base);
            
            // Base wireframe
            const baseWireframe = new THREE.Mesh(baseGeometry, new THREE.MeshBasicMaterial({ 
                color: 0x00aaff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.8 
            }));
            baseWireframe.position.copy(base.position);
            monolith.add(baseWireframe);
            
            // Create light panel grid
            createLightPanelGrid(monolith);
            
            // Add ambient lighting
            const monolithLight = new THREE.PointLight(0x0066ff, 6, 25);
            monolithLight.position.set(0, 8, 2);
            monolith.add(monolithLight);
            
            scene.add(monolith);
            
            // Initialize Game of Life grid
            initializeGameOfLife();
        }
        
        function createLightPanelGrid(monolith) {
            const panelSize = 0.12;
            const panelSpacing = 0.15;
            const gridWidth = GRID_SIZE_X * panelSpacing;
            const gridHeight = GRID_SIZE_Y * panelSpacing;
            
            // Position grid to cover entire monolith from top to floor
            const gridStartX = -gridWidth / 2 + panelSpacing / 2;
            const gridStartY = 12 - panelSpacing / 2; // Start from very top
            const gridZ = 1.6; // Just in front of monolith face
            
            for (let x = 0; x < GRID_SIZE_X; x++) {
                monolithPanels[x] = [];
                for (let y = 0; y < GRID_SIZE_Y; y++) {
                    // Create panel geometry
                    const panelGeometry = new THREE.PlaneGeometry(panelSize, panelSize);
                    const panelMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x001122,
                        emissive: 0x000000,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    panel.position.set(
                        gridStartX + x * panelSpacing,
                        gridStartY - y * panelSpacing,
                        gridZ
                    );
                    
                    // Store grid coordinates in userData
                    panel.userData = { gridX: x, gridY: y, isAlive: false };
                    
                    monolith.add(panel);
                    monolithPanels[x][y] = panel;
                    
                    // Add subtle wireframe border
                    const borderGeometry = new THREE.EdgesGeometry(panelGeometry);
                    const borderMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x004466, 
                        transparent: true, 
                        opacity: 0.5 
                    });
                    const border = new THREE.LineSegments(borderGeometry, borderMaterial);
                    border.position.copy(panel.position);
                    border.position.z += 0.001; // Slightly in front
                    monolith.add(border);
                }
            }
        }

        function handleGameOfLifeTouch(hand) {
            try {
                if (!hand.userData.isReady || !hand.userData.tipPositions.INDEX) return;
                
                const touchPosition = hand.userData.tipPositions.INDEX;
                const touchRadius = 0.08;
                
                // Check each panel for touch
                for (let x = 0; x < GRID_SIZE_X; x++) {
                    for (let y = 0; y < GRID_SIZE_Y; y++) {
                        if (!monolithPanels[x] || !monolithPanels[x][y]) continue;
                        
                        const panel = monolithPanels[x][y];
                        const distance = touchPosition.distanceTo(panel.position);
                        
                        if (distance < touchRadius) {
                            // Toggle cell state
                            gameOfLifeGrid[x][y] = !gameOfLifeGrid[x][y];
                            panel.userData.isAlive = gameOfLifeGrid[x][y];
                            
                            // Update panel appearance
                            updatePanelAppearance(panel, gameOfLifeGrid[x][y]);
                            
                            // Play zen sound (placeholder - in real implementation you'd use Web Audio API)
                            console.log('🎵 Zen touch sound at grid:', x, y);
                            
                            // Prevent multiple touches per frame
                            return;
                        }
                    }
                }
            } catch (error) {
                console.warn('Game of Life touch error:', error);
            }
        }
        
        function updatePanelAppearance(panel, isAlive) {
            if (!panel || !panel.material) return;
            
            if (isAlive) {
                panel.material.color.setHex(0x00ffaa);
                if (panel.material.emissive) {
                    panel.material.emissive.setHex(0x004422);
                }
                panel.material.opacity = 0.9;
            } else {
                panel.material.color.setHex(0x001122);
                if (panel.material.emissive) {
                    panel.material.emissive.setHex(0x000000);
                }
                panel.material.opacity = 0.3;
            }
        }
        
        function updateGameOfLife(elapsedTime) {
            try {
                // Auto-progress Game of Life
                if (gameOfLifeRunning && elapsedTime - lastGameOfLifeUpdate > (1.0 / GAME_OF_LIFE_SPEED)) {
                    stepGameOfLife();
                    lastGameOfLifeUpdate = elapsedTime;
                }
                
                // Keep the game running continuously
                if (!gameOfLifeRunning) {
                    gameOfLifeRunning = true;
                    console.log('🎮 Game of Life restarted!');
                }
            } catch (error) {
                console.warn('Game of Life update error:', error);
            }
        }
        
        function stepGameOfLife() {
            try {
                const newGrid = [];
                
                // Initialize new grid
                for (let x = 0; x < GRID_SIZE_X; x++) {
                    newGrid[x] = [];
                    for (let y = 0; y < GRID_SIZE_Y; y++) {
                        newGrid[x][y] = false;
                    }
                }
                
                // Apply Conway's Game of Life rules
                for (let x = 0; x < GRID_SIZE_X; x++) {
                    for (let y = 0; y < GRID_SIZE_Y; y++) {
                        const neighbors = countNeighbors(x, y);
                        const isAlive = gameOfLifeGrid[x][y];
                        
                        if (isAlive) {
                            // Live cell rules
                            if (neighbors === 2 || neighbors === 3) {
                                newGrid[x][y] = true; // Survives
                            }
                            // else dies (underpopulation or overpopulation)
                        } else {
                            // Dead cell rules
                            if (neighbors === 3) {
                                newGrid[x][y] = true; // Birth
                            }
                        }
                    }
                }
                
                // Update grid and panels
                let hasChanges = false;
                for (let x = 0; x < GRID_SIZE_X; x++) {
                    for (let y = 0; y < GRID_SIZE_Y; y++) {
                        if (gameOfLifeGrid[x][y] !== newGrid[x][y]) {
                            hasChanges = true;
                        }
                        gameOfLifeGrid[x][y] = newGrid[x][y];
                        
                        if (monolithPanels[x] && monolithPanels[x][y]) {
                            monolithPanels[x][y].userData.isAlive = newGrid[x][y];
                            updatePanelAppearance(monolithPanels[x][y], newGrid[x][y]);
                        }
                    }
                }
                
                // If no changes (stable state), add some new random patterns to keep it interesting
                if (!hasChanges) {
                    addRandomPattern();
                    console.log('🎮 Game of Life reached stable state - adding new patterns!');
                }
                
            } catch (error) {
                console.warn('Game of Life step error:', error);
            }
        }
        
        function countNeighbors(x, y) {
            let count = 0;
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue; // Skip center cell
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // Check bounds
                    if (nx >= 0 && nx < GRID_SIZE_X && ny >= 0 && ny < GRID_SIZE_Y) {
                        if (gameOfLifeGrid[nx][ny]) {
                            count++;
                        }
                    }
                }
            }
            
            return count;
        }
        
        function addRandomPattern() {
            // Add random patterns to keep the simulation interesting
            const patterns = [
                () => addGliderPattern(Math.floor(Math.random() * (GRID_SIZE_X - 3)), Math.floor(Math.random() * (GRID_SIZE_Y - 3))),
                () => addOscillatorPattern(Math.floor(Math.random() * (GRID_SIZE_X - 1)), Math.floor(Math.random() * (GRID_SIZE_Y - 3))),
                () => {
                    // Random small cluster
                    const x = Math.floor(Math.random() * (GRID_SIZE_X - 2));
                    const y = Math.floor(Math.random() * (GRID_SIZE_Y - 2));
                    for (let dx = 0; dx < 2; dx++) {
                        for (let dy = 0; dy < 2; dy++) {
                            if (Math.random() > 0.5) {
                                gameOfLifeGrid[x + dx][y + dy] = true;
                                if (monolithPanels[x + dx] && monolithPanels[x + dx][y + dy]) {
                                    updatePanelAppearance(monolithPanels[x + dx][y + dy], true);
                                }
                            }
                        }
                    }
                }
            ];
            
            // Add 1-3 random patterns
            const numPatterns = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < numPatterns; i++) {
                const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
                randomPattern();
            }
        }

        function createTankBattlefield() {
            // Clear existing tanks
            tanks = [];
            
            // Create initial tanks
            for (let i = 0; i < TANK_COUNT; i++) {
                const team = i % 2; // Alternate between team 0 and 1
                const angle = (i / TANK_COUNT) * Math.PI * 2;
                const distance = BATTLEFIELD_MIN_DISTANCE + Math.random() * 8;
                
                const position = new THREE.Vector3(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                
                const tank = new BattleTank(position, team);
                tanks.push(tank);
            }
            
            console.log(`🚗 Created ${TANK_COUNT} tanks for Battle Zone`);
        }

        function createSpaceBattle() {
            // Clear existing space objects
            asteroids = [];
            spaceShips = [];
            
            // Create initial asteroids
            for (let i = 0; i < ASTEROID_COUNT; i++) {
                const asteroid = new Asteroid();
                asteroids.push(asteroid);
            }
            
            // Create initial spaceships
            for (let i = 0; i < SPACESHIP_COUNT; i++) {
                const spaceship = new SpaceShip();
                spaceShips.push(spaceship);
            }
            
            console.log(`🚀 Created ${ASTEROID_COUNT} asteroids and ${SPACESHIP_COUNT} spaceships for Space Battle`);
        }

        function createLightCycleRacing() {
            // Clear existing light cycles and trails
            lightCycles = [];
            lightTrails = [];
            
            // Create initial light cycles
            for (let i = 0; i < LIGHT_CYCLE_COUNT; i++) {
                const startX = TRACK_CENTER_X + (i === 0 ? -TRACK_WIDTH / 4 : TRACK_WIDTH / 4);
                const startZ = TRACK_CENTER_Z - TRACK_HEIGHT / 2;
                const team = i; // Each cycle gets its own team
                
                const lightCycle = new LightCycle(
                    new THREE.Vector3(startX, 0, startZ),
                    team
                );
                lightCycles.push(lightCycle);
            }
            
            console.log(`🏍️ Created ${LIGHT_CYCLE_COUNT} light cycles for Tron Racing`);
        }

        function createProjectileExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 8; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = {
                        position: position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 4,
                            Math.random() * 3,
                            (Math.random() - 0.5) * 4
                        ),
                        life: 1.0,
                        color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 1, 0.7)
                    };
                    particles.push(particle);
                }
                
                console.log('💥 Projectile explosion!');
            } catch (error) {
                console.warn('Projectile explosion error:', error);
            }
        }
        
        function updateTankBattle(deltaTime, elapsedTime) {
            try {
                // Update tanks
                for (let i = tanks.length - 1; i >= 0; i--) {
                    const tank = tanks[i];
                    if (tank.health <= 0) {
                        // Respawn tank after delay
                        setTimeout(() => {
                            if (tanks.length < TANK_COUNT) {
                                const team = Math.floor(Math.random() * 2);
                                const angle = Math.random() * Math.PI * 2;
                                const distance = BATTLEFIELD_MIN_DISTANCE + Math.random() * (BATTLEFIELD_MAX_DISTANCE - BATTLEFIELD_MIN_DISTANCE);
                                
                                // Respawn tanks relative to VR user position (8, 1.8, 8)
                                const position = new THREE.Vector3(
                                    8 + Math.cos(angle) * distance,
                                    0.5, // Slightly above ground for visibility
                                    8 + Math.sin(angle) * distance
                                );
                                
                                const newTank = new BattleTank(position, team);
                                tanks.push(newTank);
                                console.log('🚗 New tank deployed!');
                            }
                        }, 5000 + Math.random() * 5000); // 5-10 second respawn delay
                        
                        tanks.splice(i, 1);
                    } else {
                        tank.update(deltaTime, elapsedTime);
                    }
                }
                
                // Update projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    if (projectile.update(deltaTime)) {
                        projectiles.splice(i, 1);
                    }
                }
            } catch (error) {
                console.warn('Tank battle update error:', error);
            }
        }
        
        function createSpaceExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 6; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = {
                        position: position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3
                        ),
                        life: 0.8,
                        color: new THREE.Color().setHSL(Math.random() * 0.2 + 0.1, 1, 0.8)
                    };
                    particles.push(particle);
                }
                
                console.log('✨ Space explosion!');
            } catch (error) {
                console.warn('Space explosion error:', error);
            }
        }
        
        function updateSkyBattle(deltaTime, elapsedTime) {
            try {
                // Update stars
                for (const star of stars) {
                    star.update(elapsedTime);
                }
                
                // Spawn shooting stars randomly
                if (Math.random() < SHOOTING_STAR_SPAWN_RATE * deltaTime) {
                    shootingStars.push(new ShootingStar());
                    console.log('✨ Shooting star appeared!');
                }
                
                // Update shooting stars
                for (let i = shootingStars.length - 1; i >= 0; i--) {
                    const shootingStar = shootingStars[i];
                    if (shootingStar.update(deltaTime, elapsedTime)) {
                        shootingStar.destroy();
                        shootingStars.splice(i, 1);
                    }
                }
                
                // Update asteroids
                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    asteroid.update(deltaTime);
                    
                    // Remove destroyed asteroids
                    if (asteroid.health <= 0) {
                        asteroids.splice(i, 1);
                    }
                }
                
                // Maintain minimum asteroid count
                while (asteroids.length < ASTEROID_COUNT / 2) {
                    asteroids.push(new Asteroid());
                }
                
                // Update space ships
                for (const ship of spaceShips) {
                    ship.update(deltaTime, elapsedTime);
                }
                
                // Update space bullets
                for (let i = spaceBullets.length - 1; i >= 0; i--) {
                    const bullet = spaceBullets[i];
                    if (bullet.update(deltaTime)) {
                        spaceBullets.splice(i, 1);
                    }
                }
                
            } catch (error) {
                console.warn('Sky battle update error:', error);
            }
        }
        
        function updateLightCycles(deltaTime, elapsedTime) {
            try {
                // Race state management
                if (raceState === 'victory') {
                    // Check if it's time to reset the race
                    if (Date.now() - raceEndTime > RACE_RESET_TIME * 1000) {
                        resetRace();
                    } else {
                        // During victory phase, show victory celebration
                        if (Math.random() < 0.02) {
                            console.log(`🏆 Light cycle ${raceWinner} is victorious! Race resets in ${Math.ceil((RACE_RESET_TIME * 1000 - (Date.now() - raceEndTime)) / 1000)} seconds...`);
                        }
                    }
                }
                
                // Update all light cycles
                for (const cycle of lightCycles) {
                    cycle.update(deltaTime, elapsedTime);
                }
                
                // Update light trails
                for (let i = lightTrails.length - 1; i >= 0; i--) {
                    const trail = lightTrails[i];
                    trail.update(elapsedTime);
                    
                    // Remove dead trails
                    if (!trail.isAlive) {
                        lightTrails.splice(i, 1);
                    }
                }
                
            } catch (error) {
                console.warn('Light cycle update error:', error);
            }
        }
        
        function resetRace() {
            console.log('🔄 Resetting light cycle race for another epic battle!');
            
            // Reset race state
            raceState = 'racing';
            raceWinner = null;
            raceEndTime = 0;
            
            // Reset both cycles
            lightCycles.forEach(cycle => {
                cycle.reset();
            });
            
            // Clear old trails for fresh start
            lightTrails.forEach(trail => {
                if (trail && trail.mesh) {
                    scene.remove(trail.mesh);
                }
            });
            lightTrails = [];
            
            console.log('✅ Race reset complete - let the battle begin!');
        }
        
        // Light cycle collision detection is now handled within each cycle's update method
        
        function handleTeleportation(hand, elapsedTime) {
            try {
                if (!hand.userData.isReady || !hand.userData.tipPositions.INDEX) return;
                
                const isPointing = detectPointingGesture(hand);
                
                if (isPointing) {
                    // Perform raycast from pointing finger
                    const rayDirection = getPointingDirection(hand);
                    const rayOrigin = hand.userData.tipPositions.INDEX.clone();
                    
                    teleportRaycaster.set(rayOrigin, rayDirection);
                    
                    // Raycast against ground plane (y = 0)
                    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const intersectPoint = new THREE.Vector3();
                    teleportRaycaster.ray.intersectPlane(groundPlane, intersectPoint);
                    
                    if (intersectPoint) {
                        const distance = rayOrigin.distanceTo(intersectPoint);
                        
                        // Check if within teleport range
                        if (distance <= TELEPORT_MAX_DISTANCE) {
                            // Show reticle at target location
                            teleportReticle.position.copy(intersectPoint);
                            teleportReticle.visible = true;
                            
                            // Check if this is a new pointing gesture or continuation
                            if (!isPointingForTeleport) {
                                // Start new teleport attempt
                                teleportHoldStartTime = elapsedTime;
                                teleportTargetPosition = intersectPoint.clone();
                                isPointingForTeleport = true;
                                console.log('📍 Teleport targeting started...');
                            } else {
                                // Check if pointing is stable (accounting for hand shake)
                                const positionDrift = intersectPoint.distanceTo(teleportTargetPosition);
                                
                                if (positionDrift > TELEPORT_SHAKE_TOLERANCE) {
                                    // Too much movement, restart timer
                                    teleportHoldStartTime = elapsedTime;
                                    teleportTargetPosition = intersectPoint.clone();
                                } else {
                                    // Stable pointing, check progress
                                    const holdTime = elapsedTime - teleportHoldStartTime;
                                    const progress = Math.min(holdTime / TELEPORT_HOLD_TIME, 1.0);
                                    
                                    // Update progress indicator
                                    teleportIndicator.position.copy(intersectPoint);
                                    teleportIndicator.visible = true;
                                    
                                    // Scale indicator based on progress
                                    const scale = 0.5 + (progress * 1.5);
                                    teleportIndicator.scale.set(scale, 1, scale);
                                    
                                    // Change color based on progress
                                    const hue = progress * 0.33; // Green to red
                                    teleportIndicator.material.color.setHSL(hue, 1, 0.5);
                                    
                                    // Teleport when timer completes
                                    if (progress >= 1.0) {
                                        performTeleport(intersectPoint);
                                        resetTeleportState();
                                    }
                                }
                            }
                        } else {
                            // Out of range
                            resetTeleportState();
                        }
                    } else {
                        // No ground intersection
                        resetTeleportState();
                    }
                } else {
                    // Not pointing anymore
                    resetTeleportState();
                }
                
            } catch (error) {
                console.warn('Teleportation error:', error);
                resetTeleportState();
            }
        }
        
        function detectPointingGesture(hand) {
            // Check if index finger is extended while other fingers are curled
            if (!hand.userData.tipPositions.INDEX || !hand.userData.tipPositions.MIDDLE) {
                return false;
            }
            
            const palmPosition = hand.userData.tipPositions.MIDDLE; // Approximate palm
            const indexTip = hand.userData.tipPositions.INDEX;
            
            // Simple pointing detection: index finger extended away from palm
            const pointingDistance = indexTip.distanceTo(palmPosition);
            return pointingDistance > 0.08; // Threshold for extended finger
        }
        
        function getPointingDirection(hand) {
            // Calculate pointing direction from palm toward index fingertip
            const palmPosition = hand.userData.tipPositions.MIDDLE; // Approximate palm
            const indexTip = hand.userData.tipPositions.INDEX;
            
            const direction = new THREE.Vector3().subVectors(indexTip, palmPosition);
            direction.normalize();
            
            return direction;
        }
        
        function performTeleport(targetPosition) {
            try {
                console.log('🚀 Teleporting to:', targetPosition);
                
                // Move the scene to effectively teleport the user
                const currentOffset = scene.position.clone();
                const userPosition = new THREE.Vector3(8, 1.8, 8); // Current user offset
                
                // Calculate new scene offset to place user at target
                const newOffset = new THREE.Vector3(
                    userPosition.x - targetPosition.x,
                    userPosition.y - targetPosition.y,
                    userPosition.z - targetPosition.z
                );
                
                scene.position.copy(newOffset);
                
                // Create teleport effect
                createTeleportEffect(targetPosition);
                
                console.log('✅ Teleport completed!');
                
            } catch (error) {
                console.warn('Teleport execution error:', error);
            }
        }
        
        function createTeleportEffect(position) {
            // Create particle effect at teleport location
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const particle = {
                    position: position.clone().add(new THREE.Vector3(0, 0.1, 0)),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    ),
                    life: 1.5,
                    color: new THREE.Color().setHSL(0.5, 1, 0.8) // Cyan teleport effect
                };
                particles.push(particle);
            }
        }
        
        function resetTeleportState() {
            isPointingForTeleport = false;
            teleportTargetPosition = null;
            teleportHoldStartTime = 0;
            
            if (teleportReticle) teleportReticle.visible = false;
            if (teleportIndicator) teleportIndicator.visible = false;
        }
        
        function detectFist(hand) {
            try {
                if (!hand.userData.isReady) return false;
                
                // Ensure we have valid tip positions
                if (!hand.userData.tipPositions.INDEX || !hand.userData.tipPositions.MIDDLE || !hand.userData.tipPositions.THUMB) {
                    return false;
                }
                
                // Get joint positions for better fist detection
                const joints = hand.joints;
                if (!joints || !joints['wrist']) return false;
                
                const wrist = joints['wrist'].position;
                const thumbTip = hand.userData.tipPositions.THUMB;
                const indexTip = hand.userData.tipPositions.INDEX;
                const middleTip = hand.userData.tipPositions.MIDDLE;
                
                // Check if fingertips are close to the wrist (curled fingers)
                const thumbToWrist = thumbTip.distanceTo(wrist);
                const indexToWrist = indexTip.distanceTo(wrist);
                const middleToWrist = middleTip.distanceTo(wrist);
                
                // Debug logging
                if (frameCount % 60 === 0) { // Log every 60 frames
                    console.log('Fist detection:', {
                        thumbToWrist: thumbToWrist.toFixed(3),
                        indexToWrist: indexToWrist.toFixed(3),
                        middleToWrist: middleToWrist.toFixed(3),
                        velocity: hand.userData.velocity ? hand.userData.velocity.length().toFixed(3) : '0'
                    });
                }
                
                // If fingertips are close to wrist, it's a fist
                return thumbToWrist < 0.12 && indexToWrist < 0.12 && middleToWrist < 0.12;
            } catch (error) {
                console.warn('Fist detection error:', error);
                return false;
            }
        }
        
        function punchBlast(hand) {
            try {
                if (!hand.userData.tipPositions.MIDDLE || !hand.userData.velocity) return;
                
                const blastCenter = hand.userData.tipPositions.MIDDLE.clone();
                const blastDirection = hand.userData.velocity.clone().normalize();
                
                console.log('Punch blast at:', blastCenter, 'direction:', blastDirection);
                
                // Create force blast effect
                createForceBlastEffect(blastCenter, blastDirection);
                
                // Affect boids within blast radius
                const boidsToRemove = [];
                boids.forEach((boid, index) => {
                    if (boid && boid.position) {
                        const distance = boid.position.distanceTo(blastCenter);
                        if (distance < PUNCH_FORCE_RADIUS) {
                            // Create particle explosion
                            createParticleExplosion(boid.position.clone());
                            boidsToRemove.push(index);
                        }
                    }
                });
                
                // Remove affected boids (in reverse order to maintain indices)
                boidsToRemove.reverse().forEach(index => {
                    boids.splice(index, 1);
                });
                
                console.log('Punch blast destroyed', boidsToRemove.length, 'boids');
                
                // Also affect predators
                predators.forEach(predator => {
                    if (predator && predator.position) {
                        const distance = predator.position.distanceTo(blastCenter);
                        if (distance < PUNCH_FORCE_RADIUS) {
                            // Push predators away
                            const pushDirection = new THREE.Vector3().subVectors(predator.position, blastCenter).normalize();
                            predator.velocity.add(pushDirection.multiplyScalar(0.5));
                        }
                    }
                });
            } catch (error) {
                console.warn('Punch blast error:', error);
            }
        }
        
        function handleGrabbing(hand, heldVoxelMesh) {
            try {
                const grabRadius = 0.15; // Increased grab radius
                
                // Start grabbing
                if (hand.userData.isPinching && hand.userData.heldVoxelIndex === null && hand.userData.heldBoidIndex === null) {
                    // Try to grab fountain voxels first
                    for (let i = 0; i < fountainVoxels.length; i++) {
                        const voxel = fountainVoxels[i];
                        if (voxel && voxel.active && hand.userData.tipPositions.INDEX.distanceTo(voxel.position) < grabRadius) {
                            voxel.active = false;
                            hand.userData.heldVoxelIndex = i;
                            hand.userData.holdStartTime = clock.getElapsedTime();
                            
                            heldVoxelMesh.material.color.set(0x550055);
                            heldVoxelMesh.material.emissive.set(0x550055);
                            heldVoxelMesh.visible = true;
                            console.log('Grabbed fountain voxel', i);
                            return;
                        }
                    }
                    
                    // Try to grab active boids
                    for (let i = 0; i < boids.length; i++) {
                        const boid = boids[i];
                        if (!boid.isGrabbed && hand.userData.tipPositions.INDEX.distanceTo(boid.position) < grabRadius) {
                            boid.isGrabbed = true;
                            boid.originalVelocity.copy(boid.velocity);
                            hand.userData.heldBoidIndex = i;
                            hand.userData.isGrabbingBoid = true;
                            hand.userData.holdStartTime = clock.getElapsedTime();
                            
                            heldVoxelMesh.material.color.set(0xff4444);
                            heldVoxelMesh.material.emissive.set(0xff2222);
                            heldVoxelMesh.visible = true;
                            console.log('Grabbed boid', i);
                            return;
                        }
                    }
                }

                // Handle held voxel (revival or predator creation)
                if (hand.userData.heldVoxelIndex !== null) {
                    const holdDuration = clock.getElapsedTime() - hand.userData.holdStartTime;
                    const isShaking = hand.userData.shakeIntensity > SHAKE_THRESHOLD;
                    
                    // Debug logging for shake detection
                    if (frameCount % 30 === 0) { // Log every 30 frames
                        console.log('Shake detection:', {
                            shakeIntensity: hand.userData.shakeIntensity.toFixed(3),
                            threshold: SHAKE_THRESHOLD,
                            isShaking: isShaking,
                            holdDuration: holdDuration.toFixed(2)
                        });
                    }
                    
                    if (!hand.userData.isPinching) {
                        if (isShaking && holdDuration >= 1.0) {
                            // Create predator from vigorous shaking
                            const predator = new Predator(heldVoxelMesh.position.clone());
                            predators.push(predator);
                            console.log('Predator created! Total predators:', predators.length);
                        } else if (holdDuration >= REVIVAL_TIME) {
                            // Normal revival
                            boids.push(new Boid(heldVoxelMesh.position.clone()));
                            console.log('Boid revived! Total boids:', boids.length);
                        } else {
                            // Don't return fountain voxels - they should fade naturally
                            console.log('Fountain voxel released');
                        }
                        
                        hand.userData.heldVoxelIndex = null;
                        heldVoxelMesh.visible = false;
                        heldVoxelMesh.position.set(0, -1000, 0); // Move far away
                    } else if (isShaking) {
                        // Visual feedback for shaking - turn red
                        heldVoxelMesh.material.color.set(0xff0000);
                        heldVoxelMesh.material.emissive.set(0xff0000);
                    }
                }
                
                // Handle held boid (tossing mechanic)
                if (hand.userData.heldBoidIndex !== null) {
                    const boid = boids[hand.userData.heldBoidIndex];
                    if (!hand.userData.isPinching) {
                        // Release and toss the boid
                        boid.isGrabbed = false;
                        boid.isBeingTossed = true;
                        boid.tossStartTime = clock.getElapsedTime();
                        boid.tossVelocity.copy(hand.userData.velocity);
                        boid.position.copy(heldVoxelMesh.position);
                        
                        hand.userData.heldBoidIndex = null;
                        hand.userData.isGrabbingBoid = false;
                        heldVoxelMesh.visible = false;
                        heldVoxelMesh.position.set(0, -1000, 0); // Move far away
                        console.log('Boid tossed');
                    }
                }
            } catch (error) {
                console.warn('Grabbing error:', error);
            }
        }
        
        function createForceBlastEffect(center, direction) {
            // Create expanding ring of particles to show force blast
            const particleCount = 15; // Reduced for Quest performance
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const radius = 0.5;
                const particle = {
                    position: center.clone(),
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 0.5,
                        Math.sin(angle) * radius
                    ).add(direction.clone().multiplyScalar(0.5)),
                    life: 0.8,
                    color: new THREE.Color(0x00aaff)
                };
                particles.push(particle);
            }
        }
        
        function createParticleExplosion(position) {
            try {
                if (!position) return;
                
                const particleCount = 10; // Reduced for Quest performance
                for (let i = 0; i < particleCount; i++) {
                    const particle = {
                        position: position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        ),
                        life: 1.0,
                        color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 1, 0.5)
                    };
                    particles.push(particle);
                }
            } catch (error) {
                console.warn('Particle explosion error:', error);
            }
        }
        
        function updateFountainVoxels(elapsedTime, deltaTime) {
            try {
                // Spawn new voxels more frequently
                if (elapsedTime - window.lastFountainSpawn > (1.0 / fountainSpawnRate)) {
                    spawnFountainVoxel();
                    window.lastFountainSpawn = elapsedTime;
                    
                    // Occasional fountain activity log
                    if (Math.random() < 0.1) {
                        console.log(`⛲ Fountain spawning voxel - active count: ${fountainVoxels.filter(v => v?.active).length}`);
                    }
                }
                
                // Update existing voxels
                fountainVoxels.forEach((voxel, index) => {
                    if (!voxel) return;
                    
                    // Smooth physics for better VR fountain visibility
                    voxel.velocity.y -= 15.0 * deltaTime; // Stronger gravity for dramatic arcs
                    voxel.position.add(voxel.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Age the voxel
                    voxel.age += deltaTime;
                    
                    // Fade out over time
                    const fadeStart = voxelLifetime * 0.7;
                    if (voxel.age > fadeStart) {
                        const fadeProgress = (voxel.age - fadeStart) / (voxelLifetime - fadeStart);
                        voxel.opacity = Math.max(0, 1 - fadeProgress);
                    }
                    
                    // Remove expired or fallen voxels
                    if (voxel.age > voxelLifetime || voxel.position.y < -2) {
                        fountainVoxels[index] = null;
                    }
                });
                
            } catch (error) {
                console.warn('Fountain voxel update error:', error);
            }
        }
        
        function spawnFountainVoxel() {
            try {
                // Find empty slot
                let emptyIndex = fountainVoxels.findIndex(voxel => voxel === null);
                if (emptyIndex === -1) {
                    // Remove oldest voxel to make space
                    emptyIndex = 0;
                    fountainVoxels[0] = null;
                }
                
                // Create new voxel with dramatic fountain physics for VR visibility
                const angle = Math.random() * Math.PI * 2;
                const speed = 4.0 + Math.random() * 4.0; // Much faster horizontal speed (4-8)
                const upwardSpeed = 6.0 + Math.random() * 6.0; // Much faster upward speed (6-12)
                
                const newVoxel = {
                    position: window.fountainPosition.clone(),
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        upwardSpeed,
                        Math.sin(angle) * speed
                    ),
                    age: 0,
                    opacity: 1.0,
                    active: true,
                    finalColor: new THREE.Color().setHSL(0.5 + Math.random() * 0.3, 0.8, 0.6)
                };
                
                fountainVoxels[emptyIndex] = newVoxel;
                
                // Occasional debug output to confirm fountain activity
                if (Math.random() < 0.05) {
                    console.log(`Fountain active: ${fountainVoxels.filter(v => v?.active).length}/${fountainVoxelCount} voxels`);
                }
                
            } catch (error) {
                console.warn('Fountain voxel spawn error:', error);
            }
        }

        function updateHandData(hand) {
            try {
                if (hand.joints && hand.joints['index-finger-tip'] && hand.joints['thumb-tip'] && hand.joints['middle-finger-tip']) {
                    hand.userData.isReady = true;
                    const thumbTip = hand.joints['thumb-tip'].position;
                    const indexTip = hand.joints['index-finger-tip'].position;
                    const middleTip = hand.joints['middle-finger-tip'].position;
                    
                    // Store previous position for velocity calculation
                    hand.userData.lastPosition.copy(hand.userData.tipPositions.INDEX);
                    
                    hand.userData.tipPositions.THUMB.copy(thumbTip);
                    hand.userData.tipPositions.INDEX.copy(indexTip);
                    hand.userData.tipPositions.MIDDLE.copy(middleTip);
                    
                    // Update finger indicator position for better hand visibility
                    if (hand.userData.fingerIndicator) {
                        hand.userData.fingerIndicator.position.copy(indexTip);
                        hand.userData.fingerIndicator.position.sub(hand.position);
                    }
                    
                    // Update hand indicator with pulsing effect
                    if (hand.userData.handIndicator && hand.userData.pulsePhase !== undefined) {
                        const pulseScale = 1.0 + Math.sin(clock.getElapsedTime() * 3.0 + hand.userData.pulsePhase) * 0.3;
                        hand.userData.handIndicator.scale.setScalar(pulseScale);
                    }
                    
                    // Calculate hand velocity
                    hand.userData.velocity.subVectors(hand.userData.tipPositions.INDEX, hand.userData.lastPosition);
                    hand.userData.velocity.multiplyScalar(60); // Approximate fps for velocity
                    
                    // Calculate shake intensity
                    const currentSpeed = hand.userData.velocity.length();
                    hand.userData.shakeHistory.push(currentSpeed);
                    if (hand.userData.shakeHistory.length > 5) { // Shorter history for more responsive shaking
                        hand.userData.shakeHistory.shift();
                    }
                    // Use max speed in recent history instead of average for better shake detection
                    hand.userData.shakeIntensity = Math.max(...hand.userData.shakeHistory);
                    
                    // Improved pinch detection
                    const thumbIndexDist = thumbTip.distanceTo(indexTip);
                    const thumbMiddleDist = thumbTip.distanceTo(middleTip);
                    hand.userData.isPinching = thumbIndexDist < 0.03 || thumbMiddleDist < 0.03;
                } else {
                    hand.userData.isReady = false;
                }
            } catch (error) {
                console.warn('Hand tracking error:', error);
                hand.userData.isReady = false;
            }
        }


        function update() {
            const elapsedTime = clock.getElapsedTime();
            const dummy = new THREE.Object3D();
            frameCount++;
            const deltaTime = clock.getDelta();
            
            // Animate the grid pulse lines for retro effect
            const gridPulseLines = scene.getObjectByName('gridPulseLines');
            if (gridPulseLines) {
                const pulseIntensity = (Math.sin(elapsedTime * 2) + 1) / 2;
                gridPulseLines.children.forEach(line => {
                    line.material.opacity = 0.5 + pulseIntensity * 0.4;
                });
            }
            
            // Update punch cooldowns
            if (punchCooldown1 > 0) {
                punchCooldown1 -= deltaTime;
            }
            if (punchCooldown2 > 0) {
                punchCooldown2 -= deltaTime;
            }

            // Only update hand data if XR is active
            if (renderer.xr.isPresenting) {
                updateHandData(hand1);
                updateHandData(hand2);
                handleGrabbing(hand1, heldVoxelMesh1);
                handleGrabbing(hand2, heldVoxelMesh2);
                
                // Handle Game of Life touch interaction
                handleGameOfLifeTouch(hand1);
                handleGameOfLifeTouch(hand2);
                
                // Handle teleportation (only use right hand to avoid conflicts)
                handleTeleportation(hand2, elapsedTime);
                
                // Handle punch detection
                [hand1, hand2].forEach((hand, index) => {
                    try {
                        const currentCooldown = index === 0 ? punchCooldown1 : punchCooldown2;
                        if (currentCooldown > 0 || !hand.userData.isReady) return;
                        
                        hand.userData.isFist = detectFist(hand);
                    
                    // Detect punch (fist moving fast) - reduced threshold
                    if (hand.userData.isFist && hand.userData.punchVelocity > 0.5) {
                        console.log('PUNCH DETECTED! Velocity:', hand.userData.punchVelocity.toFixed(3));
                        punchBlast(hand);
                        if (index === 0) {
                            punchCooldown1 = PUNCH_COOLDOWN;
                        } else {
                            punchCooldown2 = PUNCH_COOLDOWN;
                        }
                    }
                    
                    // Debug punch detection
                    if (frameCount % 60 === 0 && hand.userData.isFist) {
                        console.log('Fist detected, velocity:', hand.userData.punchVelocity.toFixed(3), 'threshold: 0.5');
                    }
                    
                    // Track punch velocity (change in fist position)
                    if (hand.userData.isFist) {
                        hand.userData.punchVelocity = hand.userData.velocity ? hand.userData.velocity.length() : 0;
                    } else {
                        hand.userData.punchVelocity = 0;
                    }
                } catch (error) {
                    console.warn('Punch detection error:', error);
                }
            });
            }
            
            // Update particles
            try {
                particles = particles.filter(particle => {
                    if (!particle || !particle.position || !particle.velocity) return false;
                    
                    particle.life -= deltaTime * 2;
                    if (particle.life <= 0) return false;
                    
                    particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
                    particle.velocity.multiplyScalar(0.98); // Friction
                    return true;
                });
            } catch (error) {
                console.warn('Particle update error:', error);
                particles = []; // Clear particles on error
            }

            // Update held objects for both hands
            [hand1, hand2].forEach((hand, handIndex) => {
                // Check if hand tracking data is available
                if (!hand.userData || !hand.userData.tipPositions || !hand.userData.tipPositions.INDEX) {
                    return; // Skip if hand tracking not ready
                }
                
                const heldMesh = handIndex === 0 ? heldVoxelMesh1 : heldVoxelMesh2;
                
                // Update held voxel (revival mechanic)
                if (hand.userData.heldVoxelIndex !== null) {
                    const voxelData = fountainVoxels[hand.userData.heldVoxelIndex];
                    if (voxelData) {
                        heldMesh.position.copy(hand.userData.tipPositions.INDEX);
                        const chargeRatio = Math.min((elapsedTime - hand.userData.holdStartTime) / REVIVAL_TIME, 1.0);
                        const finalColor = new THREE.Color(0x00ffaa); // Default final color
                        heldMesh.material.color.lerpColors(new THREE.Color(0x550055), finalColor, chargeRatio);
                        heldMesh.material.emissive.lerpColors(new THREE.Color(0x550055), finalColor, chargeRatio);
                    }
                }
                
                // Update held boid position
                if (hand.userData.heldBoidIndex !== null) {
                    const boid = boids[hand.userData.heldBoidIndex];
                    heldMesh.position.copy(hand.userData.tipPositions.INDEX);
                    boid.position.copy(heldMesh.position);
                    
                    // Visual feedback for held boid
                    const holdTime = elapsedTime - hand.userData.holdStartTime;
                    const pulseFactor = (Math.sin(holdTime * 10) + 1) / 2;
                    heldMesh.material.emissive.setRGB(0.8 * pulseFactor, 0.2 * pulseFactor, 0.2 * pulseFactor);
                }
            });
            
            
            // Update fountain voxels
            updateFountainVoxels(elapsedTime, deltaTime);
            
            // Update Game of Life
            updateGameOfLife(elapsedTime);
            
            // Update Battle Zone tank battle
            updateTankBattle(deltaTime, elapsedTime);
            
            // Update sky battle and starfield
            updateSkyBattle(deltaTime, elapsedTime);
            
            // Update Tron light cycles
            updateLightCycles(deltaTime, elapsedTime);
            
            let activeFountainCount = 0;
            fountainVoxels.forEach((voxel, i) => {
                if (voxel && voxel.active) {
                    dummy.position.copy(voxel.position);
                    dummy.updateMatrix();
                    fountainVoxelsMesh.setMatrixAt(activeFountainCount++, dummy.matrix);
                }
            });
            
            // Update fountain mesh if it exists
            if (fountainVoxelsMesh) {
                fountainVoxelsMesh.count = activeFountainCount;
                fountainVoxelsMesh.instanceMatrix.needsUpdate = true;
                fountainVoxelsMesh.visible = true;
            }

            const aliveVoxelsMesh = scene.getObjectByName('alive_voxels');
            if (aliveVoxelsMesh && boids.length > 0) {
                aliveVoxelsMesh.count = boids.length;
                
                // Performance optimization: only update flocking every few frames for distant boids
                const shouldUpdateFlocking = frameCount % OPTIMIZATION_INTERVAL === 0;
                
                boids.forEach((boid, i) => {
                    if (!boid.isGrabbed) {
                        if (shouldUpdateFlocking || boid.isBeingTossed) {
                            boid.flock(boids, [hand1, hand2], obstacles, predators);
                        }
                        boid.checkBounds();
                    }
                    boid.update();
                    dummy.position.copy(boid.position);
                    if (boid.velocity.length() > 0.01) {
                        dummy.lookAt(boid.position.clone().add(boid.velocity));
                    }
                    dummy.updateMatrix();
                    aliveVoxelsMesh.setMatrixAt(i, dummy.matrix);
                });
                aliveVoxelsMesh.instanceMatrix.needsUpdate = true;
                
                // Update predators
                const predatorMesh = scene.getObjectByName('predators');
                if (predatorMesh && predators.length > 0) {
                    predatorMesh.count = predators.length;
                    predators.forEach((predator, i) => {
                        try {
                            if (!predator.isGrabbed) {
                                predator.hunt(boids);
                                predator.checkBounds();
                            }
                            predator.update();
                            dummy.position.copy(predator.position);
                            if (predator.velocity && predator.velocity.length() > 0.01) {
                                dummy.lookAt(predator.position.clone().add(predator.velocity));
                            }
                            dummy.updateMatrix();
                            predatorMesh.setMatrixAt(i, dummy.matrix);
                        } catch (error) {
                            console.warn('Predator update error:', error);
                        }
                    });
                    predatorMesh.instanceMatrix.needsUpdate = true;
                }
            }
        }

        function render() { renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function init() {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Initialize camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 3);
            
            // Initialize renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Initialize clock
            clock = new THREE.Clock();
            
            // Setup WebXR
            renderer.xr.enabled = true;
            document.body.appendChild(VRButton.createButton(renderer));
            
            // Add hand tracking
            const handModelFactory = new XRHandModelFactory();
            hand1 = renderer.xr.getHand(0);
            hand1.add(handModelFactory.createHandModel(hand1));
            scene.add(hand1);
            
            hand2 = renderer.xr.getHand(1);
            hand2.add(handModelFactory.createHandModel(hand2));
            scene.add(hand2);
            
            // Initialize hand userData
            [hand1, hand2].forEach(hand => {
                hand.userData = {
                    tipPositions: {
                        THUMB: new THREE.Vector3(),
                        INDEX: new THREE.Vector3(),
                        MIDDLE: new THREE.Vector3()
                    },
                    lastPosition: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    shakeHistory: [0, 0, 0, 0, 0],
                    shakeIntensity: 0,
                    isPinching: false,
                    isFist: false,
                    isReady: false,
                    heldVoxelIndex: null,
                    heldBoidIndex: null,
                    holdStartTime: 0,
                    isGrabbingBoid: false,
                    punchVelocity: 0
                };
            });
            
            // Setup lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create boids
            for (let i = 0; i < initialBoidCount; i++) {
                const boid = new Boid(
                    new THREE.Vector3(
                        (Math.random() - 0.5) * boundSize,
                        Math.random() * 5 + 1,
                        (Math.random() - 0.5) * boundSize
                    )
                );
                boids.push(boid);
            }
            
            // Create world content
            createVectorGridGround();
            createTronTrees();
            createFountain();
            createGameOfLifeMonolith();
            createTankBattlefield();
            createSpaceBattle();
            createLightCycleRacing();
            
            // Setup event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Add fallback controls for desktop
            addFallbackControls();
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }
        
        function animate() {
            update();
            render();
        }

        // Call init after all definitions
        init();
    </script>
</body>
</html>